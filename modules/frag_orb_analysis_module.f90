!
! ParaGauss,  a program package  for high-performance  computations of
! molecular systems
!
! Copyright (C) 2014     T. Belling,     T. Grauschopf,     S. Krüger,
! F. Nörtemann, M. Staufer,  M. Mayer, V. A. Nasluzov, U. Birkenheuer,
! A. Hu, A. V. Matveev, A. V. Shor, M. S. K. Fuchs-Rohr, K. M. Neyman,
! D. I. Ganyushin,   T. Kerdcharoen,   A. Woiterski,  A. B. Gordienko,
! S. Majumder,     M. H. i Rotllant,     R. Ramakrishnan,    G. Dixit,
! A. Nikodem, T. Soini, M. Roderus, N. Rösch
!
! This program is free software; you can redistribute it and/or modify
! it under  the terms of the  GNU General Public License  version 2 as
! published by the Free Software Foundation [1].
!
! This program is distributed in the  hope that it will be useful, but
! WITHOUT  ANY   WARRANTY;  without  even  the   implied  warranty  of
! MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE. See  the GNU
! General Public License for more details.
!
! [1] http://www.gnu.org/licenses/gpl-2.0.html
!
! Please see the accompanying LICENSE file for further information.
!
!=====================================================================
! Public interface of module
!=====================================================================
module  frag_orb_analysis_module
  !-------------------------------------------------------------------
  !
  !  Purpose: module performs a fragment_orbital_analysis
  !           every molecular system can be divided into
  !           arbitrary number of fragments. Every atom
  !           of the system must appear in exactly one fragment.
  !           the fragments have to be calculated with the same
  !           input parameters and the same geometry as the complete
  !           system. For every fragment a file saved_fragment.dat<i>,
  !           with i the number of the fragment must exist in the input
  !           directory. This file is generated by setting the switch
  !           save_as_fragment in namelist recover_options to true.
  !           For the complete system the file saved_eigenvec.dat must
  !           exist and contain all eigenvectors ( save_eigenvec_all=t).
  !           As a result one gets Populations in terms of the fragment
  !           orbitals and the corresponding MO coefficients.
  !
  !           input switches:
  !
  !           n_fragments: number of fragments
  !           eig_min
  !           eig_max:     only orbitals with energies lieing between
  !                        will be listed in the output
  !           n_atoms:     number of atoms in the fragment
  !  Module called by: main_master
  !
  !  References:
  !
  !
  !  Author: MS
  !  Date: 12/97
  !
  !-------------------------------------------------------------------
  !== Interrupt of public interface of module ========================
  !-------------------------------------------------------------------
  ! Modifications
  !-------------------------------------------------------------------
  !
  ! Modification
  ! Author: TS
  ! Date:   1/15
  ! Description: Reworking module to use it with current build
  !
  ! Modification (Please copy before editing)
  ! Author: ...
  ! Date:   ...
  ! Description: ...
  !
  !-------------------------------------------------------------------
  use type_module ! type specification parameters
  use datatype
  use occupation_module
  use density_data_module
  use symmetry_data_module
  use unique_atom_module
  use overlap_module
  use iounitadmin_module
  use operations_module, only: operations_echo_input_level, operations_scf
  use eigen_data_module
  implicit none
  save            ! save all variables defined in this module
  private         ! by default, all names are private
  !== Interrupt end of public interface of module ====================

  type fragment_type ! used to describe fragments
     !in fragment orbital analysis
     integer(kind=i4_kind)              :: n_atoms  ! number of atoms in this fragment
     integer(kind=i4_kind), allocatable :: atoms(:) ! indices of fragment atoms
     logical                            :: active   ! perform FMO on fragment
  end type fragment_type

  !------------ public functions and subroutines ---------------------
  public frag_orb_analysis_read, frag_orb_analysis_write, frag_orb_analysis_main
  !external dgeco, dgedi !!!!!!!!!!!!!!!!!!!!!

  !===================================================================
  ! End of public interface of module
  !===================================================================

  !------------ Declaration of constants and variables ---------------

  type(pop_store_type), allocatable :: pop_store(:,:,:)
  ! pop_store(n_irrep,n_spin,n_fragments)

  type(fragment_type), allocatable :: fragments(:) ! store information
                                                   ! about fragments

  integer(kind=i4_kind) :: df_n_fragments=0, &
                           df_n_atoms=0

  real(kind=r8_kind)    :: df_eig_min=-100.0_r8_kind,   &
                           df_eig_max=10.0_r8_kind

  integer(kind=i4_kind) :: n_fragments, & ! number of fragments
                           n_atoms         ! number of atoms per fragment

  real(kind=r8_kind)    :: eig_min,     &  ! minimal value of eigenvalue,
                                           ! for wich frag_orb_anal will be
                                           ! performed ( in ev)
                           eig_max
  logical               :: df_active = .TRUE.
  logical               :: active

  namelist /frag_orb_analysis/ n_fragments, eig_min, eig_max

  namelist /fragment/ n_atoms, active

  !-------------------------------------------------------------------
  !------------ Subroutines ------------------------------------------
contains


  !*************************************************************

  subroutine frag_orb_analysis_read()
    ! purpose: read in input
    !
    !** End of interface *****************************************
    !------------ Modules used ----------------------------------
    use input_module
    integer :: unit, status, alloc_stat, i_frag, i_atom
    logical :: atom_check(n_unique_atoms), true=.true.
    !------------ Executable code ------------------------------------
    ! population_level = df_population_level
    n_fragments=df_n_fragments
    eig_min=df_eig_min
    eig_max=df_eig_max
    atom_check=.false.
    if ( input_line_is_namelist("frag_orb_analysis") ) then
       call input_read_to_intermediate
       unit = input_intermediate_unit()
       read(unit, nml=frag_orb_analysis, iostat=status)
       if (status .gt. 0) call input_error( "frag_orb_analysis_read: namelist frag_orb_analysis" )
    endif
    if(n_fragments<0.or.n_fragments>n_unique_atoms) &
         call input_error( 'frag_orb_analysis_read: sensless value for n_fragments' )
    if(eig_min>=eig_max) call input_error( 'frag_orb_analysis_read: sensless value for eig_min or eig_max' )
    eig_min=eig_min/27.211652_r8_kind
    eig_max=eig_max/27.211652_r8_kind
    if(n_fragments>0) then
       allocate(fragments(n_fragments), stat=alloc_stat)
       if(alloc_stat/=0) call error_handler(&
            'frag_orb_analysis_read: allocating fragments failed')
       do i_frag=1,n_fragments
          active = df_active
          if ( input_line_is_namelist("fragment") ) then
             call input_read_to_intermediate
             unit = input_intermediate_unit()
             read(unit, nml=fragment, iostat=status)
             if (status .gt. 0) call input_error( "frag_orb_analysis_read: namelist frag_orb_analysis" )
             if(n_atoms < 0.or.n_atoms > n_unique_atoms) call input_error( 'frag_orb_analysis_read: n_atoms is senseless' )
             fragments(i_frag)%n_atoms = n_atoms
             fragments(i_frag)%active  = active
             allocate(fragments(i_frag)%atoms(n_atoms), stat=alloc_stat)
             if(alloc_stat/=0) call error_handler( 'frag_orb_analysis_read: allocating fragments%atoms failed' )
              call input_read_to_intermediate
             unit = input_intermediate_unit()
             read(unit,*,iostat=status)  fragments(i_frag)%atoms
             if (status .gt. 0) call input_error( "frag_orb_analysis_read: reading atoms")
             do i_atom=1,n_atoms
                if(fragments(i_frag)%atoms(i_atom)<1 .or. fragments(i_frag)%atoms(i_atom)>n_unique_atoms) then
                   call input_error( 'frag_orb_analysis_read: atom is senseless' )
                elseif ( atom_check(fragments(i_frag)%atoms(i_atom) ) ) then
                   call input_error( 'frag_orb_analysis_read: atom appears in multiple fragments' )
                end if
                atom_check(fragments(i_frag)%atoms(i_atom))=atom_check(fragments(i_frag)%atoms(i_atom)) .neqv.true
             end do
          else
             call input_error(&
                  'frag_orb_analysis_read: namelist fragment required')
          endif
       end do
       if(.not.all(atom_check)) &
            call input_error(&
            'frag_orb_analysis_read: error in definition of fragments')
    end if
  end subroutine frag_orb_analysis_read

  !*************************************************************

  subroutine frag_orb_analysis_write(iounit)
    !
    ! Write input to iounit in input format.
    !
    use echo_input_module
    implicit none
    integer, intent(in) :: iounit
    !** End of interface *****************************************

    integer(kind=i4_kind) :: i_frag

    call start("FRAG_ORB_ANALYSIS","FRAG_ORB_ANALYSIS_WRITE", &
         iounit,operations_echo_input_level)
    call intg("N_FRAGMENTS",n_fragments,df_n_fragments)
    call real("EIG_MIN    ",eig_min*27.211652_r8_kind,df_eig_min)
    call real("EIG_MAX    ",eig_max*27.211652_r8_kind,df_eig_max)
    call stop()
    if(n_fragments>0) then
       do i_frag=1,n_fragments
          call start("FRAGMENT","FRAG_ORB_ANALYSIS_WRITE", &
               iounit,operations_echo_input_level)
          call intg("N_ATOMS",fragments(i_frag)%n_atoms,df_n_atoms)
          call flag("ACTIVE",fragments(i_frag)%active,df_active)
          call stop()
          write(iounit,'(20I4)') fragments(i_frag)%atoms
       end do
    end if
  end subroutine frag_orb_analysis_write

  !*************************************************************


  subroutine frag_orb_analysis_main()
    !  Purpose: main subroutine for doing a population analysis
    !** End of interface *****************************************
    !------------ Modules used ------------------- ---------------
    use filename_module
    use orbitalprojection_module
    use symmetry_data_module
    use readwriteblocked_module
    use unique_atom_module
    use occupation_module
    use population_module, only : popout, m_charge
    use datatype
    use math_module
    !------------ Declaration of local variables ---------------------
    type(readwriteblocked_tapehandle)   :: th
    integer(kind=i4_kind) :: n_spin, i_frag, i_ir, dimi, i_atom, atom_index, &
         n_ir, skip_length, alloc_stat, i_1, i_2, &
         index_start, index_end, i_start, i_end, i_l, i_spin, i_orb, orb_index,&
         i_eig, i, orb_index_keep, counter, i_i, n, n_tot, n_eig
    integer(kind=i4_kind),allocatable :: dim_irrep(:,:), fmo_index(:)
    real(kind=r8_kind), allocatable :: buffer(:)
    real(kind=r8_kind), allocatable :: Vall(:,:), VTSW(:,:), Vtil(:,:), SW(:,:)
    real(kind=r8_kind), allocatable :: contribute_f(:,:), sum_f(:), sum_ocup_f(:)
    type(arrmat3), allocatable      :: eigvec_frag(:,:)
    character(len=100)              :: chfrag
    character(len=100), allocatable :: title_cont(:)
    character(len=100), allocatable :: title_f(:)
    character(len=100), allocatable :: title_sum(:)
    character(len=100)              :: fchar, fmochar
    real(kind=r8_kind), allocatable :: dummy1(:), dummy2(:,:)

    external error_handler
    intrinsic transpose
    !------------ Executable code ------------------------------------
    if (.not. allocated( m_charge ) ) allocate( m_charge(size(unique_atoms) ) )
    write(output_unit,'(A30)') 'Fragment orbital analysis:'
    write(output_unit,'(A22,i4)') 'Number of fragments:',n_fragments
    do i_frag=1,n_fragments
       if ( fragments(i_frag)%active ) then
          write(output_unit,*) 'Fragment',i_frag,'consists of',fragments(i_frag)%n_atoms,'atoms'
          write(output_unit,'(20I4)') fragments(i_frag)%atoms
       endif
    end do
    write(output_unit,'(A12,F8.4)') 'eig_min:',eig_min
    write(output_unit,'(A12,F8.4)') 'eig_max:',eig_max

    n_spin=ssym%n_spin
    allocate( dim_irrep(ssym%n_irrep,n_fragments), fmo_index(n_fragments), eigvec_frag(ssym%n_irrep,n_fragments), stat=alloc_stat )
    if(alloc_stat/=0) call error_handler( 'fragment_orbital_analysis: allocating dim_irrep' )
    fmo_index = 0
    n_spin=ssym%n_spin
    do i_frag=1,n_fragments
       ! first we calculate the dimension of the irreps
       do i_ir=1,ssym%n_irrep
          dimi=0
          do i_atom=1,fragments(i_frag)%n_atoms
             ! loop over angular momentum
             atom_index=fragments(i_frag)%atoms(i_atom)
             do i_l=0,unique_atoms(atom_index)%lmax_ob
                dimi=dimi+unique_atoms(atom_index)%symadapt_partner(i_ir,i_l)%N_independent_fcts &
                         * (unique_atoms(atom_index)%l_ob(i_l)%N_uncontracted_fcts               &
                          + unique_atoms(atom_index)%l_ob(i_l)%N_contracted_fcts)
             enddo! i_l
          end do! loop over atoms
          dim_irrep(i_ir,i_frag)=dimi
       end do! loop over irreps
       ! now determine sum of non empty irreps and allocate
       n_ir=0
       do i_ir=1,ssym%n_irrep
          if(dim_irrep(i_ir,i_frag)>0) then
             n_ir=n_ir+1
             allocate(eigvec_frag(i_ir,i_frag)%m(&
                  dim_irrep(i_ir,i_frag),dim_irrep(i_ir,i_frag),n_spin),&
                  stat=alloc_stat)
             if(alloc_stat/=0) call error_handler( 'fragment_orbital_analysis: allocating eigvec_frag' )
          end if
       end do
       ! now read eigenvectors from file
       if ( fragments(i_frag)%active ) then
          write(chfrag,'(i4)') i_frag
          chfrag=adjustl(chfrag)
          call readwriteblocked_startread(trim(inpfile('saved_fragment.dat'//trim(chfrag))),  &
               th,variable_length=.true.)
          ! first we have to skip the parts we don`t need
          skip_length=1+n_spin*n_ir*2
          allocate(buffer(skip_length), stat=alloc_stat)
          if(alloc_stat/=0) call error_handler(&
               'fragment_orbital_analysis: allocating buffer 1')
          call readwriteblocked_read(buffer,th)
          deallocate(buffer, stat=alloc_stat)
          if(alloc_stat/=0) call error_handler(&
               'fragment_orbital_analysis: deallocating buffer 1')
          do i_ir=1,ssym%n_irrep
             if(dim_irrep(i_ir,i_frag)>0) then
                skip_length=dim_irrep(i_ir,i_frag)*2
                allocate(buffer(skip_length), stat=alloc_stat)
                if(alloc_stat/=0) call error_handler(&
                     'fragment_orbital_analysis: allocating buffer 2')
                do i_spin=1,n_spin
                   call readwriteblocked_read(buffer,th)
                   do i_orb=1,dim_irrep(i_ir,i_frag)
                      call readwriteblocked_read(eigvec_frag(i_ir,i_frag)%m(:,i_orb,i_spin),th)
                   end do
                end do
                deallocate(buffer, stat=alloc_stat)
                if(alloc_stat/=0) call error_handler(&
                     'fragment_orbital_analysis: deallocating buffer 2')
             end if
          end do
          call readwriteblocked_stopread(th)
       end if
    end do! loop over fragments
    ! now we have everything read in and we start building the eigenvectors
    ! from the fragment orbitals
    do i_spin=1,n_spin
       do i_ir=1,ssym%n_irrep
          dimi = ssym%dim(i_ir)
          allocate( Vall(dimi, dimi), VTSW(dimi, dimi), Vtil(dimi, dimi), SW(dimi, dimi), stat=alloc_stat )
          if(alloc_stat/=0) call error_handler( 'fragment_orbital_analysis: allocating VTSW' )
          Vall           = 0.0_r8_kind
          orb_index      = 1
          orb_index_keep = 1
          do i_frag = 1, n_fragments
             if(dim_irrep(i_ir,i_frag)> 0) then
                 index_start=1
                 do i_atom=1,fragments(i_frag)%n_atoms
                    atom_index=fragments(i_frag)%atoms(i_atom)
                    orb_index=orb_index_keep
                    i_start=orbitalprojection_ob(i_ir,0,atom_index)
                    if(atom_index==n_unique_atoms) then
                       i_end=ssym%dim(i_ir)
                    else
                       i_end=orbitalprojection_ob(i_ir,0,atom_index+1)-1
                    end if
                    index_end=index_start+i_end-i_start
                    if ( fragments(i_frag)%active ) then
                       do i_orb=1,dim_irrep(i_ir,i_frag)
                          Vall(i_start:i_end,orb_index)=eigvec_frag(i_ir,i_frag)%m(index_start:index_end,i_orb,i_spin)
                          orb_index=orb_index+1
                       end do! loop over i_orb
                    else
                       do i_orb=1,dim_irrep(i_ir,i_frag)
                          Vall(orb_index,orb_index) = 1.0_r8_kind
                          orb_index=orb_index+1
                       enddo
                    endif
                    index_start=index_end+1
                 end do! loop over atoms
                 orb_index_keep=orb_index
              end if
          enddo ! i_frag
          !
          ! Determine first and last MO to be considered in output
          !
          index_start = 1
          do i_eig = 1, ssym%dim(i_ir)
             if (eigval(i_ir)%m(i_eig,i_spin) > eig_min) then
                index_start = i_eig
                exit
             endif
          enddo
          index_end = ssym%dim(i_ir)
          do i_eig = index_start, ssym%dim(i_ir)
             if (eigval(i_ir)%m(i_eig,i_spin) > eig_max) then
                index_end = i_eig - 1
                exit
             endif
          enddo
          n_eig = index_end + 1 - index_start
          !
          n_tot = 0
          do i_frag = 1, n_fragments
             if ( fragments(i_frag)%active ) n_tot = n_tot + dim_irrep(i_ir, i_frag)
          enddo
          !
          allocate(title_f(n_tot), contribute_f(n_eig, n_tot), sum_f(n_tot), sum_ocup_f(n_tot), STAT=alloc_stat)
          if(alloc_stat/=0) call error_handler( 'fragment_orbital_analysis: allocate title_f' )
          !
          ! prepare header for popout block
          n=0
          do i_frag = 1, n_fragments
             if ( fragments(i_frag)%active ) then
                write(fchar,*) i_frag
                do i_orb = 1, dim_irrep(i_ir, i_frag)
                   fmo_index(i_frag) = fmo_index(i_frag) + 1
                   write(fmochar,*) fmo_index(i_frag)
                   n = n + 1
                   title_f(n) = trim(adjustl(fchar))//'F'//trim(adjustl(fmochar))
                enddo
             endif
          enddo
          !
          !
          ! FMO populations are (formally) obtained from the population matrix SP which
          ! is transformed by the fragment MOs V according to
          !
          !                 -1
          !     V ( S Pi ) V
          !
          ! where Pi is to be understood as the projector
          !
          !               T
          !     Pi = Wi Wi
          !
          ! onto the eigenvectors Wi of the complete system. The final FMO populations
          ! are computed from the two vectors (note the row-wise storage format of eigenvectors)
          !
          !        T                          -1    T
          ! 1.    V S Wi       and   2.    ( V  Wi )
          !
          ! Vectors 1. (Vtil is intermediate here)
          Vtil = matmul( overlap(i_ir)%m, eigvec(i_ir)%m(:,:, i_spin) )
          VTSW = matmul( transpose(Vall), Vtil )
          !
          ! Vectors 2.
          call invert_matrix(ssym%dim(i_ir), Vall)
          Vtil = matmul( Vall, eigvec(i_ir)%m(:,:, i_spin) )
          !
          ! Compute contributions
          sum_f        = 0.0_r8_kind
          sum_ocup_f   = 0.0_r8_kind
          contribute_f = 0.0_r8_kind
          counter      = 0
          do i_eig = index_start, index_end
             counter = counter + 1
             i_1  = 0
             i_2  = 0
             do i_frag = 1, n_fragments
                if ( fragments(i_frag)%active ) then
                   do i_i = 1, dim_irrep(i_ir, i_frag)
                      i_1 = i_1 + 1
                      i_2 = i_2 + 1
                      contribute_f(counter, i_2) = VTSW(i_1, i_eig) * Vtil(i_1, i_eig)
                      sum_f(i_2)                 = sum_f(i_2) + contribute_f(counter, i_2)
                      sum_ocup_f(i_2)            = sum_ocup_f(i_2) + contribute_f(counter, i_2) * occ_num(i_ir)%m(i_eig, i_spin)
                   enddo
                else
                   i_1 = i_1 + dim_irrep(i_ir, i_frag)
                endif
             enddo
          enddo
          !
          !
          ! Printout occupation table
          !
          call popout(i_spin, i_ir, index_start, index_end, .true., ssym, &
                      title_cont, title_f, title_sum,&
                      dummy2, contribute_f, sum_f, sum_ocup_f, &
                      dummy1, dummy1, dummy1, dummy2, [(9999.999_r8_kind, i=1,size(unique_atoms))])
          !
          ! Clean up for next irrep
          deallocate( Vall, VTSW, Vtil, SW, stat=alloc_stat )
          if(alloc_stat/=0) call error_handler( 'fragment_orbital_analysis: deallocating VTSW' )
          deallocate(title_f, contribute_f, sum_f, sum_ocup_f, STAT=alloc_stat)
          if(alloc_stat/=0) call error_handler( 'fragment_orbital_analysis: deallocating title_f' )
       enddo ! i_ir
    enddo ! i_spin
    !
  end subroutine frag_orb_analysis_main

  !*************************************************************

  !--------------- End of module -------------------------------------
end module frag_orb_analysis_module
