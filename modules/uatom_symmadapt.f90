!
! ParaGauss, a program package for high-performance computations
! of molecular systems
! Copyright (C) 2014
! T. Belling, T. Grauschopf, S. Krüger, F. Nörtemann, M. Staufer,
! M. Mayer, V. A. Nasluzov, U. Birkenheuer, A. Hu, A. V. Matveev,
! A. V. Shor, M. S. K. Fuchs-Rohr, K. M. Neyman, D. I. Ganyushin,
! T. Kerdcharoen, A. Woiterski, A. B. Gordienko, S. Majumder,
! M. H. i Rotllant, R. Ramakrishnan, G. Dixit, A. Nikodem, T. Soini,
! M. Roderus, N. Rösch
!
! This program is free software; you can redistribute it and/or modify it
! under the terms of the GNU General Public License version 2 as published
! by the Free Software Foundation [1].
!
! This program is distributed in the hope that it will be useful, but
! WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
! General Public License for more details.
!
! [1] http://www.gnu.org/licenses/gpl-2.0.html
!
! Please see the accompanying LICENSE file for further information.
!
!===============================================================
! Public interface of module
!===============================================================
module uatom_symmadapt
  !---------------------------------------------------------------
  !
  !  Purpose: ...
  !
  !
  !  Module called by: ...
  !
  !
  !  References: ...
  !
  !
  !  Author: ...
  !  Date: ...
  !
  !
  !----------------------------------------------------------------
  !== Interrupt of public interface of module =====================
  !----------------------------------------------------------------
  ! Modifications
  !----------------------------------------------------------------
  !
  ! Modification (Please copy before editing)
  ! Author: ...
  ! Date:   ...
  ! Description: ...
  !
  !----------------------------------------------------------------

# include "def.h"
  use type_module, only:&
       & IK=>i4_kind,&
       & RK=>r8_kind ! type specification parameters
  implicit none
  save            ! save all variables defined in this module
  private         ! by default, all names are private
  !== Interrupt end of public interface of module =================


  !------------ Declaration of types ------------------------------

  type, public :: symadapt_type
     ! describes the symmetry adaption of contracted or primitive basis functions
     ! of any kind. A symmetry adapted function is generated by summing over all
     ! functions described here
     integer                           :: N_fcts
     ! Number of contracted basis functions contributing
     integer, allocatable              :: I_equal_atom(:) ! I_equal_atom(N_fcts)
     ! Index of equal atom for each fct contributing
     integer, allocatable              :: m(:) ! m(N_fcts)
     ! magnetical quantum number of each fct contributing
     real(RK), allocatable             :: c(:) ! c(N_fcts)
     ! coefficient of each fct contributing
  end type symadapt_type


  type, public :: sa_int_type
     ! describes the symmetry adaption of integrals.
     ! A instance of this type exists for each equal atom.
     ! A symmetry adapted function is generated by summing over all
     ! equal atoms and all m listed here.
     integer                           :: n_fcts
     ! Number of contracted basis functions contributing
     integer, allocatable              :: m(:) ! m(n_fcts)
     ! magnetical quantum number of each fct contributing
     real(RK), allocatable   :: c(:) ! c(n_fcts)
     ! coefficient of each fct contributing

     ! if cmplx then only use %re and %im, otherwise %c:
     logical :: cmplx

     real(RK), allocatable :: re(:) ! (n_fcts)
     real(RK), allocatable :: im(:) ! (n_fcts)
  end type sa_int_type

  type, public :: partner_type
     ! describes the symmetry adaption of contracted basis functions
     ! of any kind for all partners of one irrep. One instance
     ! exits for each (ua, irrep, l).
     ! The description of symmetetry adapted functions by
     ! unique_atom_symadapt_type and unique_atom_sa_int_type
     ! is redundandent. Both can be used alternatively.
     integer(IK)                                  :: n_independent_fcts
     integer(IK)                                  :: n_ea,n_partn ! <++
     logical                                      :: spor !<++
     ! Spin-Orbit ???
     type(symadapt_type), allocatable :: symadapt(:,:)
     ! symadapt(N_independent_fcts,N_partner)
     ! N_partner number of partners within irrep.
     ! Describes symmetry adaption of basis functions.
     ! Each instance of type directley describes complete
     ! symmetry adapted function.
     type(sa_int_type), allocatable   :: sa_int(:,:,:)
     ! symadapt(N_equal_atoms,N_independent_fcts,N_partner)
     ! N_partner number of partners within irrep.
     ! Describes symmetry adaption of integrals. A symmetry
     ! adapted function is obtained by summing over the
     ! contributions of all equal atoms.
     type(sa_int_type), allocatable   :: sa_spor_int(:,:,:,:)
     ! symadapt(N_equal_atoms,2,N_independent_fcts,N_partner)
     !                        ^ spin
     ! N_partner number of partners within irrep.
     ! Describes symmetry adaption of integrals. A symmetry
     ! adapted function is obtained by summing over the
     ! contributions of all equal atoms and spins.
  end type partner_type

  type, public :: uatom ! a piece of unique_atom_type
     !
     ! FIXME: these are not present, or have different names
     !        in unique_atom_type:
     !
     logical :: spor ! true if spin-orbit
     integer(IK) :: n_irr, lmax

     !
     ! These will be copied as is into unique_atom_type:
     !
     type(partner_type), allocatable :: symadapt_partner(:, :)
     ! symadapt_partner(n_irreps,0:lmax)
     ! information for symmetry adaption of any basis

     type(partner_type), allocatable :: symadapt_spor_partner(:, :)
     ! symadapt_partner(n_irreps,0:lmax)
     ! information for symmetry adaption of any basis of the spin orbitals
  end type uatom

  !------------ Declaration of constants and variables ------------

  type(uatom), allocatable, public :: uaSymm(:)
  type(uatom), allocatable, public :: uas_Large(:)
  type(uatom), allocatable, public :: uas_Small(:)
  type(uatom), pointer,     public :: uaSymmSpor(:) ! an alias for uas_Large
  target :: uas_Large, uas_Small
  ! Dont be surprized, they are only to store symmetry adaption
  ! coefficients. Lousy solution, I know.


  !------------ Interface statements ------------------------------

  interface sa_alloc ! public alloc
     module procedure alloc_uatom
     module procedure alloc_partner_type
     module procedure alloc_sa_int_type
     module procedure alloc_symadapt_type
  end interface

  interface sa_free ! public recursive dealloc
     module procedure free_uatom
     module procedure free_partner_type
  end interface

  interface sa_cbcast ! public
     module procedure bcast_uatom !
     module procedure bcast_partner_type !
  end interface

  interface sa_cpack ! public
     module procedure pack_uatom
     module procedure pack_partner_type
  end interface

  interface sa_cunpack ! public
     module procedure unpack_uatom
     module procedure unpack_partner_type
  end interface

  interface sa_calc_sa_int ! public
     module procedure calc_sa_int_uatom
  end interface

  !------------ public functions and subroutines ------------------

  public :: uatom_symmadapt_init
  public :: uatom_symmadapt_done
  public :: sa_alloc
  public :: sa_free
  public :: sa_calc_sa_int
  public :: sa_show
  public :: ua_pack_everything
  public :: ua_unpack_everything
  public :: sa_cpack
  public :: sa_cunpack
  public :: sa_cbcast
  public :: uatom_prune

  !================================================================
  ! End of public interface of module
  !================================================================


  !------------ Declaration of types ------------------------------

  !------------ Declaration of constants and variables ----

  logical ::&
       & op_SpinOrbit       = .false.,&
       & op_Initialized     = .false.,&
       & op_SmallComponents = .false.

  integer(IK),parameter :: b_Init  = 1,&
       &                   b_Small = 2


  !----------------------------------------------------------------
  !------------ Subroutines ---------------------------------------
contains

  subroutine uatom_symmadapt_init(spor, n_ua, Large, Small)
    implicit none
    logical,    intent(in), optional :: spor
    integer(IK),intent(in), optional :: n_ua
    type(uatom),intent(in), optional :: Large(:), Small(:)
    logical:: a_switch
    ! *** end of interface ***

    integer(IK) :: memstat

    if(present(spor))then
       op_SpinOrbit = spor
    endif

    if(present(n_ua))then
#if 1 /* mem leak control */
       a_switch=.not.allocated(uaSymm)
       ASSERT(a_switch)
#endif

       allocate(uaSymm(n_ua), STAT=memstat)
       ASSERT(memstat.eq.0)

       if(op_SpinOrbit)then
          allocate(uas_Large(n_ua),uas_Small(n_ua),&
               & STAT=memstat)
          ASSERT(memstat.eq.0)

          uaSymmSpor => uas_Large
       endif
    endif

    if(present(Large))then
       uas_Large = Large
    endif

    if(present(Small))then
       uas_Small = Small
       op_SmallComponents = .true.
    endif

    op_Initialized = .true.
  end subroutine uatom_symmadapt_init

  subroutine uatom_symmadapt_done()
    implicit none
    ! *** end of interface ***

    integer(IK) :: memstat

!    ASSERT(op_Initialized)
    if(.not.op_Initialized) then
       WARN('op_Initialized')
    end if

    if(allocated(uaSymm)) then
     deallocate(uaSymm, STAT=memstat)
     ASSERT(memstat.eq.0)
    endif

    if(op_SpinOrbit)then
       deallocate(uas_Large, uas_Small, STAT=memstat)
       ASSERT(memstat.eq.0)
    endif

    op_Initialized = .false.
  end subroutine uatom_symmadapt_done

  function uatom_prune(old, mask) result(new)
    !
    ! Returns an uatom with symmetry information cleaned
    ! of empty irreps. Mask indicates which ones to be
    ! REMOVED.
    !
    implicit none
    type(uatom), intent(in) :: old
    logical, intent(in) :: mask(:) ! to be removed
    type(uatom) :: new
    ! *** end of interface ***

    integer(IK) :: keep(size(mask)), i, n

    ASSERT(size(mask)==old%n_irr)

    ! will be the number of remaining irreps:
    n = 0
    do i = 1, size(mask)
        if ( mask(i) ) cycle
        n = n + 1
        ! indices of irreps to keep:
        keep(n) = i
    enddo

    ! here n is the number of irreps to keep.
    call alloc_uatom(n, old%lmax, new, spor=old%spor)

    !
    ! We do not assume both are present (number of irreps for vector and
    ! projective irreps is different):
    !
    if ( old%spor ) then
        if ( allocated(old%symadapt_partner) ) then
            ABORT('is this NR?')
        endif
        new%symadapt_spor_partner = old%symadapt_spor_partner(keep(:n), :)
    else
        if ( allocated(old%symadapt_spor_partner) ) then
            ABORT('is this SO?')
        endif
        new%symadapt_partner = old%symadapt_partner(keep(:n), :)
    endif
  end function uatom_prune

  subroutine ua_pack_everything()
  end subroutine ua_pack_everything

  subroutine ua_unpack_everything()
  end subroutine ua_unpack_everything

  subroutine sa_show(ua,what)
    ! been once subroutine unique_atom_calc_symadapt_int()
    implicit none
    type(uatom),intent(inout) :: ua
    integer(IK),intent(in)    :: what
    ! *** end of interface ***

    type(symadapt_type) :: sa
    integer(IK) :: i_ir, i_l, i_pa, i_if

    if(what.ge.0)then
       print *,'uasa/sa_show: SpOr=',ua%spor,'lmax=',ua%lmax,' n_irr=',ua%n_irr
    endif
    if(what.ge.1)then
       i_ir_:do i_ir = 1,ua%n_irr
          i_l_:do i_l = 0,ua%lmax
             print *,'uasa/sa_show: irr=',i_ir,' L=',i_l
             i_pa_:do i_pa = 1, ua%symadapt_partner(i_ir, i_l)%n_partn
                i_if_:do i_if = 1, ua%symadapt_partner(i_ir, i_l)%N_independent_fcts
                   print *,'uasa/sa_show:  p=',i_pa,' if=',i_if
                   ! FIXME: is it a copy or a ref?
                   sa = ua%symadapt_partner(i_ir, i_l)%symadapt(i_if, i_pa)
                   if(sa%n_fcts > 0)then
                      print *,'uasa/sa_show: sa%n_fcts=',sa%n_fcts
                      print *,'uasa/sa_show: sa%I_equal_atom =',sa%I_equal_atom
                      print *,'uasa/sa_show: sa%m            =',sa%m
                      print *,'uasa/sa_show: sa%c            =',sa%c
                   else
                      print *,'uasa/sa_show: sa%n_fcts=',sa%n_fcts
                   endif
                end do i_if_
             end do i_pa_
          end do i_l_
       end do i_ir_
    endif
  end subroutine sa_show

  subroutine calc_sa_int_uatom(ua)
    ! been once subroutine unique_atom_calc_symadapt_int()
    implicit none
    type(uatom),intent(inout) :: ua
    ! *** end of interface ***

    integer(IK) :: i_ir, i_l

    do i_ir = 1, ua%n_irr
       do i_l = 0, ua%lmax
          call calc_sa_int_partner_type(ua%symadapt_partner(i_ir, i_l))
       enddo
    enddo
  end subroutine calc_sa_int_uatom

  subroutine calc_sa_int_partner_type(pa)
    ! been once subroutine unique_atom_calc_symadapt_int()
    implicit none
    type(partner_type), intent(inout) :: pa
    ! *** end of interface ***

    integer(IK) :: i_pa, i_ea, i_if, i_sa, i_sat

    i_pa_:do i_pa = 1,pa%n_partn
       i_if_:do i_if = 1, pa%N_independent_fcts
          i_ea_:do i_ea = 1, pa%n_ea

             i_sat = 0
             do i_sa = 1, pa%symadapt(i_if, i_pa)%N_fcts
                if ( pa%symadapt(i_if, i_pa)%I_equal_atom(i_sa) .eq. i_ea ) &
                     i_sat = i_sat + 1
             enddo
             call alloc_sa_int_type(i_sat, pa%sa_int(i_ea, i_if, i_pa))

             i_sat = 0
             do i_sa = 1, pa%symadapt(i_if, i_pa)%N_fcts
                if ( pa%symadapt(i_if, i_pa)%I_equal_atom(i_sa) .eq. i_ea ) then
                   i_sat = i_sat + 1
                   pa%sa_int(i_ea, i_if, i_pa)%m(i_sat) =pa%symadapt(i_if, i_pa)%m(i_sa)
                   pa%sa_int(i_ea, i_if, i_pa)%c(i_sat) =pa%symadapt(i_if, i_pa)%c(i_sa)
                endif
             enddo
          enddo i_ea_
       enddo i_if_
    enddo i_pa_
  end subroutine calc_sa_int_partner_type

  subroutine pack_uatom(ua)
    use xpack
    implicit none
    type(uatom),intent(in) :: ua
    ! *** end of interface ***

    integer(IK) :: i,j !!$,k

    call pck(ua%spor)
    call pck(ua%n_irr)
    call pck(ua%lmax)

    if(ua%spor)then
       do i=1,ua%n_irr
          do j=0,ua%lmax
             call pack_partner_type(ua%symadapt_spor_partner(i,j))
          enddo
       enddo
    else
       do i=1,ua%n_irr
          do j=0,ua%lmax
             call pack_partner_type(ua%symadapt_partner(i,j))
          enddo
       enddo
    endif
  end subroutine pack_uatom

  subroutine bcast_uatom(ua)
    use comm,                only: comm_bcast                                  &
                                 , comm_rank
    implicit none
    type(uatom),intent(inout) :: ua
    ! *** end of interface ***

    logical     :: spor
    integer(IK) :: n_irr, lmax, i, j
    !
    if( comm_rank() == 0 ) then
      spor  = ua%spor
      n_irr = ua%n_irr
      lmax  = ua%lmax
    endif
    call comm_bcast( spor  )
    call comm_bcast( n_irr )
    call comm_bcast( lmax  )
    if( comm_rank() /= 0 ) then
      call alloc_uatom(n_irr, lmax, ua, spor=spor)
    endif

    if( ua%spor ) then
      do i =1, ua%n_irr
        do j = 0, ua%lmax
          call bcast_partner_type(ua%symadapt_spor_partner(i, j))
        enddo
      enddo
    else
      do i = 1, ua%n_irr
        do j = 0, ua%lmax
          call bcast_partner_type(ua%symadapt_partner(i, j))
        enddo
      enddo
    endif
  end subroutine bcast_uatom

  subroutine unpack_uatom(ua)
    use xpack
    implicit none
    type(uatom),intent(inout) :: ua
    ! *** end of interface ***

    logical     :: spor
    integer(IK) :: n_irr,lmax,i,j !!$,k

    call upck(spor)
    call upck(n_irr)
    call upck(lmax)

    call alloc_uatom(n_irr, lmax, ua, spor=spor)

    if(ua%spor)then
       do i=1,ua%n_irr
          do j=0,ua%lmax
             call unpack_partner_type(ua%symadapt_spor_partner(i, j))
          enddo
       enddo
    else
       do i=1,ua%n_irr
          do j=0,ua%lmax
             call unpack_partner_type(ua%symadapt_partner(i, j))
          enddo
       enddo
    endif
  end subroutine unpack_uatom

  subroutine alloc_uatom(n_irr, lmax, ua, spor)
    implicit none
    integer(IK), intent(in) :: n_irr, lmax
    type(uatom), intent(inout) :: ua
    logical, optional, intent(in) :: spor
    ! *** end of interface ***

    integer(IK)     :: memstat
    logical         :: spin_orbit

    spin_orbit = .false.
    if(present(spor)) spin_orbit = spor

    ua%spor  = spin_orbit
    ua%n_irr = n_irr
    ua%lmax  = lmax
    if(spin_orbit)then
       allocate(ua%symadapt_spor_partner(n_irr, 0:lmax), STAT=memstat)
       ASSERT(memstat.eq.0)
    else
       allocate(ua%symadapt_partner(n_irr, 0:lmax), STAT=memstat)
       ASSERT(memstat.eq.0)
    endif
  end subroutine alloc_uatom

  subroutine dealloc_uatom(ua)
    implicit none
    type(uatom),intent(inout)   :: ua
    ! *** end of interface ***

    integer(IK)     :: memstat

    if(ua%spor)then
       deallocate(ua%symadapt_spor_partner,STAT=memstat)
       ASSERT(memstat.eq.0)
    else
       deallocate(ua%symadapt_partner,STAT=memstat)
       ASSERT(memstat.eq.0)
    endif
    ua%spor  = .false.
    ua%n_irr = -1
    ua%lmax  = -1
  end subroutine dealloc_uatom

  subroutine free_uatom(ua)
    implicit none
    type(uatom),intent(inout) :: ua
    ! *** end of interface ***

    integer(IK) :: i,j !!$,k !,nirr,lmax

    if(ua%spor)then
       do i=1,ua%n_irr
          do j=0,ua%lmax
             call free_partner_type(ua%symadapt_spor_partner(i, j))
          enddo
       enddo
    else
       do i=1,ua%n_irr
          do j=0,ua%lmax
             call free_partner_type(ua%symadapt_partner(i, j))
          enddo
       enddo
    endif
    call dealloc_uatom(ua)
  end subroutine free_uatom

  subroutine pack_partner_type(pa)
    use xpack
    implicit none
    type(partner_type),intent(in) :: pa
    ! *** end of interface ***

    integer(IK) :: i,j,k,l

    call pck(pa%spor)
    call pck(pa%n_ea)
    call pck(pa%n_independent_fcts)
    call pck(pa%n_partn)
    if(.not.pa%spor)then
       !
       ! pack only symadapt (I_equal_atom) structure:
       ! the rest will be computed after unpacking.
       !
       do i=1,pa%n_independent_fcts
          do j=1,pa%n_partn
             call pack_symadapt_type(pa%symadapt(i, j))
          enddo
       enddo
    else
       !
       ! There is no corresponding "I_equal_atom" struct -
       ! - packing sa_spor_int
       !
       do i=1,pa%n_ea
          do j=1,2
             do k=1,pa%n_independent_fcts
                do l=1,pa%n_partn
                   call pack_sa_int_type(pa%sa_spor_int(i,j,k,l))
                enddo
             enddo
          enddo
       enddo
    endif
  end subroutine pack_partner_type

  subroutine bcast_partner_type(pa)
    use comm,                only: comm_bcast                                  &
                                 , comm_rank
    implicit none
    type(partner_type),intent(inout) :: pa
    ! *** end of interface ***

    integer(IK) :: i, j, k, l
    integer(IK) :: n_ea, n_indep, n_partn
    logical     :: spor

    if( comm_rank() == 0 ) then
      spor    = pa%spor
      n_ea    = pa%n_ea
      n_indep = pa%n_independent_fcts
      n_partn = pa%n_partn
    endif
    call comm_bcast( spor    )
    call comm_bcast( n_ea    )
    call comm_bcast( n_indep )
    call comm_bcast( n_partn )
    if( comm_rank() /= 0 ) then
      call alloc_partner_type(n_ea, n_indep, n_partn, pa, spor=spor)
    endif

    if(.not.pa%spor)then
      !
      ! unpack only symadapt ("I_equal_atom") structure:
      ! the rest will be computed after unpacking.
      !
      do i = 1, pa%n_independent_fcts
        do j = 1, pa%n_partn
          call bcast_symadapt_type(pa%symadapt(i, j))
        enddo
      enddo
      !
      if( comm_rank() /= 0 ) then
        ! Compute sa_int struct which was not sent:
        call calc_sa_int_partner_type(pa)
      endif
      !
    else
      !
      ! There is no corresponding "I_equal_atom" struct -
      ! - packing sa_spor_int
      !
      do i = 1, pa%n_ea
        do j = 1, 2
          do k = 1, pa%n_independent_fcts
            do l = 1, pa%n_partn
              call bcast_sa_int_type(pa%sa_spor_int(i, j, k, l))
            enddo
          enddo
        enddo
      enddo
    endif
  end subroutine bcast_partner_type

  subroutine unpack_partner_type(pa)
    use xpack
    implicit none
    type(partner_type),intent(inout) :: pa
    ! *** end of interface ***

    integer(IK) :: i,j,k,l
    integer(IK) :: n_ea,n_indep,n_partn
    logical     :: spor

    call upck(spor)
    call upck(n_ea)
    call upck(n_indep)
    call upck(n_partn)

    call alloc_partner_type(n_ea, n_indep, n_partn, pa, spor=spor)

    if(.not.pa%spor)then
       !
       ! unpack only symadapt ("I_equal_atom") structure:
       ! the rest will be computed after unpacking.
       !
       do i=1,pa%n_independent_fcts
          do j=1,pa%n_partn
             call unpack_symadapt_type(pa%symadapt(i, j))
          enddo
       enddo
       !
       ! Compute sa_int struct which was not sent:
       !
       call calc_sa_int_partner_type(pa)
    else
       !
       ! There is no corresponding "I_equal_atom" struct -
       ! - packing sa_spor_int
       !
       do i=1,pa%n_ea
          do j=1,2
             do k=1,pa%n_independent_fcts
                do l=1,pa%n_partn
                   call unpack_sa_int_type(pa%sa_spor_int(i, j, k, l))
                enddo
             enddo
          enddo
       enddo
    endif
  end subroutine unpack_partner_type

  subroutine alloc_partner_type(n_ea, n_indep, n_partn, uap, spor)
    implicit none
    integer(IK),intent(in)           :: n_ea,n_indep,n_partn
    type(partner_type),intent(inout) :: uap
    logical,optional,intent(in)      :: spor
    ! *** end of interface ***

    integer(IK) :: memstat
    logical     :: spin_orbit

    spin_orbit    = .false.
    if(present(spor)) spin_orbit = spor

    uap%spor    = spin_orbit
    uap%n_ea    = n_ea
    uap%n_independent_fcts = n_indep
    uap%n_partn = n_partn
    if(spin_orbit)then
       allocate(uap%sa_spor_int(n_ea,2,n_indep,n_partn),STAT=memstat)
       ASSERT(memstat.eq.0)
    else
       allocate(uap%sa_int(n_ea,n_indep,n_partn),STAT=memstat)
       ASSERT(memstat.eq.0)
       !only in no-spin-orbit case >>>
       allocate(uap%symadapt(n_indep,n_partn),STAT=memstat)
       ASSERT(memstat.eq.0)
    endif
  end subroutine alloc_partner_type

  subroutine dealloc_partner_type(uap)
    implicit none
    type(partner_type),intent(inout) :: uap
    ! *** end of interface ***

    integer(IK) :: memstat

    if(uap%spor)then
       deallocate(uap%sa_spor_int,STAT=memstat)
       ASSERT(memstat.eq.0)
    else
       deallocate(uap%sa_int,STAT=memstat)
       ASSERT(memstat.eq.0)
       !only in no-spin-orbit case >>>
       deallocate(uap%symadapt,STAT=memstat)
       ASSERT(memstat.eq.0)
    endif
    uap%spor    = .false.
    uap%n_ea    = -1
    uap%n_independent_fcts = -1
    uap%n_partn = -1
  end subroutine dealloc_partner_type

  subroutine free_partner_type(uap)
    implicit none
    type(partner_type),intent(inout) :: uap
    ! *** end of interface ***

    integer(IK) :: i,j,k,l

    if(uap%spor)then
       do i=1,uap%n_ea
          do j=1,2
             do k=1,uap%n_independent_fcts
                do l=1,uap%n_partn
                   call dealloc_sa_int_type(uap%sa_spor_int(i, j, k, l))
                enddo
             enddo
          enddo
       enddo

    else
       do i=1,uap%n_ea
          do k=1,uap%n_independent_fcts
             do l=1,uap%n_partn
                call dealloc_sa_int_type(uap%sa_int(i, k, l))
             enddo
          enddo
       enddo
       !only in no-spin-orbit case:
       do i=1,uap%n_independent_fcts
          do k=1,uap%n_partn
             call dealloc_symadapt_type(uap%symadapt(i, k))
          enddo
       enddo
    endif
    call dealloc_partner_type(uap)
  end subroutine free_partner_type

  subroutine pack_sa_int_type(sai)
    use xpack
    implicit none
    type(sa_int_type),intent(in) :: sai
    ! *** end of interface ***

    call pck(sai%cmplx)
    call pck(sai%n_fcts)
    call pck(sai%m)

    if(sai%cmplx)then
       call pck(sai%re)
       call pck(sai%im)
    else
       call pck(sai%c)
    endif
  end subroutine pack_sa_int_type

  subroutine bcast_sa_int_type(sai)
    use comm,                only: comm_bcast                                  &
                                 , comm_rank
    implicit none
    type(sa_int_type), intent(inout) :: sai
    ! *** end of interface ***

    logical                          :: cmplx_
    integer(IK)                      :: n_fcts

    if ( comm_rank() == 0 ) then
      cmplx_ = sai%cmplx
      n_fcts = sai%n_fcts
    endif
    call comm_bcast( cmplx_ )
    call comm_bcast( n_fcts )
    if ( comm_rank() /= 0 ) then
      call alloc_sa_int_type(n_fcts, sai, cmplx=cmplx_)
    endif

    call comm_bcast( sai%m  )

    if ( sai%cmplx ) then
      call comm_bcast( sai%re )
      call comm_bcast( sai%im )
    else
      call comm_bcast(sai%c)
    endif
  end subroutine bcast_sa_int_type

  subroutine unpack_sa_int_type(sai)
    use xpack
    implicit none
    type(sa_int_type),intent(inout) :: sai
    ! *** end of interface ***

    integer(IK) :: n_fcts
    logical     :: cmplx_

    call upck(cmplx_)
    call upck(n_fcts)

    call alloc_sa_int_type(n_fcts, sai, cmplx=cmplx_)

    call upck(sai%m)

    if(sai%cmplx)then
       call upck(sai%re)
       call upck(sai%im)
    else
       call upck(sai%c)
    endif
  end subroutine unpack_sa_int_type

  subroutine alloc_sa_int_type(n_fcts, sai, cmplx)
    implicit none
    integer(IK),intent(in)          :: n_fcts
    type(sa_int_type),intent(inout) :: sai
    logical,optional,intent(in)     :: cmplx
    ! *** end of interface ***

    integer(IK) :: memstat
    logical     :: cmplx_

    cmplx_ = .false.
    if(present(cmplx)) cmplx_ = cmplx

    sai%n_fcts = n_fcts
    sai%cmplx  = cmplx_
    if(cmplx_)then
       allocate(sai%m(n_fcts), sai%re(n_fcts), sai%im(n_fcts), STAT=memstat)
       ASSERT(memstat==0)
    else
       allocate(sai%m(n_fcts), sai%c(n_fcts), STAT=memstat)
       ASSERT(memstat==0)
    endif
  end subroutine alloc_sa_int_type

  subroutine dealloc_sa_int_type(sai)
    implicit none
    type(sa_int_type),intent(inout) :: sai
    ! *** end of interface ***

    integer(IK) :: memstat

    if(sai%cmplx)then
       deallocate(sai%m, sai%re, sai%im, STAT=memstat)
       ASSERT(memstat==0)
    else
       deallocate(sai%m, sai%c, STAT=memstat)
       ASSERT(memstat==0)
    endif
    sai%n_fcts = -1
    sai%cmplx  = .false.
  end subroutine dealloc_sa_int_type

  subroutine pack_symadapt_type(sat)
    use xpack
    implicit none
    type(symadapt_type),intent(in) :: sat
    ! *** end of interface ***

    call pck(sat%n_fcts)
    call pck(sat%I_equal_atom)
    call pck(sat%m)
    call pck(sat%c)
  end subroutine pack_symadapt_type

  subroutine bcast_symadapt_type(sat)
    use comm,                only: comm_bcast                                  &
                                 , comm_rank
    implicit none
    type(symadapt_type), intent(inout) :: sat
    ! *** end of interface ***
    integer(IK)                        :: n_fcts

    if ( comm_rank() == 0 ) then
      n_fcts = sat%n_fcts
    endif
    call comm_bcast( n_fcts           )
    if ( comm_rank() /= 0 ) then
      call alloc_symadapt_type(n_fcts, sat)
    endif

    call comm_bcast( sat%I_equal_atom )
    call comm_bcast( sat%m            )
    call comm_bcast( sat%c            )

  end subroutine bcast_symadapt_type

  subroutine unpack_symadapt_type(sat)
    use xpack
    implicit none
    type(symadapt_type),intent(inout) :: sat
    ! *** end of interface ***

    integer(IK) :: n_fcts

    call upck(n_fcts)

    call alloc_symadapt_type(n_fcts, sat)

    call upck(sat%I_equal_atom)
    call upck(sat%m)
    call upck(sat%c)
  end subroutine unpack_symadapt_type

  subroutine alloc_symadapt_type(n_fcts, sat)
    implicit none
    integer(IK),intent(in)            :: n_fcts
    type(symadapt_type),intent(inout) :: sat
    ! *** end of interface ***

    integer(IK) :: memstat

    sat%n_fcts = n_fcts
    allocate(sat%I_equal_atom(n_fcts),sat%m(n_fcts),sat%c(n_fcts),STAT=memstat)
    ASSERT(memstat.eq.0)
  end subroutine alloc_symadapt_type

  subroutine dealloc_symadapt_type(sat)
    implicit none
    type(symadapt_type),intent(inout) :: sat
    ! *** end of interface ***

    integer(IK) :: memstat

    deallocate(sat%I_equal_atom,sat%m,sat%c,STAT=memstat)
    ASSERT(memstat.eq.0)
    sat%n_fcts = -1
  end subroutine dealloc_symadapt_type

  !--------------- End of module ----------------------------------
end module uatom_symmadapt
