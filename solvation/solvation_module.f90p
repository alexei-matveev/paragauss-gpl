!
! ParaGauss, a program package for high-performance computations
! of molecular systems
! Copyright (C) 2014
! T. Belling, T. Grauschopf, S. Krüger, F. Nörtemann, M. Staufer,
! M. Mayer, V. A. Nasluzov, U. Birkenheuer, A. Hu, A. V. Matveev,
! A. V. Shor, M. S. K. Fuchs-Rohr, K. M. Neyman, D. I. Ganyushin,
! T. Kerdcharoen, A. Woiterski, A. B. Gordienko, S. Majumder,
! M. H. i Rotllant, R. Ramakrishnan, G. Dixit, A. Nikodem, T. Soini,
! M. Roderus, N. Rösch
!
! This program is free software; you can redistribute it and/or modify it
! under the terms of the GNU General Public License version 2 as published
! by the Free Software Foundation [1].
!
! This program is distributed in the hope that it will be useful, but
! WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
! General Public License for more details.
!
! [1] http://www.gnu.org/licenses/gpl-2.0.html
!
! Please see the accompanying LICENSE file for further information.
!
! Public interface of module
!===============================================================
module solvation_module
!
!  This module are used to calculate electrostatic
!  contribution to the solvent effect of molecule
!  There are different parts in this module:
!  1) building the molecular cavity and generating
!  the set of cavity surface points using GEPOL_GB
!  algorithm
!  2) calculation of the additional contribution to the free
!  energy of the molecule in the solvent due to the
!  electrostatic interaction between the solute molecule
!  and the induced polarization of the solvent
!  3) calculation of the cavity building energy
!  4) call of routines to calculate the dispersion/repulsion energy
!  5) calculation of gradients of that parts of energy
!     (resp the call of appropriate routines in case of dispersion/repulsion)
!
!== Interrupt of public interface of module =========
!  Author: AS
!  Date: 11/99
!
!----------------------------------------------------------------
! Modifications
!----------------------------------------------------------------
!
! Modification (Please copy before editing)
! Author: MF 
! Date:   2/2000
! Description: Correction in poligon area computing
!              (in case one sphere is more than half inside another)
! Date:   3/2000
! Description: Corrected sign in solvation-hamiltonian
! Date:   4/2000
! Description: Corrected error in cancle tesselation points part
! Date:   4/2000
! Description: Additional local symmetries
! Date:   4/2000
! Description: Choose of maximal tessera area
! Date:   5/2000
! Description: Gradients of Geometric Cavity Properties
! Date:   5,6/2000
! Description: Correction in intersection computing: two intersections
!         per edge possible, compute all tessera sizes with Gauss-Bonnet
!         (because the subdivision scheme can not produce similar,
!         equal sized tessera) 
! Date:   6/2000
! Description: Gradients of cavitation energy (and disp/rep)
! Date:   7/2000
! Description: adaption to VPP
!
! Author: AS
! Date:   4,5,6/2000
! Description: Cavitation,Dispersion and repulsion term, 
! Description: Electrostatic Gradients, Collecting Gradients
!
!----------------------------------------------------------------
!
! Modification (Please copy before editing)
! Author: ...
! Date:   ...
! Description: ...
!
!----------------------------------------------------------------
!== Interrupt end of public interface of module =====              

!----modules used ------------------
! use FPP_USR_TIMERs:
! define FPP_TIMERS 2
# include <def.h>
  use type_module ! type specification parameters
  use datatype
  use filename_module, only: input_dir
  use iounitadmin_module, only: output_unit,write_to_output_units,openget_iounit, &
       returnclose_iounit
  use group_module ,only: symm_transformation_int
  use output_module ,only: output_cavity_data, output_cavity_long
  use atoms_data_module
#ifdef FPP_AIX_XLF
  use matrix_module, only: matmult
# define MATMUL(a,b) matmult(a,b)
#endif
  implicit none

  save            ! save all variables defined in this module
  private         ! by default, all names are private

  logical, public :: stop_solv
  logical, public :: with_pc=.false.
  logical, public :: fixed_pc=.false.
  type(arrmat2), allocatable, public :: F_solv_pc(:)

!------------ public functions and subroutines ------------------
  public solvation_read, solvation_write, check_read, &
       points_on_cavity_surface, &
       solv_poten_transfer_data, solv_elfield_transfer_data, & !send_receive_cavity_matrix 
       const_part_of_ham_and_energy, send_receive_nuc_pot_Q, & 
       build_solv_ham, X_part_of_ham, send_receive_Q_e, alloc_ham_solv, &
       dealloc_ham_solv, solv_energy_el,calc_rho,&
       energy_and_grad_of_cavity,disp_rep_wrap, &
       matrix_grad,nuc_grad,send_receive_geom_grad,&
       dealloc_geom_grad,shutdown_solvation, &
       init_forces_on_pc,solv_forces_on_pc,dealloc_solv_pc

!================================================================
!================================================================
!== Interrupt of public interface of module =========
!----private types
  type, private :: triangles
     real(kind=r8_kind),pointer :: xyz(:,:)
     real(kind=r8_kind),pointer :: xyz_centers(:,:)
     integer(kind=i4_kind),pointer :: index(:,:)
     real(kind=r8_kind) :: radius
     real(kind=r8_kind) :: area
  end type triangles

# define MAX_POL_VER 30
  type, private :: poligon
     integer(kind=i4_kind) :: n_vertises
     real(kind=r8_kind) :: xyz_vertex(MAX_POL_VER,3)
     integer(kind=i4_kind) :: bounds(MAX_POL_VER,2)
     real(kind=r8_kind) :: r_bound(MAX_POL_VER,2)
     real(kind=r8_kind) :: xyz_bound(MAX_POL_VER,6)
     integer(kind=i4_kind) :: n_sphere(MAX_POL_VER,2)
  end type poligon

  type, private :: cavity_data
     integer(kind=i4_kind) :: n_equal
     real(kind=r8_kind),pointer :: xyz(:,:)
     real(kind=r8_kind) :: area
     real(kind=r8_kind) :: r_tes
     integer(kind=i4_kind),pointer :: sphere(:)
     logical :: cut_off
  end type cavity_data

  type, private :: grad_atomic_center
     real(kind=r8_kind), pointer :: xyz_grad(:,:,:)
  end type grad_atomic_center

  type, private :: geom_deriv
     type(grad_atomic_center), pointer :: dc(:,:)
     type(grad_atomic_center), pointer :: dR(:)
     type(arrmat1), pointer :: darea(:,:,:)
     type(arrmat2), pointer :: dcenter(:,:,:)
  end type geom_deriv

!== Interrupt end of public interface of module =====      
!--public types ---
!--type collecting information needed for calculating gradients
  type, public:: grad_data
     real(kind=r8_kind) :: dielconst
     integer(kind=i4_kind) :: n_points
     integer(kind=i4_kind),pointer :: n_equal(:)
     real(kind=r8_kind),pointer :: xyz(:,:,:)
     real(kind=r8_kind),pointer :: s(:)
     integer(kind=i4_kind),pointer :: i_symm_sort(:,:)
     type(arrmat1), pointer :: ds_totsyms(:,:)
     type(arrmat2), pointer :: dxyz_totsyms(:,:)
     real(kind=r8_kind),pointer :: Q(:)
  end type grad_data

!--public variables ---
  !if I will ever calculate this:
  logical, public :: cavitation_energy
  logical, public :: disp_rep_energy
  logical, public :: charge_correction

  !if I will calculate this now:
  logical , public :: do_correction, do_cavitation,do_disp_rep
  logical, public :: do_gradients

  !cycle when I start to include solvent effects
  integer(kind=i4_kind), public :: sol_start_cycle

  !interaction energy between molecule chare (el and nuc) and the
  !polarized solvent:
  real(kind=r8_kind), public :: energy_solv_el
  !caviation energy:
  real(kind=r8_kind), public :: energy_cav
  !additional part of hamiltonian due to interaction with polarization
  !charges of the solvent:
  type(arrmat2),allocatable,public :: ham_solv_el(:)
  !collected data for calculating the solvent specific
  !gradients:
  type(grad_data),public :: to_calc_grads
  !totsym and cartesian gradient of energies speficic to
  !solvent effects:
  real(kind=r8_kind),public,allocatable,target :: grad_solv_totsym(:)
  real(kind=r8_kind),public,allocatable,target :: grad_solv_totsym_tes(:,:) !!!!!!!!!!AS
  type(arrmat2),public,allocatable :: grad_solv_cart(:)
! End of public interface of module

  logical :: save_cav
  type(symm_transformation_int), pointer :: point_trafos(:)
  real(kind=r8_kind), allocatable :: A_matrix(:,:)
  real(kind=r8_kind), public, allocatable :: A_matrix_inv(:,:)
  integer(kind=i4_kind) :: N_total
  integer(kind=i4_kind) :: n_size

  real(kind=r8_kind), allocatable :: Q_n(:), Q_e(:)
  real(r8_kind),  public, allocatable :: Q_grad(:,:) !!!!!!!!!!!!!!AS
  real(kind=r8_kind) :: energy_core_n

  type(cavity_data),allocatable :: tessarea(:)
  integer(kind=i4_kind) :: N_spheres,N_atom_spheres
  real(kind=r8_kind), allocatable :: r_sphere(:)
  real(kind=r8_kind), allocatable :: xyz_sphere(:,:)
  integer(kind=i4_kind), allocatable :: parents(:,:)
  logical, allocatable :: zero_area(:)
  integer(kind=i4_kind) :: N_points_of_triangles
  integer(kind=i4_kind) :: N_centers_on_sphere
  real(kind=r8_kind) :: R_access
  real(kind=r8_kind) :: m_t_a
  integer(kind=i4_kind) :: local_point_factor

  type(geom_deriv) :: cagr
  integer(kind=i4_kind), allocatable :: i_symm_sort(:,:)
  integer(kind=i4_kind), allocatable :: i_unique_at_index(:)
  integer(kind=i4_kind) :: ua_dim_max = -1

  character*5 :: solvation_model
  character*4 :: spec_point_group
  real(kind=r8_kind) :: solvent_radius
  real(kind=r8_kind) :: scaled_factor
  real(kind=r8_kind) :: dielectric_constant
  real(kind=r8_kind) :: abs_temperature
  real(kind=r8_kind) :: solvent_volume
  integer(kind=i4_kind) :: point_factor
  logical :: get_vdwr
  logical :: no_hydrogen_sphere
  integer(kind=i4_kind) :: external_vdwr
  real(kind=r8_kind) :: max_tes_area
  logical, public :: hydrogen_no_scale  
  character(len=13) :: correction_type
  character(len=13) :: cent_type
  logical :: cor_el, cor_nuc
  real(kind=r8_kind) :: correct_factor_n
  logical :: orig_cent,weight_cent_sin,weight_cent_mass,weight_cent
  real(kind=r8_kind) :: fradio,overlap_angle,rmin_gepol,min_area
  logical :: fix_number_add
  logical :: cavitation_all
  !new
  logical :: only_cavities  !cancel calculations just after cavity calculations
  integer :: gepol          !choose gepol algorithm (Gepol87 or Gepol93)
  real(r8_kind) :: overlap_factor !new overlap factor for Gepol93
  logical :: view_cavity

  logical :: yes_no = .false.

  namelist /solvation/ &
       solvation_model, &
       cavitation_energy, &
       disp_rep_energy, &
       dielectric_constant, &
       abs_temperature, &
       solvent_volume, &
       solvent_radius, &
       scaled_factor, &
       point_factor, &
       max_tes_area, &
       get_vdwr, &
       external_vdwr, &
       no_hydrogen_sphere, &
       hydrogen_no_scale, &
       sol_start_cycle, &
       correction_type, &
       spec_point_group, &
       orig_cent, &
       weight_cent, &
       cent_type, &
       cavitation_all, &
       fradio, &
       overlap_angle, &
       rmin_gepol, &
       fix_number_add, &
       min_area, &
       only_cavities, &
       gepol, &
       overlap_factor, &
       view_cavity

  integer(kind=i4_kind) :: number_unique_atom
  real(kind=r8_kind) :: vdw_rad
  integer(kind=i4_kind), allocatable :: n_uq_at(:)
  real(kind=r8_kind), allocatable :: vdwr(:)

  namelist /van_der_Waals_radius/ &
       number_unique_atom, &
       vdw_rad


  character*5 :: df_solvation_model = "COSMO"
  character*4 :: df_spec_point_group = "C1  "
  logical :: df_cavitation_energy = .true.
  logical :: df_disp_rep_energy = .true.
  real(kind=r8_kind) :: df_solvent_radius = 1.400_r8_kind   !angstrom
  real(kind=r8_kind) :: df_scaled_factor = 1.2_r8_kind
  real(kind=r8_kind) :: df_dielectric_constant = 78.4_r8_kind
  real(kind=r8_kind) :: df_abs_temperature = 298.0_r8_kind    !K
  real(kind=r8_kind) :: df_solvent_volume = 18.07_r8_kind   !cm^3/mol
  integer(kind=i4_kind) :: df_point_factor = 1
  logical :: df_get_vdwr = .false.
  logical :: df_no_hydrogen_sphere = .false.
  integer(kind=i4_kind) :: df_external_vdwr = 0
  logical :: df_charge_correction = .false.
  real(kind=r8_kind) :: df_max_tes_area = 0.5_r8_kind !angstrom^2
  integer(kind=i4_kind) :: df_sol_start_cycle = 1
  logical :: df_hydrogen_no_scale = .true.
  character(len=13) :: df_correction_type = "Scale_Nuc_El "
  character(len=13) :: df_cent_type =       "default      "
  logical :: df_orig_cent = .false.
  logical :: df_weight_cent = .false.
  real(kind=r8_kind) :: df_fradio = 0.7_r8_kind
  real(kind=r8_kind) :: df_overlap_angle = 40.0_r8_kind
  real(kind=r8_kind) :: df_rmin_gepol = 0.2_r8_kind
  real(kind=r8_kind) :: df_min_area = 1.0e-7_r8_kind
  logical :: df_fix_number_add = .false.
  logical :: df_cavitation_all = .false.
  !new
  logical :: df_only_cavities
  integer :: df_gepol=93 !87
  real(r8_kind) :: df_overlap_factor=0.77_r8_kind
  logical :: df_view_cavity=.false.

  logical, allocatable :: skip_short(:)
  integer, allocatable :: iuniq(:)

  real(kind=r8_kind) , parameter :: pi = 3.14159265355897932368_r8_kind
  real(kind=r8_kind) , parameter :: ang_au = 0.529177249_r8_kind
  real(kind=r8_kind) , parameter :: au_to_erg = 4.35926565522e-11_r8_kind
  real(kind=r8_kind) , parameter :: au_to_dyn = 8.237e-3_r8_kind
  real(kind=r8_kind) , parameter :: avogadro = 6.0221367e23_r8_kind  !mol^(-1)
  real(kind=r8_kind) , parameter :: pressure = 1.01325e6_r8_kind      !dyn/cm^2
  real(kind=r8_kind) , parameter :: boltzmann = 1.380658e-16_r8_kind   !erg/K
  integer(i4_kind), parameter :: N_max_spheres=1000 !maximal number of spheres
  integer(i4_kind) :: NDIV=5

  integer(i4_kind),parameter :: MAX_ATOMS_QMMM=40
  integer(i4_kind),parameter :: MAX_ATOMS_QMMM1=100

  integer(kind=i4_kind) :: counter_n
  external error_handler

contains

  !********************************************************************
  subroutine solvation_read
   !reads in the namelist "solvation", sets defaults of elements
   !and checks input values.
   !reads also van der Waals radia if given in input
   !called by read_input
   !** End of interface *****************************************

    use input_module
    use unique_atom_module, only: N_unique_atoms
    use operations_module, only: operations_gradients,operations_geo_opt

    integer(kind=i4_kind) :: unit,status,i

    solvation_model=df_solvation_model
    cavitation_energy=df_cavitation_energy
    disp_rep_energy=df_disp_rep_energy
    dielectric_constant=df_dielectric_constant
    abs_temperature=df_abs_temperature
    solvent_radius=df_solvent_radius
    solvent_volume=df_solvent_volume
    scaled_factor=df_scaled_factor
    point_factor=df_point_factor
    get_vdwr=df_get_vdwr
    no_hydrogen_sphere=df_no_hydrogen_sphere
    hydrogen_no_scale=df_hydrogen_no_scale 
    external_vdwr=df_external_vdwr
    charge_correction=df_charge_correction
    max_tes_area=df_max_tes_area
    sol_start_cycle=df_sol_start_cycle
    correction_type=df_correction_type
    cent_type=df_cent_type
    spec_point_group=df_spec_point_group
    orig_cent=df_orig_cent
    weight_cent=df_weight_cent
    overlap_angle=df_overlap_angle
    fradio=df_fradio
    rmin_gepol=df_rmin_gepol
    min_area=df_min_area
    fix_number_add = df_fix_number_add
    if(operations_geo_opt) fix_number_add=.true.
    cavitation_all=df_cavitation_all
    only_cavities=df_only_cavities
    gepol=df_gepol
    overlap_factor=df_overlap_factor
    view_cavity=df_view_cavity

    unit = input_intermediate_unit()
    call input_read_to_intermediate
    read(unit, nml=solvation, iostat=status)
    if (status .ne. 0) call input_error( &
         "solvation_read: namelist solvation.")
    yes_no = .true.

    stop_solv=only_cavities
    save_cav=view_cavity
    if ( solvation_model/='COSMO' .and. &
         solvation_model/='cosmo')  call input_error( &
         "solvation_read: "// &
         "I do not know anything about choosen solvation model. I deal with COSMO(cosmo) only.")
    if (solvent_radius <= 0.0) call input_error( &
         "solvation_read: You have put wrong solvent_radius. Sorry")
    if (scaled_factor < 1.0) call input_error( &
         "solvation_read: You have put wrong scaled_factor. Sorry")
!!$    if (point_factor > 2 .or. point_factor <= 0) call input_error( &
!!$         "solvation_read: point_factor can not be more then 2 and less 1. Sorry")
    if (dielectric_constant < 1.0 ) call input_error( &
         "solvation_read: You have put wrong dielectric_constant. Sorry")
    if(cavitation_energy .and. .not.  disp_rep_energy) cavitation_all=.true.
    if(gepol /= 87 .and. gepol /= 93) gepol = 93
    if(overlap_factor < 0.0_r8_kind .or. overlap_factor >= 1.0_r8_kind) &
         overlap_factor=df_overlap_factor

    !type of surface tessera center (representative point) definition
    select case(cent_type) 
     case("corners      ")
	weight_cent=.false.
    	weight_cent_mass=.false.
    	weight_cent_sin=.false.
        orig_cent=.false.
     case("sin          ")
	weight_cent=.true.
    	weight_cent_mass=.false.
    	weight_cent_sin=.true.
        orig_cent=.false.
     case("triangles    ")
	weight_cent=.false.
    	weight_cent_mass=.false.
    	weight_cent_sin=.false.
        orig_cent=.false.
     case("mass         ")
	weight_cent=.true.
    	weight_cent_mass=.true.
    	weight_cent_sin=.false.
        orig_cent=.false.
     case("default      ")
	!for old kind input options
    	weight_cent_mass=weight_cent
    	weight_cent_sin=.false.
     case default 
       call input_error("solvation_read: cent_type: allowed values are&
			& corners,mass,triangles,sin,default")
    end select

    select case(correction_type) 
     case("None         ")
	charge_correction=.false.
        cor_el           =.false.
        cor_nuc          =.false.
     case("Scale_Nuc_El ")
	charge_correction=.false.
        cor_el           =.true.
        cor_nuc          =.true.
     case("Scale_Nuclear")
	charge_correction=.false.
        cor_el           =.false.
        cor_nuc          =.true.
     case("Charge_Inside")
 	charge_correction=.true.
        cor_el           =.false.
        cor_nuc          =.false.
     case default 
       call input_error("solvation_read: correction_type: allowed values are&
			& None,Scale_Nuc_El,Scale_Nuclear,Charge_Inside ")
    end select
    if(operations_gradients.and.(cor_el.or.cor_nuc.or.charge_correction)) then
      call write_to_output_units("Warning: In connection with the calculation &
	& of gradients only correction_type=None is allowed. I reset this &
        & value ")
      cor_el =.false.
      cor_nuc=.false.
      charge_correction=.false.
      correction_type="None         "
    endif

    if(external_vdwr > 0) then
       if(.not. allocated(n_uq_at)) then
          allocate(n_uq_at(external_vdwr),vdwr(external_vdwr),stat=status)
          if ( status /= 0) call error_handler( &
               "solvation_read: allocation of n_uq_at is failed")
       endif
    endif

    do i=1,external_vdwr
       call input_read_to_intermediate()
       read(unit, nml=van_der_Waals_radius, iostat=status)
       n_uq_at(i)=number_unique_atom
       if (number_unique_atom > N_unique_atoms .or. &
            number_unique_atom <= 0 ) call input_error( &
            "solvation_read: You have put wrong number_unique_atom . Sorry")

       vdwr(i)=vdw_rad
       if( n_uq_at(i) == 0 .or. vdwr(i) == 0.0_r8_kind) call input_error( &
            "solvation_read: Please specify something reasonable")
    enddo

    if(charge_correction .and. operations_gradients) then
	call input_error(" no charge correction allowed when calculating &
		& gradients")
    endif

  end subroutine solvation_read
  !********************************************************************

  !********************************************************************
  subroutine check_read
   ! sets defaults if namelist "solvation" is not present
   ! called by main_master
   !** End of interface *****************************************
   use operations_module, only: operations_geo_opt
    
    if (.not.yes_no) then
       solvation_model = df_solvation_model
       cavitation_energy = df_cavitation_energy
       disp_rep_energy = df_disp_rep_energy
       dielectric_constant = df_dielectric_constant
       abs_temperature = df_abs_temperature
       solvent_radius = df_solvent_radius
       solvent_volume=df_solvent_volume
       scaled_factor = df_scaled_factor
       point_factor = df_point_factor
       get_vdwr=df_get_vdwr
       no_hydrogen_sphere=df_no_hydrogen_sphere
       hydrogen_no_scale=df_hydrogen_no_scale 
       external_vdwr=df_external_vdwr
       charge_correction=df_charge_correction
!!! MF >>>>
       max_tes_area=df_max_tes_area
       sol_start_cycle=df_sol_start_cycle
       correction_type=df_correction_type
       cent_type=df_cent_type
       spec_point_group=df_spec_point_group
       orig_cent=df_orig_cent
       weight_cent=df_weight_cent
       weight_cent_mass=df_weight_cent
       weight_cent_sin=.false.
       fradio=df_fradio
       rmin_gepol=df_rmin_gepol
       min_area=df_min_area
       overlap_angle=df_overlap_angle
       fix_number_add = df_fix_number_add
       if(operations_geo_opt) fix_number_add=.true.
       cavitation_all=df_cavitation_all
       !!! MF <<<<
       only_cavities=df_only_cavities
       stop_solv=only_cavities
       gepol=df_gepol
       overlap_factor=df_overlap_factor
       view_cavity=df_view_cavity
       save_cav=view_cavity
    endif

  end subroutine check_read
  !********************************************************************
  subroutine solvation_write(unit)
   !writes the used parameters of namelist "solvation" 
   !called by write_input
   !** End of interface *****************************************
    use echo_input_module
    use operations_module, only: operations_echo_input_level

    integer(kind=i4_kind), intent(in) :: unit
    integer(kind=i4_kind) :: i

    real_format1 = '("    ",a," = ",f7.3:" # ",a)'
    real_format2 = '("    ",a," = ",es12.3:" # ",a)'
    intg_format = '("    ",a," = ",i7  :" # ",a)'
    word_format = '("    ",a," = ",a15 :" # ",a)' 
    flag_format = '("    ",a," = ",a7  :" # ",a)'

    call start("SOLVATION","SOLVATION_WRITE",unit,operations_echo_input_level)
    call word("SOLVATION_MODEL    ",solvation_model    ,df_solvation_model    )
    call flag("CAVITATION_ENERGY  ",cavitation_energy  ,df_cavitation_energy  )
    call flag("DISP_REP_ENERGY    ",disp_rep_energy    ,df_disp_rep_energy    )
    call flag("ONLY_CAVITIES      ",only_cavities      ,df_only_cavities      )
    call flag("VIEW_CAVITY        ",view_cavity        ,df_view_cavity        )
    call real("DIELECTRIC_CONSTANT",dielectric_constant,df_dielectric_constant,1)
    call real("ABS_TEMPERATURE    ",abs_temperature    ,df_abs_temperature    ,1)
    call intg("GEPOL              ",gepol              ,df_gepol              )
    call real("SOLVENT_VOLUME     ",solvent_volume     ,df_solvent_volume     ,1)
    call real("SOLVENT_RADIUS     ",solvent_radius     ,df_solvent_radius     ,1)
    call real("SCALED_FACTOR      ",scaled_factor      ,df_scaled_factor      ,1)
    call intg("POINT_FACTOR       ",point_factor       ,df_point_factor       )
    call real("MAX_TES_AREA       ",max_tes_area       ,df_max_tes_area       ,2)
    call flag("GET_VDWR           ",get_vdwr           ,df_get_vdwr           )
    call intg("EXTERNAL_VDWR      ",external_vdwr      ,df_external_vdwr      )
    call flag("NO_HYDROGEN_SPHERE ",no_hydrogen_sphere ,df_no_hydrogen_sphere )
    call flag("HYDROGEN_NO_SCALE  ",hydrogen_no_scale  ,df_hydrogen_no_scale  ) 
    call intg("SOL_START_CYCLE    ",sol_start_cycle    ,df_sol_start_cycle    )
    call word("CORRECTION_TYPE    ",correction_type    ,df_correction_type    )
       write (unit,'(A100)') &
            "   # Allowed values are: None Scale_Nuc_El Scale_Nuclear Charge_Inside "
    call word("CENT_TYPE          ",cent_type          ,df_cent_type          )
       write (unit,'(A100)') &
            "   # Allowed values are: corners, mass, sin, triangles, default "       
    call flag("WEIGHT_CENT        ",weight_cent        ,df_weight_cent        ) 
       write (unit,'(A100)') &
            "   # (only for old fashion input (without cent_type) "       
    call real("FRADIO             ",fradio             ,df_fradio,1)
    call real("OVERLAP_ANGLE      ",overlap_angle      ,df_overlap_angle,1)
    call real("OVERLAP_FACTOR     ",overlap_factor     ,df_overlap_factor,1)
    call real("RMIN_GEPOL         ",rmin_gepol         ,df_rmin_gepol   ,2)
    call word("SPEC_POINT_GROUP   ",spec_point_group   ,df_spec_point_group   )
    call flag("FIX_NUMBER_ADD     ",fix_number_add     ,df_fix_number_add)
    call flag("CAVITATION_ALL     ",cavitation_all     ,df_cavitation_all)
    call real("MIN_AREA           ",min_area           ,df_min_area   ,2)
    call stop()

    do i=1,external_vdwr
       call start("VAN_DER_WAALS_RADIUS","VAN_DER_WAALS_RADIUS_WRITE",unit,operations_echo_input_level)
       call intg("NUMBER_UNIQUE_ATOM",n_uq_at(i)        ,0                     )
       call real("VDW_RAD           ",vdwr(i)           ,0.0_r8_kind           )
       call stop()
    enddo

  end subroutine solvation_write
  !**************************************************************

  !**************************************************************
  subroutine save_cavity_image()
    !save excluding molecular surface cavity data in wrml format

    integer(i4_kind) :: file_id
    integer(i4_kind) :: i

    file_id=openget_iounit(trim(input_dir)//'/cavity.wrl', &
            form='formatted', status='unknown')
    write(file_id,'(a16)') '#VRML V1.0 ascii'
    write(file_id,'(a11)') 'Separator {'

    do i=1,N_spheres
       if(gepol == 93) then
          if(zero_area(i)) cycle
       end if
       write(file_id,'(a11,a16,i5)') 'Separator {','       # sphere ',i
       write(file_id,'(a18)') '        Material {'
       write(file_id,'(a34)') '                ambientColor 0 0 0'
       write(file_id,'(a34)') '                diffuseColor 0 1 1'
       write(file_id,'(a35)') '                specularColor 0 0 0'
       write(file_id,'(a35)') '                emissiveColor 0 0 0'
       write(file_id,'(a27)') '                shininess 0'
       write(file_id,'(a30)') '                transparency 0'
       write(file_id,'(a9)' ) '        }'
       write(file_id,'(a19)') '        Transform {'
       write(file_id,'(a28,3f10.6)') '                translation ',xyz_sphere(i,:)*ang_au
       write(file_id,'(a9)' ) '        }'
       write(file_id,'(a16)') '        Sphere {'
       write(file_id,'(a23,f10.6)') '                radius ',r_sphere(i)*ang_au
       write(file_id,'(a9)' ) '        }'
       write(file_id,'(a1)' ) '}'
    end do

    write(file_id,'(a1)' ) '}'

    call returnclose_iounit(file_id)

  end subroutine save_cavity_image
  !**************************************************************

  !**************************************************************
  subroutine energy_and_grad_of_cavity(grad_index)
   !calculates the cavitation energy or its gradients 
   !(scaled particle theory) formulas from
   !
   !** End of interface *****************************************

    use unique_atom_module, only: N_moving_unique_atoms,unique_atoms,moving_unique_atom_index, &
         unique_atom_grad_info
    use pointcharge_module, only: pointcharge_N,pointcharge_array
    use elec_static_field_module

    integer(kind=i4_kind), intent(in), optional :: grad_index(N_moving_unique_atoms + 1)

    real(kind=r8_kind) :: Kb, P, Vsol, num_dens, rsolv
    real(kind=r8_kind) :: K0, K1, K2, K3, dd, Y, YY, Ecav, area_total, area_s
    integer(kind=i4_kind) :: i,i1,j,k,l,m,ma,ma1,na,ea,grad_dim,index
    real(kind=r8_kind),pointer  :: rotmat(:,:)
    real (kind=r8_kind) :: gradient(3)
    integer :: N_pc

    DPRINT 'energy_and_grad_of_cavity: entered'

    !convert some parameters to atomic units
    Kb=boltzmann/au_to_erg
    P=(pressure*ang_au*ang_au/au_to_dyn)*1.0e-16_r8_kind
    Vsol=solvent_volume*1.0e24_r8_kind/(ang_au*ang_au*ang_au)
    rsolv=solvent_radius/ang_au

    num_dens=avogadro/Vsol

    if(.not.do_gradients) then
       energy_cav=0.0_r8_kind
       do_nsp_i: do i=1,N_spheres
	  if(.not. cavitation_all) then
	        !use skip_short only when allocated!
                if(skip_short(iuniq(i))) cycle do_nsp_i
          endif
          Y=4.0_r8_kind*pi*num_dens*rsolv**3/3.0_r8_kind
          YY=Y/(1.0_r8_kind-Y)

          dd=r_sphere(i)/rsolv

          K0= -log(1.0_r8_kind-Y)
          K1= 3.0_r8_kind*YY
          K2= 3.0_r8_kind*YY+4.5_r8_kind*YY**2
!!$          K3= Y*P/(num_dens*Kb*abs_temperature)
          K3=0.0_r8_kind

          Ecav=(K0+K1*dd+K2*dd**2+K3*dd**3)*Kb*abs_temperature
       
          area_total=4.0_r8_kind*pi*r_sphere(i)**2

          area_s=0.0_r8_kind
          do j=1,n_size
             do k=1,tessarea(j)%n_equal
                if(tessarea(j)%sphere(k) == i) area_s=area_s+tessarea(j)%area
             enddo
          enddo
          energy_cav=energy_cav+Ecav*area_s/area_total
       enddo do_nsp_i
    else
       N_pc=0
       if(with_pc .and. .not.fixed_pc)  N_pc=pointcharge_N

       unique1: do ma=1,N_moving_unique_atoms+N_pc
          if(ma <= N_moving_unique_atoms) then
             na=moving_unique_atom_index(ma)
             ea=unique_atoms(na)%n_equal_atoms
          else
             na=ma-N_moving_unique_atoms
             ea=pointcharge_array(na)%N_equal_charges
          end if
       
          unique2: do m=1,ea
             gradient=0.0_r8_kind

             i_N: do i=1,N_spheres
	        if(.not. cavitation_all) then
	              !use skip_short only when allocated!
                      if(skip_short(iuniq(i))) cycle i_N
                endif
                Y=4.0_r8_kind*pi*num_dens*rsolv**3/3.0_r8_kind
                YY=Y/(1.0_r8_kind-Y)
             
                dd=r_sphere(i)/rsolv

                K0= -log(1.0_r8_kind-Y)
                K1= 3.0_r8_kind*YY
                K2= 3.0_r8_kind*YY+4.5_r8_kind*YY**2
!!$             K3= Y*P/(num_dens*Kb*abs_temperature)
                K3=0.0_r8_kind

                Ecav=(K0+K1*dd+K2*dd**2+K3*dd**3)*Kb*abs_temperature

                area_total=4.0_r8_kind*pi*r_sphere(i)**2

                DPRINT 'i_symm_sort used here, shape=',shape(i_symm_sort)
                do j=1,n_size
                   do k=1,tessarea(j)%n_equal
                      if(tessarea(j)%sphere(k) == i) then
                         do l=1,3
                            gradient(l)=gradient(l)+&
                                 Ecav*cagr%darea(l,ma,m)%m(i_symm_sort(j,k))/area_total
!!$print*,l,ma,m,j,k,cagr%darea(l,ma,m)%m(i_symm_sort(j,k)),i_symm_sort(j,k)
                         enddo
                      endif
                   enddo
                enddo
             enddo i_N

             if(ma <= N_moving_unique_atoms) then
                grad_dim=grad_index(ma+1)-grad_index(ma)
                rotmat=>unique_atom_grad_info(ma)%m(:,:,m)
                index=grad_index(ma)
                do i1=1,grad_dim
!!! ??? Sign ???
!               grad_solv_totsym(index) = grad_solv_totsym(index) - &
!                    sum( rotmat(i1,:) * gradient(:) )
                   grad_solv_totsym(index) = grad_solv_totsym(index) + &
                        sum( rotmat(i1,:) * gradient(:) )
                   index=index+1
                end do
             else
                ma1=ma-N_moving_unique_atoms
                grad_dim=surf_points_grad_index(ma1+1)-surf_points_grad_index(ma1)
                rotmat=>surf_points_grad_info(ma1)%m(:,:,m)
                index=surf_points_grad_index(ma1)
                do i1=1,grad_dim
                   totalsym_field(index) = totalsym_field(index) - &
                        sum( rotmat(i1,:) * gradient(:) )
                   index=index+1
                end do
             end if
          enddo unique2
       enddo unique1
    endif
    if(do_gradients) then
       call dealloc_geom_deriv_part2
    endif

    call dealloc_cavity()

    if(allocated(skip_short)) then
	!maybe not allocated if dispersion repulsion not calculated
        deallocate(skip_short,stat=i)
        if(i/=0) call error_handler("energy_and_grad_of_cavity: dealloc of skip short failed")
    endif

  end subroutine energy_and_grad_of_cavity
  !**************************************************************

  !**************************************************************
  subroutine disp_rep_wrap(grad_index)
   !calls the routines for calculating the dispersion/repulsion
   !energy or its gradients
   !** End of interface *****************************************
    
    use disp_rep_module
    use unique_atom_module, only: N_unique_atoms,unique_atoms,N_moving_unique_atoms, &
         unique_atom_grad_info,moving_unique_atom_index
    use pointcharge_module, only: pointcharge_N,pointcharge_array
    use elec_static_field_module

    integer(kind=i4_kind), intent(in), optional :: grad_index(N_moving_unique_atoms + 1)
    real(kind=r8_kind) :: Vsol
    real(kind=r8_kind),pointer  :: rotmat(:,:)
    real(kind=r8_kind) :: gradient(3)
    integer(kind=i4_kind) :: grad_dim,index,na,ea
    integer :: N_pc,N_pc2
    integer(kind=i4_kind) :: i,status,ma,ma1,mb,i1

    Vsol=solvent_volume*1.0e24_r8_kind/(ang_au*ang_au*ang_au)
    num_dens_dr=avogadro/Vsol

    N_pc=0; N_pc2=0
    if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
    if(with_pc) N_pc2=pointcharge_N

    allocate(nm_solute_at(N_unique_atoms+N_pc2),stat=status)
    if ( status /= 0) call error_handler( &
         "disp_rep_wrap: allocation of nm_solute_at is failed")

    if(.not. allocated(skip_short)) then
            allocate(skip_short(N_unique_atoms+N_pc2),stat=status)
            if ( status /= 0) call error_handler( &
                 "disp_rep_wrap: allocation of skip_short is failed")
    endif

    if(.not. use_rappe_data) then
       call initialize_data(skip_short,with_pc)
    else
       call get_rappe_data(with_pc)
       skip_short(:)=.false.
    endif

    if (.not.do_gradients) then
       E_disp=0.0_r8_kind
       E_rep=0.0_r8_kind

       do i=1,ndsa
          if(output_cavity_data) write (output_unit,*) 'THE CAVITY -',i
          R_access=r_sphere_at(i)
          call points_on_cavity_surface()

          call solv_disprep_transer_data()

          call disp_rep_energies_and_grad(i,do_gradients,with_pc)

          call deallocate_D_R_points(do_gradients)
       enddo
    else
!      unique1: do ma=1,N_moving_unique_atoms
!         na = moving_unique_atom_index(ma)
!         ea = unique_atoms(na)%n_equal_atoms
!         unique2: do mb=1,ea
!            gradient=0.0_r8_kind
!            do i=1,ndsa
!               R_access=r_sphere_at(i)
!               call points_on_cavity_surface()
!               call solv_disprep_transer_data()
!               call disp_rep_energies_and_grad(i,do_gradients,gradient,ma,mb)
!               call deallocate_D_R_points(do_gradients)
!            enddo
!            grad_dim=grad_index(ma+1)-grad_index(ma)
!            rotmat=>unique_atom_grad_info(ma)%m(:,:,mb)
!            index=grad_index(ma)
!            do i1=1,grad_dim
!               grad_solv_totsym(index) = grad_solv_totsym(index) + &
!                    sum( rotmat(i1,:) * gradient(:) )
!               index=index+1
!            enddo
!         enddo unique2
!      enddo unique1
       do i=1,ndsa
          if(output_cavity_data) write (output_unit,*) 'THE CAVITY -',i
          R_access=r_sphere_at(i)
          call points_on_cavity_surface()
          call solv_disprep_transer_data()
          unique1: do ma=1,N_moving_unique_atoms+N_pc
             if(ma <= N_moving_unique_atoms) then
                na = moving_unique_atom_index(ma)
                ea = unique_atoms(na)%n_equal_atoms
             else
                na=ma-N_moving_unique_atoms
                ea=pointcharge_array(na)%N_equal_charges
             end if
             unique2: do mb=1,ea
                 gradient=0.0_r8_kind
                 call disp_rep_energies_and_grad(i,do_gradients,with_pc,gradient,ma,mb)
                 if(ma <= N_moving_unique_atoms) then
                    grad_dim=grad_index(ma+1)-grad_index(ma)
                    rotmat=>unique_atom_grad_info(ma)%m(:,:,mb)
                    index=grad_index(ma)
                    do i1=1,grad_dim
                       grad_solv_totsym(index) = grad_solv_totsym(index) + &
                            sum( rotmat(i1,:) * gradient(:) )
                       index=index+1
                    enddo
                 else
                    ma1=ma-N_moving_unique_atoms
                    grad_dim=surf_points_grad_index(ma1+1)-surf_points_grad_index(ma1)
                    rotmat=>surf_points_grad_info(ma1)%m(:,:,mb)
                    index=surf_points_grad_index(ma1)
                    do i1=1,grad_dim
                       totalsym_field(index) = totalsym_field(index) - & 
                            sum( rotmat(i1,:) * gradient(:) )
                       index=index+1
                    end do
                 end if
             enddo unique2
          enddo unique1
          call deallocate_D_R_points(do_gradients)
       enddo
    endif

    call deallocate_parameters(do_gradients)
    deallocate(nm_solute_at,stat=status)
    if ( status /= 0) call error_handler( &
         "disp_rep_wrap: deallocation of nm_solute_at is failed")

    contains

      subroutine solv_disprep_transer_data()
        !stores data needed for calculating the dispersion/repulsion
        !energy or its gradients in variables
        !D_R_points
        !D_R_grad
        !** End of interface *****************************************

        integer(kind=i4_kind) :: status,nat,nat1,eat
        integer(kind=i4_kind) :: j,j1,k,k1,l,m,n
        integer(kind=i4_kind) :: i_sym,N_pc1

        DPRINT 'solv_disprep_t_d: do_gradients=',do_gradients

        N_pc1=0
        if(with_pc) N_pc1=pointcharge_N
        N_points_dr=n_size

        if (do_gradients) then
           allocate(D_R_points(N_points_dr),D_R_grad(N_points_dr),&
                stat=status)
        else
           allocate(D_R_points(N_points_dr),stat=status)
        endif
        ASSERT(status==0)

        ASSERT(size(tessarea)==n_size)
        ASSERT(ua_dim_max.ne.-1)

        if(do_gradients)then
           DPRINT 'solv_disprep_t_d: shape(i_symm_sort)=',shape(i_symm_sort)
        endif

        do l=1,N_points_dr
           D_R_points(l)%N_equal_points = tessarea(l)%n_equal

           allocate(D_R_points(l)%position(3,D_R_points(l)%N_equal_points),stat=status)
           ASSERT(status==0)
           allocate(D_R_points(l)%out_normal(3,D_R_points(l)%N_equal_points),stat=status)
           ASSERT(status==0)

	   if(do_gradients) then
              allocate(D_R_grad(l)&
                   & %position  (3,N_moving_unique_atoms+N_pc1,ua_dim_max,3,tessarea(l)%n_equal),&
                   D_R_grad(l)&
                   & %out_normal(3,N_moving_unique_atoms+N_pc1,ua_dim_max,3,tessarea(l)%n_equal), &
                   D_R_grad(l)&
                   & %area      (3,N_moving_unique_atoms+N_pc1,ua_dim_max,tessarea(l)%n_equal), &
                   D_R_grad(l)&
                   & %distance  (3,N_moving_unique_atoms+N_pc1,ua_dim_max,N_unique_atoms+N_pc1,ua_dim_max, &
                   3,tessarea(l)%n_equal), &
                   stat=status)
              ASSERT(status==0)
	   endif

           do j=1,D_R_points(l)%N_equal_points
              D_R_points(l)%position(:,j) = tessarea(l)%xyz(j,:)
              k=tessarea(l)%sphere(j)
              D_R_points(l)%out_normal(:,j)=(tessarea(l)%xyz(j,:)-xyz_sphere(k,:))/ &
                sqrt(dot_product(tessarea(l)%xyz(j,:)-xyz_sphere(k,:),tessarea(l)%xyz(j,:)-xyz_sphere(k,:)))

	      if(do_gradients) then
                 i_sym = i_symm_sort(l,j)
                 do j1=1,N_moving_unique_atoms+N_pc1 ! gradient coodinates
                    if(j1 <= N_moving_unique_atoms) then
                       nat = moving_unique_atom_index(j1)
                       eat = unique_atoms(nat)%n_equal_atoms
                       nat1=nat
                    else
                       nat=j1-N_moving_unique_atoms
                       eat=pointcharge_array(nat)%N_equal_charges
                       nat1=nat+N_unique_atoms
                    end if
                    do k1=1,eat
                       do n=1,3
                          ! SIGSEGV here:
                          D_R_grad(l)%position(n,j1,k1,:,j)=&
                               cagr%dcenter(n,j1,k1)%m(:,i_sym)
                          D_R_grad(l)%area(n,j1,k1,j)=&
                               cagr%darea(n,j1,k1)%m(i_sym)

                          do m=1,3 ! coordinate(x,y,z) of point j
                             D_R_grad(l)%out_normal(n,j1,k1,m,j)=&
                                  (cagr%dcenter(n,j1,k1)%m(m,i_sym)-&
                                  cagr%dc(m,k)%xyz_grad(n,j1,k1))/r_sphere(k)

                             D_R_grad(l)%distance(n,j1,k1,:,:,m,j)=&
                                  D_R_grad(l)%position(n,j1,k1,m,j)
                          enddo

                          D_R_grad(l)%distance(n,j1,k1,nat1,k1,n,j)=&
                               D_R_grad(l)%distance(n,j1,k1,nat1,k1,n,j)-1.0_r8_kind
                       enddo
                    enddo
                 enddo
	      endif
           enddo
           D_R_points(l)%area=tessarea(l)%area
        enddo

        call dealloc_cavity()
        if(do_gradients) then
           call dealloc_geom_deriv_part1(cagr)
           call dealloc_geom_deriv_part2()
        endif

      end subroutine solv_disprep_transer_data

    end subroutine disp_rep_wrap
  !**************************************************************
  subroutine points_on_cavity_surface
   !calls routines for producing the appropriate cavity surface grid:
   !1) calc_cavity or calc_caity_1: find set of spheres building the
   !   cavity
   !2) denerate_cube, generate_dodecahedron, or generate_doublepyramide:
   !   produce points on a spherical surface with 
   !   local symmetry, starting from a appropriate polihedron.
   !3) tesselation: calculates areas and centers of 
   !   cutted (by other spheres) and non cutted surface pieces (tesserae)  
   !4) symm_sorted_centers: find and store symmetry equivalent 
   !   surface tesserae
   !
   ! called by main_master, main_gradient and (intern) disp_rep_wrap
   !** End of interface *****************************************

    use unique_atom_module
    use pointcharge_module
    use symmetry_data_module, only : symmetry_data_point_group
    use group_module, only : ylm_trafos,sub_group,group_coset, &
         symm_transformation_int,group_num_el,group_coset_decomp
    use symm_module, only : symm_adapt_centers
    use math_module, only : invert_matrix
    use elec_static_field_module, only: unique_surf_points
    use disp_rep_module
    use help_cavity_module

    character*4 :: name_point_group
    real(kind=r8_kind) :: radius
    type(triangles), target :: surf_elem                 !! for generate_dodecahedron and generate_cube
    real(kind=r8_kind), allocatable :: xyz_tes_c(:,:),area_tes(:),r_tes(:)           !! for tesselation
    integer(kind=i4_kind), allocatable :: sphere(:)                                  !! for tesselation
    logical, allocatable :: cuttt(:)                                                 !! for tesselation
    type(poligon),allocatable :: data_tes(:)                                         !! for tesselation
!!! MF >>>>
    integer (kind=i4_kind) :: n_rotations,max_cent
    integer (kind=i4_kind), allocatable :: cut_rad_sort(:,:)
!!! MF <<<<

    integer(kind=i4_kind) :: i
    integer(kind=i4_kind) :: i_poly
    integer(kind=i4_kind) :: ret_stat

    external error_handler

    if(.not.do_correction .and. .not.do_cavitation .and. .not.do_disp_rep) then
       if(output_cavity_data .and. .not.do_gradients) then
          write (output_unit,*) '*******************************************************************'
          write (output_unit,*) '          SOLVATION EFFECT - ELECTROSTATIC CONTRIBUTION          '
          write (output_unit,*) '                     C O S M O - model                           '
          write (output_unit,*) '==================================================================='
          write (output_unit,*) 'Definition of cavity and coordinats of point charges on its surface'
          write (output_unit,*) '==================================================================='
       endif
       if(get_vdwr.and. .not.do_gradients ) then
          write (output_unit,*) '       Default values of van der Waals radii     '
          write (output_unit,*) '-------------------------------------------------'
          write (output_unit,*) 'Element      van der Waals radius(A)'
          do i=1,98
	     if(vdW_radius(i)/=0.0_r8_kind) then
                write (output_unit,'(3x,a2,17x,f5.2,1x,a5)')atom_name(i),vdW_radius(i),'Bondi'
             else
                write (output_unit,'(3x,a2,17x,f5.2,1x,a5)')atom_name(i),R_def_rap(i)/2.0_r8_kind,'Rappe'
             endif
          enddo
          write (output_unit,*) '-------------------------------------------------'
       endif
    endif

    if(do_correction .and. output_cavity_data .and. .not.do_gradients) then
       write (output_unit,*) '*******************************************************************'
       write (output_unit,*) '                     SOLVATION EFFECT'
       write (output_unit,*) '     Definition of point set on solute cavity to define          '
       write (output_unit,*) '                escaped electronic charge'
       write (output_unit,*) '==================================================================='
    endif

    if(do_cavitation .and. output_cavity_data .and. .not.do_gradients) then
       write (output_unit,*) '*******************************************************************'
       write (output_unit,*) '          SOLVATION EFFECT - CAVITATION CONTRIBUTION'
       write (output_unit,*) '                    Definition of cavity'
       write (output_unit,*) '==================================================================='
    endif
       
    if(do_disp_rep .and. output_cavity_data .and. .not.do_gradients) then
       write (output_unit,*) '*******************************************************************'
       write (output_unit,*) '       SOLVATION EFFECT - DISPERSION-REPULSION CONTRIBUTION'
       write (output_unit,*) '                    Definition of cavity'
       write (output_unit,*) '==================================================================='
    endif

    ua_dim_max = maxval(unique_atoms(:)%N_equal_atoms)
    if(with_pc) ua_dim_max = max(maxval(pointcharge_array(:)%N_equal_charges),ua_dim_max)
    DPRINT 'points_on_cavity_surface: ua_dim_max=',ua_dim_max

    if(do_disp_rep .or. do_cavitation) then
       if(do_cavitation) R_access=0.0_r8_kind
       call calc_cavity_1()
!!$       print*,'calc_cavity_1 N_spheres', N_spheres
       if(do_gradients) call calc_cavity_gradient(.false.)
    else
       if(gepol == 87) then 
          call calc_cavity()
       elseif(gepol == 93) then
          if(symmetry_data_point_group() =='C1  ') NDIV=4
          name_point_group='C1  '
          call generate_dodecahedron(1)
          call calc_cavity_93()
          deallocate(surf_elem%xyz_centers,surf_elem%xyz,surf_elem%index)
!!$          print*,'calc_cavity N_spheres', N_spheres
       end if
       if(save_cav .and. .not.do_gradients) call save_cavity_image()
       if(do_gradients) call calc_cavity_gradient(.true.)
    endif
       
!   name_point_group=symmetry_data_point_group()
    if(spec_point_group==df_spec_point_group) then
       name_point_group =symmetry_data_point_group() 
    else 
	name_point_group=spec_point_group
    endif

!!! MF >>>>
    m_t_a=max_tes_area/(ang_au**2)
    call find_max_dim_surf_elem()
!!! MF <<<<

    i_poly=0
    if ( N_atom_spheres >= MAX_ATOMS_QMMM .and. &
         name_point_group=='C1  ') then
       if(output_cavity_data .and. .not.do_gradients) &
            write (output_unit,*) 'The OCTAHEDRON is inscribed into each sphere'
       call generate_octahedron()
       i_poly=1
    elseif ( (name_point_group=='C1  ')  .or. &
         (name_point_group=='C2  ')  .or. &
         (name_point_group=='C3  ')  .or. &
         (name_point_group=='C5  ')  .or. &
         (name_point_group=='CS  ')  .or. &
         (name_point_group=='Ci  ')  .or. &
         (name_point_group=='C2V ')  .or. &
         (name_point_group=='C2H ')  .or. &
         (name_point_group=='C3V ')  .or. &
         (name_point_group=='C5V ')  .or. &
         (name_point_group=='S6  ')  .or. &
         (name_point_group=='S10 ')  .or. &
         (name_point_group=='D2  ')  .or. &
         (name_point_group=='D2H ')  .or. &
         (name_point_group=='D3  ')  .or. &
         (name_point_group=='D3D ')  .or. &
         (name_point_group=='D5  ')  .or. &
         (name_point_group=='D5D ')  .or. &
         (name_point_group=='I   ')  .or. &
         (name_point_group=='IH  ')  ) then
       if(output_cavity_data .and. .not.do_gradients) &
            write (output_unit,*) 'The DODECAHEDRON is inscribed into each sphere'
       call generate_dodecahedron(0)
    elseif ( (name_point_group=='C4  ') .or. &
         (name_point_group=='C4V ')  .or. &
         (name_point_group=='C4H ')  .or. &
         (name_point_group=='D4  ')  .or. &
         (name_point_group=='D4H ')  .or. &
         (name_point_group=='S4  ')  .or. &
         (name_point_group=='D2D ')  .or. &
         (name_point_group=='O   ')  .or. &
         (name_point_group=='OH  ')  .or. &
         (name_point_group=='T   ')  .or. &
         (name_point_group=='TH  ')  .or. &
         (name_point_group=='TD  ') ) then
       if(output_cavity_data .and. .not.do_gradients) & 
            write (output_unit,*) 'The CUBE is inscribed into each sphere'
       call generate_cube()
    else
!!! MF >>>>
       n_rotations=0
       if( (name_point_group=='C3H ')  .or. &
            (name_point_group=='D3H ') ) then
          n_rotations=3
       elseif( (name_point_group=='C5H ')  .or. &
            (name_point_group=='D5H ') ) then
          n_rotations=5
       elseif( (name_point_group=='C6  ')  .or. &
            (name_point_group=='C6V ')  .or. &
            (name_point_group=='C6H ')  .or. &
            (name_point_group=='D6  ')  .or. &
            (name_point_group=='D6H ') ) then
          n_rotations=6
       elseif( (name_point_group=='C7  ')  .or. &
            (name_point_group=='C7V ')  .or. &
            (name_point_group=='C7H ')  .or. &
            (name_point_group=='D7  ')  .or. &
            (name_point_group=='D7H ') ) then
          n_rotations=7
       elseif( (name_point_group=='C8  ')  .or. &
            (name_point_group=='C8V ')  .or. &
            (name_point_group=='C8H ')  .or. &
            (name_point_group=='D4D ')  .or. &
            (name_point_group=='S8  ')  .or. &
            (name_point_group=='D8  ')  .or. &
            (name_point_group=='D8H ') ) then
          n_rotations=8
       elseif( (name_point_group=='C9  ')  .or. &
            (name_point_group=='C9V ')  .or. &
            (name_point_group=='C9H ')  .or. &
            (name_point_group=='D9  ')  .or. &
            (name_point_group=='D9H ') ) then
          n_rotations=9
       elseif( (name_point_group=='C10 ')  .or. &
            (name_point_group=='C10V')  .or. &
            (name_point_group=='C10H')  .or. &
            (name_point_group=='D10 ')  .or. &
            (name_point_group=='D10H') ) then
          n_rotations=10
       elseif( (name_point_group=='S12 ')  .or. &
            (name_point_group=='D6D ')) then
          n_rotations=12
       elseif( (name_point_group=='S14 ')  .or. &
            (name_point_group=='D7D ')) then
          n_rotations=14
       elseif( (name_point_group=='S16 ')  .or. &
            (name_point_group=='D8D ')) then
          n_rotations=16
       elseif( (name_point_group=='S18 ')  .or. &
            (name_point_group=='D9D ')) then
          n_rotations=18
       elseif( (name_point_group=='S20 ')  .or. &
            (name_point_group=='D10D')) then
          n_rotations=20
       endif
       if(n_rotations==0) then
          call error_handler( &
               "points_on_cavity_surface: S12 ... S20 and  &
               & D6D ... D10D are yet missing &
               & in the solvent model.Sorry")
       endif

       if(output_cavity_data .and. .not.do_gradients) & 
            write (output_unit,*) 'The DOUBLEPIRAMIDE is inscribed into each sphere'
       call generate_doublepyramide(n_rotations)
!!! MF <<<<
    endif

    call init_cut_rad_sort
    counter_n=0
    call tesselation
!!$    print *,'          call symm_sorted_centers(ret_stat,verbose=.false.)'
   call symm_sorted_centers(ret_stat,verbose=.false.)
!!$    if(ret_stat/=0) then
!!$       print *,'retrying  call symm_sorted_centers(ret_stat,verbose=.true.)'
!!$       call symm_sorted_centers(ret_stat,verbose=.true.)
!!$       if(ret_stat/=0)then
!!$          stop 'symm_sorted_centers failed'
!!$       endif
!!$    endif
    DPRINT 'end of points of cavity'
    if(.not.do_correction .and. .not.do_cavitation .and. .not.do_disp_rep) then 
       DPRINT 'call matrix'
       if(.not. do_gradients) call matrix_generation
       DPRINT 'end matrix'
       if(output_cavity_data .and. .not.do_gradients ) then
          write (output_unit,*) '        THE END OF THE SOLUTE CAVITY POINTS GENERATION'
          write (output_unit,*) '*****************************************************************'
       endif
    endif
    if(do_correction .and. output_cavity_data .and. .not.do_gradients) then
       write (output_unit,*) '      THE SET OF SOLUTE CAVITY POINTS FOR CALCULATION OF'
       write (output_unit,*) '              THE CHARGE CORRECTION HAS BEEN DONE'
       write (output_unit,*) '*****************************************************************'
    endif
    if(do_cavitation .or. do_disp_rep .and. output_cavity_data .and. .not.do_gradients ) then
       write (output_unit,*) '*****************************************************************'
    endif

    DPRINT 'end of points of cavity'
  contains

    !------------------------------------------------------------
    ! Public interface of module
    subroutine calc_cavity_1
      !private subroutine
      !solvent accessible surface (only for dispersion-repulsion and cavitation terms)
      ! End of public interface of module

      real(kind=r8_kind) :: v_d_w_r
      integer(kind=i4_kind) :: vdW_index
      logical :: ext
      integer(kind=i4_kind) :: i,j,k,status

      N_spheres = 0
      do i=1,N_unique_atoms
         if(no_hydrogen_sphere .and. int(unique_atoms(i)%Z)==1_i4_kind) cycle 
         N_spheres = N_spheres + unique_atoms(i)%N_equal_atoms
      enddo
      if(with_pc) then
         do i=1,pointcharge_N
            if(no_hydrogen_sphere .and. (trim(pointcharge_array(i)%name) == "H")) cycle
            do j=1,98
               if(trim(pointcharge_array(i)%name) == trim(atom_name(j))) goto 100
            end do
            cycle
100         N_spheres = N_spheres + pointcharge_array(i)%N_equal_charges
         end do
      end if
      N_atom_spheres=N_spheres

      allocate(r_sphere(N_spheres),iuniq(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface(1): allocation of r_sphere is failed")
      allocate(xyz_sphere(N_spheres,3), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface(1): allocation of xyz_sphere is failed")

      if(do_gradients) then
         allocate(i_unique_at_index(N_spheres),stat=status)
         if(status/=0) call error_handler("calc cavity_1: allocation &
              & of i_unique_at_index is failed")
         i_unique_at_index(:)=0
      endif

      k=0
      n_uni: do i=1,N_unique_atoms
         if(no_hydrogen_sphere .and. int(unique_atoms(i)%Z)==1) cycle n_uni
         ext=.false.
         if(external_vdwr /= 0) then
            do j=1,external_vdwr
               if(i ==  n_uq_at(j)) then
                  vdW_index=j
                  ext=.true.
               endif
            enddo
         endif
         if(external_vdwr /= 0 .and. ext) then
            v_d_w_r=vdwr(vdW_index)
         else
            vdW_index=int(unique_atoms(i)%Z)
	    if(vdW_radius(vdW_index) /= 0.0_r8_kind) then
               v_d_w_r=vdW_radius(vdW_index)
            else
               v_d_w_r=R_def_rap(vdW_index)/2.0_r8_kind
            endif
            if(v_d_w_r == 0.0_r8_kind ) then
               write (output_unit,*) i,' -unique_atom has no default value of van der Waals radius'
               call error_handler( &
                    "points_on_cavity_surface: one of atoms in the solute has no &
                    & default value of van der Waals radius (See output file). If &
                    & You want to know no default van der Waals radii please specify &
                    & option GET_VDWR")
            endif
         endif
         do j=1,unique_atoms(i)%N_equal_atoms
            k=k+1
            r_sphere(k)=v_d_w_r/ang_au+R_access
            iuniq(k)=i
            xyz_sphere(k,:)=unique_atoms(i)%position(:,j)
            ASSERT(ua_dim_max.ne.-1)
            if(do_gradients)then
               i_unique_at_index(k)= (i - 1) * ua_dim_max + (j - 1)
               ASSERT(j.le.ua_dim_max)
            endif
         enddo
      enddo n_uni

      if(with_pc) then
         n_uni_pc: do i=1,pointcharge_N
            if(no_hydrogen_sphere .and. (trim(pointcharge_array(i)%name) == "H")) cycle n_uni_pc

            do j=1,98
               if(trim(pointcharge_array(i)%name) == trim(atom_name(j))) goto 200
            end do
            cycle n_uni_pc
200         vdW_index=j
	    if(vdW_radius(vdW_index) /= 0.0_r8_kind) then
               v_d_w_r=vdW_radius(vdW_index)
            else
               v_d_w_r=R_def_rap(vdW_index)/2.0_r8_kind
            endif
            do j=1,pointcharge_array(i)%N_equal_charges
               k=k+1
               r_sphere(k)=v_d_w_r/ang_au+R_access
               iuniq(k)=i
               xyz_sphere(k,:)=pointcharge_array(i)%position(:,j)
               ASSERT(ua_dim_max.ne.-1)
               if(do_gradients)then
                  i_unique_at_index(k)= (i+N_unique_atoms - 1) * ua_dim_max + (j - 1)
                  ASSERT(j.le.ua_dim_max)
               endif
            enddo
         end do n_uni_pc
      end if

      if(output_cavity_data .and. .not.do_gradients ) then
         write (output_unit,'(a23,i4,a19)') 'The cavity consists of ',N_spheres,' overlaping spheres'
         write (output_unit,*) 'number       radius(a.u.)                 coordinates(a.u)'
         do i=1,N_spheres
            write (output_unit,'(1x,i4,6x,f11.8,6x,3(f13.9,1x))') i,r_sphere(i),xyz_sphere(i,:)
         enddo
         write (output_unit,*) '---------------------------------------------------'
      endif

    end subroutine calc_cavity_1
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine calc_cavity
      ! the solvent excluding surface
      !** End of interface *****************************************

      real(kind=r8_kind) :: r_mini, r_new
      real(kind=r8_kind), allocatable :: r_sphere_buf(:)
      real(kind=r8_kind), allocatable :: xyz_sphere_buf(:,:)
      integer(kind=i4_kind), allocatable :: parents_buf(:,:)
      integer(kind=i4_kind), pointer :: fix_par(:,:)
      integer(kind=i4_kind) :: n_pair, N_spheres_old, n_par_fix,n_max_par

      real(kind=r8_kind) :: distance12, distance13, distance23, d_13, d_23, &
           dist_overlap, dist_h, dist_hiding, sp
      real(kind=r8_kind) :: delta_xyz12(3), delta_xyz13(3), delta_xyz23(3)

      real(kind=r8_kind) :: r_solv,v_d_w_r,s_f,help,rmin,rmax
      real(kind=r8_kind) :: overlap_angle_rad,coso,sino

      integer(kind=i4_kind) :: vdW_index, one_more_sphere
      logical :: ext,use_stored,parents_file_exists
      integer(kind=i4_kind) :: i,j,k,l,status,ii

      !converting parameters to radian and atomic units
      overlap_angle_rad= overlap_angle*pi/180.0_r8_kind
      sino=sin(overlap_angle_rad)
      coso=cos(overlap_angle_rad)
      r_solv=solvent_radius/ang_au !!!!!!!
      r_mini=rmin_gepol/ang_au     !!!!!!
      if(do_cavitation) then
         s_f=1.0_r8_kind
      else
         s_f=scaled_factor
      endif

      parents_file_exists=.false.
      if(fix_number_add) call read_fixed_parents(parents_file_exists,n_max_par,fix_par)
      use_stored=(fix_number_add .and. parents_file_exists)
      if(use_stored) write(output_unit,*) "THE CAVITY CONFIGURATIONS IS TAKEN FROM FIX_PAR FILE"

      N_spheres = 0
      do i=1,N_unique_atoms
         if(no_hydrogen_sphere .and. int(unique_atoms(i)%Z)==1_i4_kind) cycle 
         N_spheres = N_spheres + unique_atoms(i)%N_equal_atoms
      enddo
      if(with_pc) then
         do i=1,pointcharge_N
            if(no_hydrogen_sphere .and. (trim(pointcharge_array(i)%name) == "H")) cycle
            do j=1,98
               if(trim(pointcharge_array(i)%name) == trim(atom_name(j))) goto 100
            end do
            cycle
100         N_spheres = N_spheres + pointcharge_array(i)%N_equal_charges
         end do
      end if
      N_atom_spheres=N_spheres

      if(do_gradients) then
         allocate(i_unique_at_index(N_spheres),stat=status)
         if(status/=0) call error_handler("calc cavity: allocation &
              & of i_unique_at_index is failed")
         i_unique_at_index(:)=0
      endif

      allocate(r_sphere(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of r_sphere is failed")
      allocate(xyz_sphere(N_spheres,3), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of xyz_sphere is failed")
      allocate(parents(N_spheres,2), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of parents is failed")

      !definition of initial spheres
      k=0
      n_uni: do i=1,N_unique_atoms
         if(no_hydrogen_sphere .and. int(unique_atoms(i)%Z)==1) cycle n_uni
         ext=.false.
         if(external_vdwr /= 0) then
            do j=1,external_vdwr
               if(i ==  n_uq_at(j)) then
                  vdW_index=j
                  ext=.true.
               endif
            enddo
         endif
         if(external_vdwr /= 0 .and. ext) then
            v_d_w_r=vdwr(vdW_index)
         else
            vdW_index=int(unique_atoms(i)%Z)
	    if(vdW_radius(vdW_index) /= 0.0_r8_kind) then
               v_d_w_r=vdW_radius(vdW_index)
            else
               v_d_w_r=R_def_rap(vdW_index)/2.0_r8_kind
            endif
            if(v_d_w_r == 0.0_r8_kind ) then
               write (output_unit,*) i,' -unique_atom has no default value of van der Waals radius'
               call error_handler( &
                    "points_on_cavity_surface: one of atoms in the solute has no &
                    & default value of van der Waals radius (See output file). If &
                    & You want to know no default van der Waals radii please specify &
                    & option GET_VDWR")
            endif
         endif
         do j=1,unique_atoms(i)%N_equal_atoms
            k=k+1
	    if((.not.hydrogen_no_scale).or.(unique_atoms(i)%Z/=1.).or.&
                 (do_cavitation)) then
               r_sphere(k)=v_d_w_r*s_f/ang_au  !!!!!
	    else
               r_sphere(k)=v_d_w_r/ang_au      !!!!!!!!
	    endif
            xyz_sphere(k,:)=unique_atoms(i)%position(:,j) !*ang_au !!!!!!!
            parents(k,:)=0
            ASSERT(ua_dim_max.ne.-1)
            if(do_gradients)then
               i_unique_at_index(k)= (i - 1) * ua_dim_max + (j - 1)
               ASSERT(j.le.ua_dim_max)
            endif
         enddo
      enddo n_uni

      if(with_pc) then
         n_uni_pc: do i=1,pointcharge_N
            if(no_hydrogen_sphere .and. (trim(pointcharge_array(i)%name) == "H")) cycle n_uni_pc

            do j=1,98
               if(trim(pointcharge_array(i)%name) == trim(atom_name(j))) goto 200
            end do
            cycle n_uni_pc
200         vdW_index=j
	    if(vdW_radius(vdW_index) /= 0.0_r8_kind) then
               v_d_w_r=vdW_radius(vdW_index)
            else
               v_d_w_r=R_def_rap(vdW_index)/2.0_r8_kind
            endif
            do j=1,pointcharge_array(i)%N_equal_charges
               k=k+1
               if((.not.hydrogen_no_scale).or.(trim(pointcharge_array(i)%name) /= "H").or.&
                    (do_cavitation)) then
                  r_sphere(k)=v_d_w_r*s_f/ang_au  !!!!!
               else
                  r_sphere(k)=v_d_w_r/ang_au
               end if
               xyz_sphere(k,:)=pointcharge_array(i)%position(:,j)
               ASSERT(ua_dim_max.ne.-1)
               parents(k,:)=0
               if(do_gradients)then
                  i_unique_at_index(k)= (i+N_unique_atoms - 1) * ua_dim_max + (j - 1)
                  ASSERT(j.le.ua_dim_max)
               endif
            enddo
         end do n_uni_pc
      end if

      !start main cycle
! 	print*,'start main cycle use stored',use_stored
      N_spheres_old=0
      n_par_fix=1

      main_cycle_0: do
         n_pair = (N_spheres*(N_spheres-1_i4_kind))/2_i4_kind
         allocate(r_sphere_buf(N_spheres+n_pair),stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of r_sphere_buf is failed")
         allocate(xyz_sphere_buf(N_spheres+n_pair,3), stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of xyz_sphere is failed")
         allocate(parents_buf(N_spheres+n_pair,2), stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of parants_buf is failed")

         r_sphere_buf(1:N_spheres)=r_sphere(:)
         xyz_sphere_buf(1:N_spheres,:)=xyz_sphere(:,:)
         parents_buf(1:N_spheres,:)=parents(:,:)

         one_more_sphere=0
         main_cycle_1: do i=1,N_spheres-1
            l=i+1
            if(l < N_spheres_old+1) l= N_spheres_old+1
            main_cycle_2: do j=l,N_spheres

	       if(use_stored ) then
! 		    print*,'fix_par', fix_par(n_par_fix,1),fix_par(n_par_fix,2)
		    if(fix_par(n_par_fix,1)==i .and. fix_par(n_par_fix,2)==j) then
			n_par_fix=n_par_fix+1
		    else
			cycle main_cycle_2
		    endif
	       endif

               delta_xyz12(:) = xyz_sphere(j,:) - xyz_sphere(i,:)
               distance12 = sqrt(dot_product(delta_xyz12,delta_xyz12))

               if(.not. use_stored) then
                 !checking distance between two spheres
                 if (distance12 >= (r_sphere(i)+r_sphere(j)+2.0_r8_kind*r_solv)) cycle  main_cycle_2

                 !checking overlaping of two spheres
                 if (r_sphere(i) <= r_sphere(j)) then
                    rmin=r_sphere(i); rmax=r_sphere(j)
                 else
                    rmin=r_sphere(j); rmax=r_sphere(i)
                 endif
                 help=rmax**2-(rmin*sino)**2
                 if(help<0.0_r8_kind) help=0.0_r8_kind
                 dist_overlap=rmin*coso+sqrt(help)
!                 help=rmax**2-(rmin*coso)**2
!                 if(help<0.0_r8_kind) help=0.0_r8_kind
!                 dist_overlap=rmin*sino+sqrt(help)

                 if (distance12 <= dist_overlap) cycle  main_cycle_2
!                 help=((rmax+r_solv)**2+rmax**2-(r_solv+r_mini)**2)/rmax      !??????????
!                 if (distance12 >= help) cycle  main_cycle_2                  !??????????

                 !are there any other spheres in between two spheres
                 check_hiding: do k=1,N_spheres
                   if (k == i .or. k == j) cycle 

                   delta_xyz13(:) = xyz_sphere(k,:) - xyz_sphere(i,:)
                   distance13 = sqrt(dot_product(delta_xyz13,delta_xyz13))
                   delta_xyz23(:) = xyz_sphere(k,:) - xyz_sphere(j,:)
                   distance23 = sqrt(dot_product(delta_xyz23,delta_xyz23))

!                   d_13=abs(dot_product(delta_xyz13,delta_xyz12)/distance12)
                   d_13=dot_product(delta_xyz13,delta_xyz12)/distance12
                   if(abs(d_13) <= 1.0e-8_r8_kind) d_13=0.0_r8_kind
!                   d_23=abs(dot_product(delta_xyz23,delta_xyz12)/distance12)
                   d_23=dot_product(delta_xyz23,-delta_xyz12)/distance12
                   if(abs(d_23) <= 1.0e-8_r8_kind) d_23=0.0_r8_kind
                   if(d_13 <= 0.0_r8_kind .or. d_23 <= 0.0_r8_kind) cycle

		   help=1.0_r8_kind-(dot_product(delta_xyz13,delta_xyz12)/(distance13*distance12))**2
		   if(help<0.0_r8_kind) help=0.0_r8_kind
                   dist_h=distance13*sqrt(help)

!                   sp = (distance12+distance13+distance23)/2.0_r8_kind      !old fashion
!                   help=4.0_r8_kind*(sp*(sp-distance12)*(sp-distance13)*(sp-distance23))/distance12**2
!                   dist_h=sqrt(help)

                   dist_hiding = r_sphere(k)*fradio
!                   if( dist_h <= dist_hiding .and. abs(distance12-d_13-d_23)<=1.0e-8_r8_kind ) then
                   if( dist_h <= dist_hiding) then
                      cycle main_cycle_2
                   end if
                 enddo check_hiding

               endif !use_stored

               ! creation of new sphere

               if ( distance12 <= (r_sphere(i)+r_sphere(j))) then
                  !case A of GEPOL algorithm
                  help= (r_sphere(j)+r_solv)**2+0.5_r8_kind*(distance12+r_sphere(j)- &
                       r_sphere(i))*(0.5_r8_kind*(distance12+r_sphere(j)-r_sphere(i))- &
                       ((r_sphere(j)+r_solv)**2+distance12**2-(r_sphere(i)+r_solv)**2)/distance12)
                  if(help<0.0_r8_kind) help=0.0_r8_kind     
                  r_new= sqrt(help)-r_solv
                  if ( r_new < r_mini .and. .not. use_stored ) cycle main_cycle_2
! 		  print*,'case A of GEPOL algorithm',distance12,r_sphere(i),r_sphere(j),use_stored
                  one_more_sphere=one_more_sphere+1
                  r_sphere_buf(N_spheres+one_more_sphere)=r_new
                  xyz_sphere_buf(N_spheres+one_more_sphere,:)=& 
                       0.5_r8_kind*(xyz_sphere(j,:)+xyz_sphere(i,:))- &
                       (r_sphere(j)-r_sphere(i))*(xyz_sphere(j,:)- &
                       xyz_sphere(i,:))/(2.0_r8_kind*distance12)
               else
                  help= (r_sphere(j)+r_solv)**2+0.5_r8_kind*(distance12+r_sphere(j)- &
                       r_sphere(i))*(0.5_r8_kind*(distance12+r_sphere(j)-r_sphere(i))- &
                       ((r_sphere(j)+r_solv)**2+distance12**2-(r_sphere(i)+r_solv)**2)/distance12)
		  if(help<0.0_r8_kind) help=0.0_r8_kind
                  r_new= sqrt(help)-r_solv

                  if ( r_new >= r_mini .or. use_stored) then
                     !case B of GEPOL algorithm
! 		     print*,'case B of GEPOL algorithm'
                     one_more_sphere=one_more_sphere+1
                     r_sphere_buf(N_spheres+one_more_sphere)=r_new
                     xyz_sphere_buf(N_spheres+one_more_sphere,:)= &
                          0.5_r8_kind*(xyz_sphere(j,:)+xyz_sphere(i,:))- &
                          (r_sphere(j)-r_sphere(i))*(xyz_sphere(j,:)- &
                          xyz_sphere(i,:))/(2.0_r8_kind*distance12)
                  else
                     !case C of GEPOL algorithm
                     if( r_sphere(j) >= r_sphere(i) ) then
                        help=(r_sphere(j)+r_solv)**2+r_sphere(j)**2- &
                             r_sphere(j)*((r_sphere(j)+r_solv)**2+distance12**2- &
                             (r_sphere(i)+r_solv)**2)/distance12
			if(help<0.0_r8_kind) help=0.0_r8_kind
                        r_new= sqrt(help)-r_solv
                        if ( r_new < r_mini .and. .not. use_stored ) cycle main_cycle_2
! 		        print*,'case C of GEPOL algorithm'
                        one_more_sphere=one_more_sphere+1
                        r_sphere_buf(N_spheres+one_more_sphere)=r_new
                        xyz_sphere_buf(N_spheres+one_more_sphere,:)= &
                             xyz_sphere(j,:)-r_sphere(j)*(xyz_sphere(j,:)-xyz_sphere(i,:))/distance12
                     else

                        help=(r_sphere(i)+r_solv)**2+r_sphere(i)**2- &
                             r_sphere(i)*((r_sphere(i)+r_solv)**2+distance12**2- &
                             (r_sphere(j)+r_solv)**2)/distance12
                        r_new= sqrt(help)-r_solv
                        if ( r_new < r_mini .and. .not. use_stored) cycle main_cycle_2
! 		       print*,'last case of GEPOL algorithm'
                        one_more_sphere=one_more_sphere+1
                        r_sphere_buf(N_spheres+one_more_sphere)=r_new
                        xyz_sphere_buf(N_spheres+one_more_sphere,:)= &
                             xyz_sphere(i,:)-r_sphere(i)*(xyz_sphere(i,:)-xyz_sphere(j,:))/distance12
                     endif
                  endif
               endif
               parents_buf(N_spheres+one_more_sphere,1)=i
               parents_buf(N_spheres+one_more_sphere,2)=j

            enddo main_cycle_2
         enddo main_cycle_1

         deallocate(r_sphere, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of r_sphere is failed")
         deallocate(xyz_sphere, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of xyz_sphere is failed")
         deallocate(parents, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of parents is failed")

         N_spheres_old=N_spheres
         N_spheres= N_spheres+one_more_sphere

         allocate(r_sphere(N_spheres), stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of r_sphere is failed(1)")
         allocate(xyz_sphere(N_spheres,3), stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of xyz_sphere is failed(1)")
         allocate(parents(N_spheres,2), stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of parents is failed(1)")

         r_sphere(:)=r_sphere_buf(1:N_spheres)
         xyz_sphere(:,:)=xyz_sphere_buf(1:N_spheres,:)
         parents(:,:)=parents_buf(1:N_spheres,:)
         do j=1,N_spheres
            do i=1,3
               if(abs(xyz_sphere(j,i)) <= 1.0E-10_r8_kind) xyz_sphere(j,i)=0.0_r8_kind
            enddo
         enddo

         deallocate(r_sphere_buf, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation r_sphere_buf is failed")
         deallocate(xyz_sphere_buf, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation xyz_sphere_buf is failed")
         deallocate(parents_buf, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of parents_buf is failed")

         if (one_more_sphere == 0 ) exit main_cycle_0
      enddo main_cycle_0

      if(fix_number_add .and. .not. parents_file_exists) then
		call write_fixed_parents(N_spheres,N_atom_spheres,parents)
      else if(fix_number_add) then
		deallocate(fix_par,stat=status)
		if( status /= 0) call error_handler( &
			"points_on_cavity_surface: deallocation of fix_par is failed")
      endif
      if(output_cavity_data .and. .not.do_gradients) then
         write (output_unit,'(a23,i4,a19)') 'The cavity consists of ',N_spheres,' overlaping spheres'
         write (output_unit,*) 'number       radius(a.u.)                 coordinates(a.u)'
         do i=1,N_spheres
            write (output_unit,'(1x,i4,6x,f11.8,6x,3(f13.9,1x))') i,r_sphere(i),xyz_sphere(i,:)
         enddo
         write (output_unit,*) '---------------------------------------------------'
      endif

    end subroutine calc_cavity
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    subroutine read_fixed_parents(f_exists,n_max_par,fix_par)
      !** End of interface *****************************************
      use iounitadmin_module
      use filename_module
      integer(kind=i4_kind) :: st, iounit,ii
      logical,intent(out) :: f_exists
      integer, intent(out) :: n_max_par
      integer, pointer :: fix_par(:,:)
    
      if(gepol==87) then
         inquire(file=trim(input_dir)//'/fix_par',EXIST=f_exists)
         if(f_exists) then
            iounit = openget_iounit(file=trim(input_dir)//'/fix_par',form='FORMATTED', &
                 action='READ',status='OLD')
         else 	
            inquire(file=trim(data_dir)//'/fix_par',EXIST=f_exists)
            if(f_exists) then
               iounit = openget_iounit(file=trim(data_dir)//'/fix_par',form='FORMATTED', &
                    action='READ',status='OLD')
            else 	
               return
            endif
         endif
      elseif(gepol==93) then
         inquire(file=trim(input_dir)//'/fix_par.93a',EXIST=f_exists)
         if(f_exists) then
            iounit = openget_iounit(file=trim(input_dir)//'/fix_par.93a',form='FORMATTED', &
                 action='READ',status='OLD')
         else 	
            inquire(file=trim(data_dir)//'/fix_par.93a',EXIST=f_exists)
            if(f_exists) then
               iounit = openget_iounit(file=trim(data_dir)//'/fix_par.93a',form='FORMATTED', &
                    action='READ',status='OLD')
            else 	
               return
            endif
         endif
      end if

      read(iounit, fmt=*, iostat=st) n_max_par
      if ( st .ne. 0 ) call error_handler("read_fixed_parents: read n_max_par failed")

      if(gepol==87) then
         allocate(fix_par(n_max_par+1,2),stat=st)
      elseif(gepol==93) then
         allocate(fix_par(n_max_par+1,3),stat=st)
      end if
      if ( st .ne. 0 ) call error_handler("read_fixed_parents: allocation failed")
      fix_par=0

      do ii=1,n_max_par
         if(gepol==87) then
            read(iounit, fmt=*, iostat=st) fix_par(ii,1:2)
         elseif(gepol==93) then
            read(iounit, fmt=*, iostat=st) fix_par(ii,1:3)
         end if
         if ( st .ne. 0 ) call error_handler("read_fixed_parents: read fix_par failed")
      enddo

      call returnclose_iounit(iounit,status='KEEP')
    end subroutine read_fixed_parents
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
    subroutine write_fixed_parents(n_sph,n_at_sph,fixed_par)
    !** End of interface *****************************************
      use iounitadmin_module
      use filename_module
      integer(kind=i4_kind) :: iostat, iounit,ii, n_par,iounit1
      integer(kind=i4_kind), intent(in) :: n_sph,n_at_sph,fixed_par(:,:)

      n_par=n_sph-n_at_sph

      if(gepol == 87) then
         iounit = openget_iounit(file=trim(data_dir)//'/fix_par',form='FORMATTED', &
              action='WRITE',status='NEW')
         iounit1 = openget_iounit(file=trim(output_dir)//'/fix_par',form='FORMATTED', &
              action='WRITE',status='NEW')
      elseif(gepol==93) then
         iounit = openget_iounit(file=trim(data_dir)//'/fix_par.93a',form='FORMATTED', &
              action='WRITE',status='NEW')
         iounit1 = openget_iounit(file=trim(output_dir)//'/fix_par.93a',form='FORMATTED', &
              action='WRITE',status='NEW')
      end if

      write(iounit,iostat=iostat,fmt='(i5)') n_par
      if ( iostat .ne. 0 ) call error_handler("write_fixed_parents: write failed (data_dir)" )     
      write(iounit1,iostat=iostat,fmt='(i5)') n_par
      if ( iostat .ne. 0 ) call error_handler("write_fixed_parents: write failed (output_dir)" )     

      do ii=1,n_par
         if(gepol == 87) then
            write(iounit,iostat=iostat,fmt='(2i5)') fixed_par(ii+n_at_sph,:)
         elseif(gepol==93) then
            write(iounit,iostat=iostat,fmt='(3i5)') fixed_par(ii+n_at_sph,:)
         end if
         if ( iostat .ne. 0 ) call error_handler("write_fixed_parents: write failed (data)" )     
         if(gepol == 87) then
            write(iounit1,iostat=iostat,fmt='(2i5)') fixed_par(ii+n_at_sph,:)
         elseif(gepol==93) then
            write(iounit1,iostat=iostat,fmt='(3i5)') fixed_par(ii+n_at_sph,:)
         end if
         if ( iostat .ne. 0 ) call error_handler("write_fixed_parents: write failed (output)" )     
      enddo
      
      call returnclose_iounit(iounit,status='KEEP')
      call returnclose_iounit(iounit1,status='KEEP')
    end subroutine write_fixed_parents
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   

    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine calc_cavity_93
      !Solvent excluding surface (Gepol93 algorithm)
      !** End of interface *****************************************
      real(r8_kind), allocatable :: r_sphere_buf(:)
      real(r8_kind), allocatable :: xyz_sphere_buf(:,:)
      integer(i4_kind), allocatable :: parents_buf(:,:)
      integer(i4_kind), allocatable :: pairs(:,:)
      integer(i4_kind) :: n_pairs
      integer(i4_kind) :: sym_pairs(500,2)
      integer(i4_kind), pointer :: fix_par(:,:)
      integer(i4_kind) :: n_par_fix,n_max_par

      real(r8_kind) :: r_mini,r_max,r_min,r_solv,v_d_w_r,s_f,ofac
      integer(i4_kind) :: vdW_index,N_spheres_old,one_more_sphere
      real(r8_kind) :: distance12,dist13,dist23
      real(r8_kind) :: delta_xyz12(3),delta_xyz13(3)
      real(r8_kind) :: xyz_new(3),r_new,dist_1new,dist_2new,dist_3new
      real(r8_kind) :: xyz_surf(3),dist_sk
      real(r8_kind) :: xyz_symm(500,4)
      integer(i4_kind) :: max_i,min_i,n_sym

      logical :: ext,parents_file_exists,use_stored
      integer(i4_kind) :: i,j,k,l,m,n,kk,status
      real(r8_kind), parameter :: smalll=1.0e-8_r8_kind

      !converting parameters to radian and atomic units
      r_solv=solvent_radius/ang_au !!!!!!!
      r_mini=rmin_gepol/ang_au  !!!!!!!!!
      if(do_cavitation) then
         s_f=1.0_r8_kind
      else
         s_f=scaled_factor
      endif
      ofac=1.0_r8_kind-2.0_r8_kind*overlap_factor

      allocate(r_sphere_buf(N_max_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of r_sphere_buf is failed (93)")
      allocate(xyz_sphere_buf(N_max_spheres,3), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of xyz_sphere_buf is failed (93)")
      allocate(parents_buf(N_max_spheres,3), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of parents_buf is failed (93)")
      allocate(pairs(N_max_spheres*N_max_spheres,2), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of pairs is failed (93)")

      parents_file_exists=.false.
      if(fix_number_add) call read_fixed_parents(parents_file_exists,n_max_par,fix_par)
      use_stored=(fix_number_add .and. parents_file_exists)
      if(use_stored) write(output_unit,*) "THE CAVITY CONFIGURATIONS IS TAKEN FROM FIX_PAR.93 FILE"

      N_spheres = 0
      do i=1,N_unique_atoms
         if(no_hydrogen_sphere .and. int(unique_atoms(i)%Z)==1_i4_kind) cycle
         N_spheres = N_spheres + unique_atoms(i)%N_equal_atoms
      enddo
      if(with_pc) then
         do i=1,pointcharge_N
            if(no_hydrogen_sphere .and. (trim(pointcharge_array(i)%name) == "H")) cycle
            do j=1,98
               if(trim(pointcharge_array(i)%name) == trim(atom_name(j))) goto 100
            end do
            cycle
100         N_spheres = N_spheres + pointcharge_array(i)%N_equal_charges
         end do
      end if
      N_atom_spheres=N_spheres

      if(do_gradients) then
         allocate(i_unique_at_index(N_spheres),stat=status)
         if(status/=0) call error_handler("calc cavity: allocation &
              & of i_unique_at_index is failed (93)")
         i_unique_at_index(:)=0
      endif

      !definition of initial spheres
      k=0
      n_uni: do i=1,N_unique_atoms
         if(no_hydrogen_sphere .and. int(unique_atoms(i)%Z)==1) cycle n_uni
         ext=.false.
         if(external_vdwr /= 0) then
            do j=1,external_vdwr
               if(i ==  n_uq_at(j)) then
                  vdW_index=j
                  ext=.true.
               endif
            enddo
         endif
         if(external_vdwr /= 0 .and. ext) then
            v_d_w_r=vdwr(vdW_index)
         else
            vdW_index=int(unique_atoms(i)%Z)
            if(vdW_radius(vdW_index) /= 0.0_r8_kind) then
               v_d_w_r=vdW_radius(vdW_index)
            else
               v_d_w_r=R_def_rap(vdW_index)/2.0_r8_kind
            endif
            if(v_d_w_r == 0.0_r8_kind ) then
               write (output_unit,*) i,' -unique_atom has no default value of van der Waals radius'
               call error_handler( &
                    "points_on_cavity_surface: one of atoms in the solute has no &
                    & default value of van der Waals radius (See output file). If &
                    & You want to know no default van der Waals radii please specify &
                    & option GET_VDWR")
            endif
         endif
         do j=1,unique_atoms(i)%N_equal_atoms
            k=k+1
            if((.not.hydrogen_no_scale).or.(unique_atoms(i)%Z/=1.0_r8_kind).or.&
                 (do_cavitation)) then
               r_sphere_buf(k)=v_d_w_r*s_f/ang_au  !!!!!!!!!!!
            else
               r_sphere_buf(k)=v_d_w_r/ang_au  !!!!!!!!
            endif
            xyz_sphere_buf(k,:)=unique_atoms(i)%position(:,j) !*ang_au !!!!!!!
            parents_buf(k,:)=0
            if(do_gradients) i_unique_at_index(k)= (i - 1) * ua_dim_max + (j - 1) !i*10+j
         enddo
      enddo n_uni

      if(with_pc) then
         n_uni_pc: do i=1,pointcharge_N 
            if(no_hydrogen_sphere .and. (trim(pointcharge_array(i)%name) == "H")) cycle n_uni_pc

            do j=1,98
               if(trim(pointcharge_array(i)%name) == trim(atom_name(j))) goto 200
            end do
            cycle n_uni_pc
200         vdW_index=j
            if(vdW_radius(vdW_index) /= 0.0_r8_kind) then
               v_d_w_r=vdW_radius(vdW_index)
            else
               v_d_w_r=R_def_rap(vdW_index)/2.0_r8_kind
            endif
            do j=1,pointcharge_array(i)%N_equal_charges
               k=k+1
               if((.not.hydrogen_no_scale).or.(trim(pointcharge_array(i)%name) /= "H").or.&
                    (do_cavitation)) then      
                  r_sphere_buf(k)=v_d_w_r*s_f/ang_au  !!!!!
               else
                  r_sphere_buf(k)=v_d_w_r/ang_au
               end if
               xyz_sphere_buf(k,:)=pointcharge_array(i)%position(:,j)
               parents_buf(k,:)=0
               if(do_gradients) i_unique_at_index(k)= (i+N_unique_atoms - 1) * ua_dim_max + (j - 1)
            enddo 
         end do n_uni_pc
      end if

      do j=1,N_spheres
         do i=1,3
            if(abs(xyz_sphere_buf(j,i)) <= 1.0E-10_r8_kind) xyz_sphere_buf(j,i)=0.0_r8_kind
         enddo
      enddo

      pairs=0; n_pairs=0

      n_par_fix=1
      !start BULK mode: fill internal space by spheres which have no contact to
      !solvent (solvent accessible surface are zero)
      N_spheres_old=0
      bulk: do
         one_more_sphere=0         

         !choose the first sphere of the pair
         first: do i=1,N_spheres-1
            l=i+1
            if(l < N_spheres_old+1) l= N_spheres_old+1

            !choose the second sphere of the pair
            second: do j=l,N_spheres

               do k=1,n_pairs
                  if(i==pairs(k,1) .and. j==pairs(k,2)) cycle second
               end do

               if(use_stored ) then
                    if(fix_par(n_par_fix,1)==i .and. &
                       fix_par(n_par_fix,2)==j .and. &
                       fix_par(n_par_fix,3)==1) then
                     else
                        cycle second
                    endif
               endif
               
               !calculate the distance between the spheres
               delta_xyz12(:) = xyz_sphere_buf(j,:) - xyz_sphere_buf(i,:)
               distance12 = sqrt(dot_product(delta_xyz12,delta_xyz12))
                  
               if(.not.use_stored) then
                  !can the solvent pass between spheres? if Yes choose new second sphere
                  if (distance12 >= (r_sphere_buf(i)+r_sphere_buf(j)+2.0_r8_kind*r_solv)) then
                     sym_pairs=0
                     call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                          sym_pairs,n_sym)
                     do kk=1,n_sym
                        n_pairs=n_pairs+1
                        pairs(n_pairs,:)=sym_pairs(kk,:)
                     end do
                     cycle second
                  end if
                  
                  !choose the largest sphere
                  if(r_sphere_buf(i) >= r_sphere_buf(j)) then
                     r_max=r_sphere_buf(i)
                     r_min=r_sphere_buf(j)
                  else
                     r_max=r_sphere_buf(j)
                     r_min=r_sphere_buf(i)
                  end if

                  !check overlapping two spheres. If spheres too close to each other
                  !choose new second sphere
                  if(distance12 <= r_max+r_min*ofac) then 
                     sym_pairs=0
                     call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                          sym_pairs,n_sym)
                     do kk=1,n_sym
                        n_pairs=n_pairs+1
                        pairs(n_pairs,:)=sym_pairs(kk,:)
                     end do
                     cycle second
                  end if

                  !compute coordinates, radius of new sphere and its distance to
                  !the first sphere
                  xyz_new=0.5_r8_kind*(xyz_sphere_buf(j,:)+xyz_sphere_buf(i,:))- &
                       (r_sphere_buf(j)-r_sphere_buf(i))*(xyz_sphere_buf(j,:)-xyz_sphere_buf(i,:))/ &
                       (2.0_r8_kind*distance12)
                  r_new=r_max
                  dist_1new=0.5_r8_kind*(distance12-r_sphere_buf(j)+r_sphere_buf(i))


                  !check overlapping the new sphere
                  third: do k=1,N_spheres+one_more_sphere
                     delta_xyz13(:) = xyz_new(:) - xyz_sphere_buf(k,:)
                     dist_3new = sqrt(dot_product(delta_xyz13,delta_xyz13))
                     
                     !if no overlapping choose new the third sphere
                     if(dist_3new >= r_sphere_buf(k)+r_new) cycle third
                     !if overlapping
                     if(r_new > r_sphere_buf(k)) cycle third
                     !if overlapping too strong cancel the process and choose new second sphere
                     if(dist_3new <= r_sphere_buf(k)+r_new*ofac) then 
                        sym_pairs=0
                        call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                             sym_pairs,n_sym)
                        do kk=1,n_sym
                           n_pairs=n_pairs+1
                           pairs(n_pairs,:)=sym_pairs(kk,:)
                        end do
                        cycle second
                     end if
                  end do third

                  !Determine if new sphere contact with solvent
                  !(has non zero solvent accessible surface)
                  !if Yes choose new second sphere (define new pair)
                  surf_points:do k=1,N_centers_on_sphere
                     xyz_surf=surf_elem%xyz_centers(k,:)*(r_new+r_solv)/radius+xyz_new

                     atoms:do m=1,N_atom_spheres
                        delta_xyz13(:) = xyz_surf(:) - xyz_sphere_buf(m,:)
                        dist_sk = sqrt(dot_product(delta_xyz13,delta_xyz13))
                        
                        if(dist_sk < r_sphere_buf(m)+r_solv) cycle surf_points
                     end do atoms
                     sym_pairs=0
                     call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                          sym_pairs,n_sym)
                     do kk=1,n_sym
                        n_pairs=n_pairs+1
                        pairs(n_pairs,:)=sym_pairs(kk,:)
                     end do
                     cycle second
                  end do surf_points
               else
                  !choose the largest sphere
                  if(r_sphere_buf(i) >= r_sphere_buf(j)) then
                     r_max=r_sphere_buf(i)
                     r_min=r_sphere_buf(j)
                  else
                     r_max=r_sphere_buf(j)
                     r_min=r_sphere_buf(i)
                  end if
                  !compute coordinates, radius of new sphere and its distance to
                  !the first sphere
                  xyz_new=0.5_r8_kind*(xyz_sphere_buf(j,:)+xyz_sphere_buf(i,:))- &
                       (r_sphere_buf(j)-r_sphere_buf(i))*(xyz_sphere_buf(j,:)-xyz_sphere_buf(i,:))/ &
                       (2.0_r8_kind*distance12)
                  r_new=r_max
               end if
                  
               sym_pairs=0
               call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                    sym_pairs,n_sym,xyz_new,xyz_symm)
               l_kk1:do kk=1,n_sym
                  n_pairs=n_pairs+1
                  pairs(n_pairs,:)=sym_pairs(kk,:)
                  if(int(xyz_symm(kk,4))==0) cycle 
                  one_more_sphere=one_more_sphere+1
                  xyz_sphere_buf(N_spheres+one_more_sphere,:)=xyz_symm(kk,1:3)
                  r_sphere_buf(N_spheres+one_more_sphere)=r_new
                  parents_buf(N_spheres+one_more_sphere,1)=sym_pairs(kk,1)
                  parents_buf(N_spheres+one_more_sphere,2)=sym_pairs(kk,2)
                  parents_buf(N_spheres+one_more_sphere,3)=1
                  if(use_stored ) n_par_fix=n_par_fix+1
               end do l_kk1
            end do second
         end do first

         N_spheres_old=N_spheres
         N_spheres=N_spheres+one_more_sphere
         if(N_spheres > N_max_spheres) call error_handler("calc_cavity 93: number of &
              & spheres have exceeded maximal value 1000")
         
         if(one_more_sphere == 0) exit bulk
      
      end do bulk

      do j=1,N_spheres
         do i=1,3
            if(abs(xyz_sphere_buf(j,i)) <= 1.0E-10_r8_kind) xyz_sphere_buf(j,i)=0.0_r8_kind
         enddo
      enddo

      pairs=0; n_pairs=0

      !start CREA mode: refining the surface built after BULK mode run
      N_spheres_old=0
      crea: do
         one_more_sphere=0         

         !choose the first sphere of the pair
         first1: do i=1,N_spheres-1
            l=i+1
            if(l < N_spheres_old+1) l= N_spheres_old+1

            !choose the second sphere of the pair
            second1: do j=l,N_spheres
               do k=1,n_pairs
                  if(i==pairs(k,1) .and. j==pairs(k,2)) cycle second1
               end do

               if(use_stored ) then
                    if(fix_par(n_par_fix,1)==i .and. &
                       fix_par(n_par_fix,2)==j .and. &
                       fix_par(n_par_fix,3)==2) then
                    else
                        cycle second1
                    endif
               endif

               !calculate the distance between the spheres
               delta_xyz12(:) = xyz_sphere_buf(j,:) - xyz_sphere_buf(i,:)
               distance12 = sqrt(dot_product(delta_xyz12,delta_xyz12))

               if(.not.use_stored) then
                  !can the solvent pass between spheres? if Yes choose new second sphere
                  if (distance12 >= (r_sphere_buf(i)+r_sphere_buf(j)+2.0_r8_kind*r_solv)) then
                     sym_pairs=0
                     call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                          sym_pairs,n_sym)
                     do kk=1,n_sym
                        n_pairs=n_pairs+1
                        pairs(n_pairs,:)=sym_pairs(kk,:)
                     end do
                     cycle second1
                  end if

                  !choose the largest sphere
                  if(r_sphere_buf(i) >= r_sphere_buf(j)) then
                     r_max=r_sphere_buf(i)
                     r_min=r_sphere_buf(j)
                     max_i=i; min_i=j
                  else
                     r_max=r_sphere_buf(j)
                     r_min=r_sphere_buf(i)
                     max_i=j; min_i=i
                  end if

                  !check overlapping two spheres. If spheres too close to each other
                  !choose new second sphere
                  if(distance12 < r_max+r_min*ofac) then 
                     cycle second1
                     sym_pairs=0
                     call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                          sym_pairs,n_sym)
                     do kk=1,n_sym
                        n_pairs=n_pairs+1
                        pairs(n_pairs,:)=sym_pairs(kk,:)
                     end do
                  end if
               else
                  !choose the largest sphere
                  if(r_sphere_buf(i) >= r_sphere_buf(j)) then
                     r_max=r_sphere_buf(i)
                     r_min=r_sphere_buf(j)
                     max_i=i; min_i=j
                  else
                     r_max=r_sphere_buf(j)
                     r_min=r_sphere_buf(i)
                     max_i=j; min_i=i
                  end if
               end if

               dist13=r_min+r_solv
               dist23=r_max+r_solv
               dist_2new=0.5_r8_kind*(distance12-r_min+r_max)

               if(distance12 <= r_sphere_buf(i)+r_sphere_buf(j)) then
                  !variant A of sphere building
                  r_new=sqrt(dist23**2+dist_2new* &
                       (dist_2new-(dist23**2+distance12**2-dist13**2)/distance12))- &
                       r_solv
                  if(r_new <= r_mini) then 
                     cycle second1
                     sym_pairs=0
                     call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                          sym_pairs,n_sym)
                     do kk=1,n_sym
                        n_pairs=n_pairs+1
                        pairs(n_pairs,:)=sym_pairs(kk,:)
                     end do
                  end if
                  xyz_new=0.5_r8_kind*(xyz_sphere_buf(max_i,:)+xyz_sphere_buf(min_i,:))- &
                       (r_max-r_min)*(xyz_sphere_buf(max_i,:)-xyz_sphere_buf(min_i,:))/ &
                       (2.0_r8_kind*distance12)
                  dist_1new=0.5_r8_kind*(distance12-r_sphere_buf(j)+r_sphere_buf(i))
               else
                  !variants B and C
                  r_new=sqrt(dist23**2+dist_2new* &
                       (dist_2new-(dist23**2+distance12**2-dist13**2)/distance12))- &
                       r_solv
                  if(r_new > r_mini) then
                     !variant B
                     xyz_new=0.5_r8_kind*(xyz_sphere_buf(max_i,:)+xyz_sphere_buf(min_i,:))- &
                          (r_max-r_min)*(xyz_sphere_buf(max_i,:)-xyz_sphere_buf(min_i,:))/ &
                          (2.0_r8_kind*distance12)
                     dist_1new=0.5_r8_kind*(distance12-r_sphere_buf(j)+r_sphere_buf(i))
                  else
                     !variant C
                     r_new=sqrt(dist23**2+r_max**2- &
                          (r_max/distance12)*(dist23**2+distance12**2-dist13**2))- &
                          r_solv
                     if(r_new <= r_mini) then 
                        sym_pairs=0
                        call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                             sym_pairs,n_sym)
                        do kk=1,n_sym
                           n_pairs=n_pairs+1
                           pairs(n_pairs,:)=sym_pairs(kk,:)
                        end do
                        cycle second1
                     end if
                     xyz_new=0.5_r8_kind*(xyz_sphere_buf(max_i,:)+xyz_sphere_buf(min_i,:))- &
                          (r_max-r_min)*(xyz_sphere_buf(max_i,:)-xyz_sphere_buf(min_i,:))/ &
                          (2.0_r8_kind*distance12)
                     if(max_i == i) then
                        dist_1new=dist_2new
                     else
                        dist_1new=distance12-dist_2new
                     end if
                  end if
               end if

               if(.not.use_stored) then
                  !check overlapping the new sphere
                  third1: do k=1,N_spheres+one_more_sphere
                     delta_xyz13(:) = xyz_new(:) - xyz_sphere_buf(k,:)
                     dist_3new = sqrt(dot_product(delta_xyz13,delta_xyz13))
                  
                     !if no overlapping choose new the third sphere
                     if(dist_3new >= r_sphere_buf(k)+r_new) cycle third1
                     !if overlapping
                     if(r_new > r_sphere_buf(k) .and.  &
                          abs(r_new-r_sphere_buf(k)) > smalll) cycle third1
                     !if overlapping too strong cancel the process and choose new second sphere
                     if(dist_3new <= r_sphere_buf(k)+r_new*ofac) then 
                        sym_pairs=0
                        call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                             sym_pairs,n_sym)
                        do kk=1,n_sym
                           n_pairs=n_pairs+1
                           pairs(n_pairs,:)=sym_pairs(kk,:)
                        end do
                        cycle second1
                     end if
                  end do third1
               end if

               sym_pairs=0
               call calc_symm_pairs(i,j,distance12,xyz_sphere_buf(1:N_spheres,1:3),N_spheres, &
                    sym_pairs,n_sym,xyz_new,xyz_symm)
               l_kk:do kk=1,n_sym
                  n_pairs=n_pairs+1
                  pairs(n_pairs,:)=sym_pairs(kk,:)
                  if(int(xyz_symm(kk,4))==0) cycle 
                  one_more_sphere=one_more_sphere+1
                  xyz_sphere_buf(N_spheres+one_more_sphere,:)=xyz_symm(kk,1:3)
                  r_sphere_buf(N_spheres+one_more_sphere)=r_new
                  parents_buf(N_spheres+one_more_sphere,1)=sym_pairs(kk,1)
                  parents_buf(N_spheres+one_more_sphere,2)=sym_pairs(kk,2)
                  parents_buf(N_spheres+one_more_sphere,3)=2
                  if(use_stored ) n_par_fix=n_par_fix+1
               end do l_kk
            end do second1
         end do first1

         N_spheres_old=N_spheres
         N_spheres=N_spheres+one_more_sphere
         if(N_spheres > N_max_spheres) call error_handler("calc_cavity 93: number of &
              & spheres have exceeded maximal value 1000 (1)")

         if(one_more_sphere == 0) exit crea

      end do crea

      allocate(r_sphere(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of r_sphere is failed (93)")
      allocate(zero_area(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of zero_area is failed (93)")
      allocate(xyz_sphere(N_spheres,3), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of xyz_sphere is failed (93)")
      allocate(parents(N_spheres,3), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of parents is failed (93)")

      r_sphere(1:N_spheres)=r_sphere_buf(1:N_spheres)
      xyz_sphere(1:N_spheres,:)=xyz_sphere_buf(1:N_spheres,:)
      parents(1:N_spheres,:)=parents_buf(1:N_spheres,:)

      do j=1,N_spheres
         do i=1,3
            if(abs(xyz_sphere(j,i)) <= 1.0E-10_r8_kind) xyz_sphere(j,i)=0.0_r8_kind
         enddo
      enddo

      !marking spheres with zero contribution to solvent excluding surface
      zero_area=.true.
      one:do i=1,N_spheres
         three:do k=1,N_centers_on_sphere
            xyz_surf=surf_elem%xyz_centers(k,:)*r_sphere(i)/radius+xyz_sphere(i,:)
            two:do j=1,N_spheres
               if(j==i) cycle two
                        
               delta_xyz13(:) = xyz_surf(:) - xyz_sphere(j,:)
               dist_sk = sqrt(dot_product(delta_xyz13,delta_xyz13))
                        
               if(dist_sk <= r_sphere_buf(j)) cycle three
            end do two
            zero_area(i)=.false.
            cycle one
         enddo three
      enddo one

      deallocate(r_sphere_buf, stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: deallocation of r_sphere_buf is failed (93)")
      deallocate(xyz_sphere_buf, stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: deallocation of xyz_sphere_buf is failed (93)")
      deallocate(parents_buf, stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: deallocation of parents_buf is failed (93)")
      deallocate(pairs, stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: deallocation of pairs is failed (93)")

      if(fix_number_add .and. .not. parents_file_exists) then
         call write_fixed_parents(N_spheres,N_atom_spheres,parents)
      else if(fix_number_add) then
         deallocate(fix_par,stat=status)
         if( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of fix_par is failed (93)")
      end if

      if(output_cavity_data .and. .not.do_gradients) then
         write (output_unit,'(a23,i4,a19)') 'The cavity consists of ',N_spheres,' overlaping spheres'
         write (output_unit,*) 'number       radius(a.u.)                 coordinates(a.u)'
         do i=1,N_spheres
            write (output_unit,'(1x,i4,6x,f11.8,6x,3(f13.9,1x),l1)') i,r_sphere(i),xyz_sphere(i,:),zero_area(i)
         enddo
         write (output_unit,*) '---------------------------------------------------'
      endif

    end subroutine calc_cavity_93
    !------------------------------------------------------------
!!!MF - gradients >>>> 
    !------------------------------------------------------------
    subroutine calc_cavity_gradient(cavity_flag)
      ! formulas see Cossi 1996
      !** End of interface *****************************************
      logical, intent(in) :: cavity_flag ! spheres with parents?

      integer(kind=i4_kind) :: i,j,k,l,l1,l2,l3,status,na,ea
      real(kind=r8_kind) :: r1s,r2s,ras,d12,vbuf(3),help
      real(kind=r8_kind) :: drdr1,drdr2,drda(3),dadr(3),dbdadiag1,dbdadiag2,&
           dbdanondiag,r_solv
      logical :: dist_check_j,dist_check_k
      integer :: N_pc
      real(kind=r8_kind), parameter :: small=1.e-8_r8_kind

      N_pc=0
!!$      if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
      if(with_pc) N_pc=pointcharge_N
      
      DPRINT 'calc_cavity_gradient(',cavity_flag,'): enetered'
      r_solv=solvent_radius/ang_au
      call alloc_geom_deriv_part1(cagr)

      ! gradients of atomic centers and radia
      ASSERT(ua_dim_max.ne.-1)
      do i=1,N_atom_spheres
         DPRINT '_gradient: i_unique_at_index(',i,')=',i_unique_at_index(i)
         na= 1 +     i_unique_at_index(i) / ua_dim_max
         ea= 1 + mod(i_unique_at_index(i),  ua_dim_max)
         DPRINT '_gradient: na=',na,' ea=',ea
         do j=1,3
            cagr%dc(j,i)%xyz_grad(j,na,ea)=1.0_r8_kind
         enddo
      enddo

      deallocate(i_unique_at_index,stat=status)
      if(status/=0) call error_handler("calc_cavity_gradient: &
		& deallocation of i_unique_at_index is failed") 

      ! gradients of additional centers and radii
      ! spheres are ordered such that parents always before childs
      cav_f: if(cavity_flag) then
         do i=N_atom_spheres+1,N_spheres 
            j=parents(i,1)
            k=parents(i,2)
            if(j>=i .or. k>=i) call error_handler("calc_cavity_gradient: &
                 & wrong order of spheres")

            vbuf=xyz_sphere(j,:)-xyz_sphere(k,:)

            d12=sqrt(dot_product(vbuf,vbuf))
            r1s=r_sphere(j)+r_solv
            r2s=r_sphere(k)+r_solv
            ras=r_sphere(i)+r_solv

            vbuf=xyz_sphere(j,:)-r_sphere(j)/d12*(xyz_sphere(j,:)-xyz_sphere(k,:))&
                 -xyz_sphere(i,:)
            dist_check_j = dot_product(vbuf,vbuf)<small
            if(dist_check_j) then
               dist_check_k = .false.
            else 
               vbuf=xyz_sphere(k,:)-r_sphere(k)/d12* &
                    (xyz_sphere(k,:)-xyz_sphere(j,:))&
                    -xyz_sphere(i,:)
               dist_check_k = dot_product(vbuf,vbuf)<small
            endif

            if(.not.dist_check_j .and. .not. dist_check_k) then
               ! case A/B formulas (18)-(21)
               drdr1=(3.0_r8_kind*r1s*(d12-r1s)-r2s*(d12-r2s)&
                    +2.0_r8_kind*r1s*r2s)/(4.0_r8_kind*d12*ras)
               drdr2=(3.0_r8_kind*r2s*(d12-r2s)-r1s*(d12-r1s)&
                    +2.0_r8_kind*r2s*r1s)/(4.0_r8_kind*d12*ras)
               drda(:)= (-d12**3+(r1s+r2s)*(r1s-r2s)**2)/&
                    (4.0_r8_kind*d12**3*ras) &
                    *(xyz_sphere(j,:)-xyz_sphere(k,:)) 
               dadr(:)=-(xyz_sphere(j,:)-xyz_sphere(k,:))/(2.0_r8_kind*d12)
               dbdadiag1= 0.5_r8_kind - (r1s-r2s)/(2.0_r8_kind*d12)
               dbdadiag2= 0.5_r8_kind + (r1s-r2s)/(2.0_r8_kind*d12)
               dbdanondiag = (r1s-r2s)/(2.0_r8_kind*d12**3)
               
               do l=1,N_moving_unique_atoms+N_pc
                  if(l <= N_moving_unique_atoms) then
                     na=moving_unique_atom_index(l)
                     ea=unique_atoms(na)%n_equal_atoms
                  else
                     na=l-N_moving_unique_atoms
                     ea=pointcharge_array(na)%N_equal_charges
                  end if
                  do l3=1,ea
                     do l1=1,3
                        help=xyz_sphere(j,l1)-xyz_sphere(k,l1) !beta_1-beta_2
                        do l2=1,3
                           cagr%dc(l1,i)%xyz_grad(:,l,l3) = &
                                cagr%dc(l1,i)%xyz_grad(:,l,l3) &
                                + dbdanondiag*help* &
                                (xyz_sphere(j,l2)-xyz_sphere(k,l2)) * &
                                cagr%dc(l2,j)%xyz_grad(:,l,l3) &
                                + dbdanondiag*help* &
                                (xyz_sphere(k,l2)-xyz_sphere(j,l2)) * &
                                cagr%dc(l2,k)%xyz_grad(:,l,l3)
                        enddo

                        cagr%dR(i)%xyz_grad(:,l,l3) = cagr%dR(i)%xyz_grad(:,l,l3) &
                             + drda(l1)*cagr%dc(l1,j)%xyz_grad(:,l,l3) &
                             - drda(l1)*cagr%dc(l1,k)%xyz_grad(:,l,l3)
                  
                        cagr%dc(l1,i)%xyz_grad(:,l,l3) = &
                             cagr%dc(l1,i)%xyz_grad(:,l,l3) &
                             + dadr(l1)*cagr%dR(j)%xyz_grad(:,l,l3) &
                             - dadr(l1)*cagr%dR(k)%xyz_grad(:,l,l3)
                     
                        cagr%dc(l1,i)%xyz_grad(:,l,l3) = &
                             cagr%dc(l1,i)%xyz_grad(:,l,l3) &
                             + dbdadiag1*cagr%dc(l1,j)%xyz_grad(:,l,l3) &
                             + dbdadiag2*cagr%dc(l1,k)%xyz_grad(:,l,l3)
		 
                     enddo
                     cagr%dR(i)%xyz_grad(:,l,l3) = cagr%dR(i)%xyz_grad(:,l,l3) + &
                          drdr1*cagr%dR(j)%xyz_grad(:,l,l3) + &
                          drdr2*cagr%dR(k)%xyz_grad(:,l,l3)
                  enddo
               enddo
            else
               ! case C
               ! test if j/k resp r1 and r2 have to been swaped !!!
               if(dist_check_k) then
                  l=k
                  k=j
                  j=l
                  help=r1s
                  r1s=r2s
                  r2s=help		
               endif

               drdr1=(2.0_r8_kind*(d12*r1s+d12*r_sphere(j)- &
                    r1s*r_sphere(j)) - r1s**2 -r2s**2 +d12**2)/ &
                    (2.0_r8_kind*d12*ras)
               drdr2= (r2s*r_sphere(j))/(d12*r_sphere(i)**2)
               drda(:) = r_sphere(j)*(-d12**2+r1s**2-r2s**2)/ &
                    (2.0_r8_kind*d12**2 * ras**2) * &
                    (xyz_sphere(j,:)-xyz_sphere(k,:))
               dadr(:)=-(xyz_sphere(j,:)-xyz_sphere(k,:))/d12
               dbdadiag2=  r_sphere(j)/d12
               dbdadiag1= 1.0_r8_kind - dbdadiag2
               dbdanondiag = r_sphere(j)/d12**3
               
               do l=1,N_moving_unique_atoms+N_pc
                  if(l <= N_moving_unique_atoms) then
                     na=moving_unique_atom_index(l)
                     ea=unique_atoms(na)%n_equal_atoms
                  else
                     na=l-N_moving_unique_atoms
                     ea=pointcharge_array(na)%N_equal_charges
                  end if
                  do l3=1,ea
                     do l1=1,3
                        help=xyz_sphere(j,l1)-xyz_sphere(k,l1) !beta_1-beta_2
                        do l2=1,3
                           cagr%dc(l1,i)%xyz_grad(:,l,l3) = &
                                cagr%dc(l1,i)%xyz_grad(:,l,l3) &
                                + dbdanondiag*help* &
                                (xyz_sphere(j,l2)-xyz_sphere(k,l2)) * &
                                cagr%dc(l2,j)%xyz_grad(:,l,l3) &
                                + dbdanondiag*help* &
                                (xyz_sphere(k,l2)-xyz_sphere(j,l2)) * &
                                cagr%dc(l2,k)%xyz_grad(:,l,l3)
                        enddo
                        
                        cagr%dR(i)%xyz_grad(:,l,l3) = cagr%dR(i)%xyz_grad(:,l,l3) &
                             + drda(l1)*cagr%dc(l1,j)%xyz_grad(:,l,l3) &
                             - drda(l1)*cagr%dc(l1,k)%xyz_grad(:,l,l3)

                        cagr%dc(l1,i)%xyz_grad(:,l,l3) = &
                             cagr%dc(l1,i)%xyz_grad(:,l,l3) &
                             + dadr(l1)*cagr%dR(j)%xyz_grad(:,l,l3) 

                        cagr%dc(l1,i)%xyz_grad(:,l,l3) = &
                             cagr%dc(l1,i)%xyz_grad(:,l,l3) &
                             + dbdadiag1*cagr%dc(l1,j)%xyz_grad(:,l,l3) &
                             + dbdadiag2*cagr%dc(l1,k)%xyz_grad(:,l,l3)
		 
                     enddo
                     cagr%dR(i)%xyz_grad(:,l,l3) = cagr%dR(i)%xyz_grad(:,l,l3) + &
                          drdr1*cagr%dR(j)%xyz_grad(:,l,l3) + &
                          drdr2*cagr%dR(k)%xyz_grad(:,l,l3)
                  enddo
               enddo
            endif
         enddo
      endif cav_f

    end subroutine calc_cavity_gradient
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine alloc_geom_deriv_part1(ca)
      !allocation of dR,dc gradients of geom_deriv ca
      type(geom_deriv) :: ca
      !** End of interface *****************************************
      
      integer(kind=i4_kind) :: i,alloc_stat,j
      integer :: N_pc

      N_pc=0
!!$      if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
      if(with_pc) N_pc=pointcharge_N

      allocate(ca%dR(N_spheres),stat=alloc_stat)
      if ( alloc_stat /= 0) call error_handler( &
           "alloc_geom_deriv_part: allocation of grad_atomic_center type  array is failed")
      allocate(ca%dc(3,N_spheres),stat=alloc_stat)
      if ( alloc_stat /= 0) call error_handler( &
           "alloc_geom_deriv_part: allocation of grad_atomic_center type  array is failed")
  
      do i=1,N_spheres
         allocate(ca%dR(i)%xyz_grad(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=alloc_stat)
         if ( alloc_stat /= 0) call error_handler( &
              "alloc_geom_deriv_part: allocation of xyz_grad is failed")
         ca%dR(i)%xyz_grad(:,:,:)=0.0_r8_kind
         do j=1,3
            allocate(ca%dc(j,i)%xyz_grad(3,N_moving_unique_atoms+N_pc,ua_dim_max),&
                 stat=alloc_stat)
            if ( alloc_stat /= 0) call error_handler( "alloc_geom_&
                 &deriv_part: allocation of xyz_grad is failed")
            ca%dc(j,i)%xyz_grad(:,:,:)=0.0_r8_kind
         enddo
      enddo

    end subroutine alloc_geom_deriv_part1
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine alloc_geom_deriv_part2(ca,n_max)
      !allocation vo dare,dcenter of geom_deriv ca
      !** End of interface *****************************************
      type(geom_deriv) :: ca
      integer(kind=i4_kind) ::n_max 

      integer(kind=i4_kind) :: i,l,alloc_stat,j,na,ea
      integer :: N_pc

      N_pc=0
!!$      if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
      if(with_pc) N_pc=pointcharge_N

      allocate(ca%darea(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=alloc_stat)
      allocate(ca%dcenter(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=alloc_stat)

      do i=1,N_moving_unique_atoms+N_pc
         do l=1,ua_dim_max
            do j=1,3
               allocate(ca%darea(j,i,l)%m(n_max),stat=alloc_stat)
               allocate(ca%dcenter(j,i,l)%m(3,n_max),stat=alloc_stat)
               ca%darea(j,i,l)%m=0.0_r8_kind
               ca%dcenter(j,i,l)%m=0.0_r8_kind
            enddo
         enddo
      enddo

    end subroutine alloc_geom_deriv_part2
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine find_max_dim_surf_elem
      !find maximal numbers of centers needed for a subdivision
      !with average areas less than max_tes_area
      !** End of interface *****************************************
      integer (kind=i4_kind) :: i,l
      real (kind=r8_kind) :: area_comp

      max_cent=0
      do i=1,N_spheres
         area_comp=4.0_r8_kind*pi*r_sphere(i)**2
!        l=int(area_comp/m_t_a,kind=i4_kind)
 	 l=ceiling(area_comp/m_t_a)
	 if(l > max_cent) max_cent=l
      enddo
DPRINT 'max cent',max_cent
    end subroutine find_max_dim_surf_elem
    !------------------------------------------------------------
!!!MF <<<<

    !------------------------------------------------------------
    subroutine generate_octahedron()
      !generate set of surface points on a sphere starting from a cube
      !and do subdivisions
      !** End of interface *****************************************

      real(kind=r8_kind),pointer :: xyz(:,:),xyz_cent(:,:)
      integer(kind=i4_kind), pointer :: indexx(:,:)
      real(kind=r8_kind) :: a,d


      real(kind=r8_kind) :: r_buf,xyz_buf(3)
      integer(kind=i4_kind) :: tang_buf(4)
      integer(kind=i4_kind) :: N_dim_xyz,N_dim_cent,N_dim_xyz_st,N_dim_cent_st
      integer(kind=i4_kind) :: N_dim_xyz_next,N_dim_cent_next
      integer(kind=i4_kind) :: i,j,k,l,m,n,l1,n1,ind,i1,status1


      a=1.0_r8_kind
      radius=a
      d=sqrt(2.0_r8_kind)*a

      N_dim_cent=8
      N_dim_cent_st=8
      N_dim_xyz=6
      N_dim_xyz_st=6

      local_point_factor=2
      if(N_atom_spheres >= MAX_ATOMS_QMMM1) local_point_factor=1

      i=1
      do
         if(i>local_point_factor-1) exit
         N_dim_xyz=N_dim_xyz+(N_dim_cent*3)/2
         N_dim_cent=N_dim_cent*4
         if(i==1) then
            N_dim_xyz_next=N_dim_xyz
            N_dim_cent_next=N_dim_cent
         endif
         i=i+1
      enddo

      allocate(surf_elem%xyz(N_dim_xyz,3),stat=status1)
      if ( status1 /= 0) call error_handler &
           ("MolMech:generate_octaahedron: allocation surf_elem%xyz is failed")

      !definition of initial set of points
      xyz=>surf_elem%xyz
      xyz=0.0_r8_kind

      xyz(1,1)=a
      xyz(2,1)=-a
      xyz(3,2)=a
      xyz(4,2)=-a
      xyz(5,3)=a
      xyz(6,3)=-a

      !definition of triangles

      allocate(surf_elem%index(N_dim_cent,3),stat=status1)
      if ( status1 /= 0) call error_handler( &
           "MolMech:generate_octahedron: allocation surf_elem%index is failed")
      indexx=>surf_elem%index

      indexx(1,1)=1
      indexx(1,2)=3
      indexx(1,3)=5

      indexx(2,1)=1
      indexx(2,2)=4
      indexx(2,3)=5

      indexx(3,1)=1
      indexx(3,2)=3
      indexx(3,3)=6

      indexx(4,1)=1
      indexx(4,2)=4
      indexx(4,3)=6

      indexx(5,1)=2
      indexx(5,2)=3
      indexx(5,3)=5

      indexx(6,1)=2
      indexx(6,2)=4
      indexx(6,3)=5

      indexx(7,1)=2
      indexx(7,2)=3
      indexx(7,3)=6

      indexx(8,1)=2
      indexx(8,2)=4
      indexx(8,3)=6

      do j=1,local_point_factor-1
#ifdef _LINUX1
         call more_triangles(N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#else
         call more_triangles(xyz,indexx,N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#endif
         N_dim_xyz_st=N_dim_xyz_next
         N_dim_cent_st=N_dim_cent_next
         N_dim_xyz_next= N_dim_xyz_st+(N_dim_cent_st*3)/2
         N_dim_cent_next= N_dim_cent_st*4
      enddo

      ! definition of triangle centers
      allocate(surf_elem%xyz_centers(N_dim_cent,3),stat=status1)
      if ( status1 /= 0) call error_handler( &
           "MolMech:generate_dodecahedron: allocation surf_elem%xyz_centers is failed")

      xyz_cent=>surf_elem%xyz_centers
      do i=1,N_dim_cent_st
         i1=indexx(i,1)
         l1=indexx(i,2)
         n1=indexx(i,3)
         xyz_buf=(xyz(i1,:)+xyz(l1,:)+xyz(n1,:))/3.0_r8_kind
         xyz_cent(i,:)=(radius/sqrt(dot_product(xyz_buf,xyz_buf)))*xyz_buf
      enddo
      N_points_of_triangles=N_dim_xyz_st
      N_centers_on_sphere=N_dim_cent_st

      if (do_cavitation .and. output_cavity_data .and. .not.do_gradients) &
           write (output_unit,'(a42,i5)') &
           'the number of triangles on each sphere is ', N_centers_on_sphere

    end subroutine generate_octahedron
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine generate_cube
      !generate set of surface points on a sphere starting from a cube
      !and do subdivisions
      !** End of interface *****************************************

      real(kind=r8_kind),pointer :: xyz(:,:),xyz_cent(:,:)
      integer(kind=i4_kind), pointer :: indexx(:,:)
      real(kind=r8_kind) :: a,d


      real(kind=r8_kind) :: r_buf,xyz_buf(3)
      integer(kind=i4_kind) :: tang_buf(4)
      integer(kind=i4_kind) :: N_dim_xyz,N_dim_cent,N_dim_xyz_st,N_dim_cent_st
!!!MF >>>>
      integer(kind=i4_kind) :: N_dim_xyz_next,N_dim_cent_next
!!!MF <<<<
      integer(kind=i4_kind) :: i,j,k,l,m,n,l1,n1,ind,i1,status1

      a=sqrt(2.0_r8_kind)/2.0_r8_kind
      radius=sqrt(1.5_r8_kind)
      d=(radius-a)**2+1.0_r8_kind

      N_dim_cent=24
      N_dim_cent_st=24
      N_dim_xyz=14
      N_dim_xyz_st=14

      if(do_correction) then
         local_point_factor=3
      else if (do_cavitation) then
         local_point_factor=0
      else
         local_point_factor=point_factor
      endif

!!!MF >>>>
      i=1
      do 
       if(i>local_point_factor .and. & 
 		(N_dim_cent>=max_cent  .or. do_cavitation) ) exit
         N_dim_xyz=N_dim_xyz+N_dim_cent*3/2
         N_dim_cent=N_dim_cent*4
	 if(i==1) then
	    N_dim_xyz_next=N_dim_xyz
	    N_dim_cent_next=N_dim_cent
	 endif
         i=i+1
      enddo
!!!MF <<<<
!     if(local_point_factor < i) local_point_factor=i-1
!     if(do_cavitation) local_point_factor=0

      allocate(surf_elem%xyz(N_dim_xyz,3),stat=status1)
      if ( status1 /= 0) call error_handler( &
           "generate_cube: allocation surf_elem%xyz is failed")

      !definition of initial set of points
      xyz=>surf_elem%xyz
      xyz=0.0_r8_kind

      xyz(1:4,1)=a
      xyz(5:8,1)=-a
      xyz(9,1)=radius
      xyz(10,1)=-radius
      xyz(11:14,1)=0.0_r8_kind

      xyz(1,2)=-a
      xyz(2,2)=a
      xyz(3,2)=-a
      xyz(4,2)=a
      xyz(5,2)=-a
      xyz(6,2)=a
      xyz(7,2)=-a
      xyz(8,2)=a
      xyz(9:10,2)=0.0_r8_kind
      xyz(11,2)=radius
      xyz(12,2)=-radius
      xyz(13:14,2)=0.0_r8_kind

      xyz(1:2,3)=a
      xyz(3:4,3)=-a
      xyz(5:6,3)=a
      xyz(7:8,3)=-a
      xyz(9:12,3)=0.0_r8_kind
      xyz(13,3)=radius
      xyz(14,3)=-radius

      !definition of triangles

      allocate(surf_elem%index(N_dim_cent,3),stat=status1)
      if ( status1 /= 0) call error_handler( &
           "generate_cube: allocation surf_elem%index is failed")
      surf_elem%index=0

      indexx=>surf_elem%index

      ind=1
      do i=1,6
         k=i+8
         m=4*(i-1)+1
         indexx(m:m+3,1)=k

         n=1
         do j=1,8
            xyz_buf=xyz(k,:)-xyz(j,:)
            r_buf=sqrt(dot_product(xyz_buf,xyz_buf))
            if (r_buf <= sqrt(d)+0.01_r8_kind) then
               tang_buf(n)=j
               n=n+1
               if (n > 4) exit
            endif

         enddo

         do l=1,3
            l1=tang_buf(l)
            do n=l+1,4
               n1=tang_buf(n)
               xyz_buf=xyz(n1,:)-xyz(l1,:)
               r_buf=sqrt(dot_product(xyz_buf,xyz_buf))
               if (r_buf <= 2*a+0.01_r8_kind) then
                  indexx(ind,2)=l1
                  indexx(ind,3)=n1
                  ind=ind+1
               endif
            enddo
         enddo
      enddo

      !dividing each triangles in four new triangles 
!!!MF >>>>
      do j=1,local_point_factor
#ifdef _LINUX1
         call more_triangles(N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#else
         call more_triangles(xyz,indexx,N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#endif
	 N_dim_xyz_st=N_dim_xyz_next
	 N_dim_cent_st=N_dim_cent_next
	 N_dim_xyz_next= N_dim_xyz_st+N_dim_cent_st*3/2
	 N_dim_cent_next= N_dim_cent_st*4
      enddo
!!!MF <<<<

DPRINT 'maximum allowd centers',N_dim_cent
      ! definition of triangle centers
      allocate(surf_elem%xyz_centers(N_dim_cent,3),stat=status1)
      if ( status1 /= 0) call error_handler( &
           "generate_dodecahedron: allocation surf_elem%xyz_centers is failed")

      xyz_cent=>surf_elem%xyz_centers
      do i=1,N_dim_cent_st
         i1=indexx(i,1)
         l1=indexx(i,2)
         n1=indexx(i,3)
         xyz_buf=(xyz(i1,:)+xyz(l1,:)+xyz(n1,:))/3.0_r8_kind
         xyz_cent(i,:)=(radius/sqrt(dot_product(xyz_buf,xyz_buf)))*xyz_buf
      enddo

      N_points_of_triangles=N_dim_xyz_st
      N_centers_on_sphere=N_dim_cent_st

      if (do_cavitation .and. output_cavity_data .and. .not.do_gradients) &
           write (output_unit,'(a42,i5)') 'the number of triangles on each sphere is', N_centers_on_sphere
!     nullify(xyz,xyz_cent,index)
    end subroutine generate_cube
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine generate_dodecahedron(gp93)
      !generate points due to a pentakis-dodecahedron
      !rotate in right symmetry
      !subdivide if needed
      !** End of interface *****************************************

      integer(kind=i4_kind), intent(in) :: gp93
      real(kind=r8_kind),pointer :: xyz(:,:),xyz_cent(:,:)
      integer(kind=i4_kind), pointer :: indexx(:,:)
      real(kind=r8_kind) :: x,y,z
      real(kind=r8_kind) :: t,s,h,r,b,c1,c2,h1,h2,rr,cosT,sinT

      real(kind=r8_kind) :: r_buf,xyz_buf(3)
      integer(kind=i4_kind) :: tang_buf(5)
      integer(kind=i4_kind) :: N_dim_xyz,N_dim_cent,N_dim_xyz_st,N_dim_cent_st
!!!MF >>>>
      integer(kind=i4_kind) :: N_dim_xyz_next,N_dim_cent_next
!!!MF <<<<
!!!MF 12.4.2000 little rotations for D3 and D5 cos/sin of 2 pi/12 or 2 pi/20 >>>>
      real(kind=r8_kind), parameter :: cos12=0.8660254037844_r8_kind
      real(kind=r8_kind), parameter :: sin12=0.5_r8_kind
      real(kind=r8_kind), parameter :: cos20=0.9510565162952_r8_kind
      real(kind=r8_kind), parameter :: sin20=0.3090169943749_r8_kind
!!!MF <<<<
      integer(kind=i4_kind) :: i,j,k,l,m,n,l1,n1,ind,i1,status2

      !definition a pentakis dodecahedron 
      t=(sqrt(5.0_r8_kind)+1.0_r8_kind)/2.0_r8_kind
      s=sqrt(3.0_r8_kind-t)/2.0_r8_kind      
      h=(2.0_r8_kind*s+(t+1.0_r8_kind)*sqrt(t+2.0_r8_kind))/4.0_r8_kind
      radius=sqrt(h**2+s**2)
      b=radius*sqrt(3.0_r8_kind)/3.0_r8_kind
      c1=(2.0_r8_kind*b+h)/5.0_r8_kind
      c2=(2.0_r8_kind*h+2.0_r8_kind*b+s)/5.0_r8_kind
      rr=sqrt(c1**2+c2**2)
      h1=c1*radius/rr
      h2=c2*radius/rr
      cosT=h2/sqrt(h1**2+h2**2)
      sinT=sqrt(1.0_r8_kind-cosT**2)
      r=sqrt(radius**2-1.0_r8_kind)

      N_dim_cent=60
      N_dim_cent_st=60
      N_dim_xyz=32
      N_dim_xyz_st=32

      if(do_correction) then
         local_point_factor=3
      else if (do_cavitation) then
         local_point_factor=1
      else
         local_point_factor=point_factor
      endif

      if(gp93==1) then 
         local_point_factor=NDIV
         i=1
         do 
            if(i >local_point_factor-1) exit
            N_dim_xyz=N_dim_xyz+(N_dim_cent*3)/2
            N_dim_cent=N_dim_cent*4
            if(i==1) then
               N_dim_xyz_next=N_dim_xyz
               N_dim_cent_next=N_dim_cent
            endif
            i=i+1
         end do
      else
         i=1
         do 
            if(i>local_point_factor-1 .and. & 
                 (N_dim_cent>=max_cent .or. do_cavitation) ) exit
            N_dim_xyz=N_dim_xyz+(N_dim_cent*3)/2
            N_dim_cent=N_dim_cent*4
            if(i==1) then
               N_dim_xyz_next=N_dim_xyz
               N_dim_cent_next=N_dim_cent
            endif
            i=i+1
         enddo
      end if
!!!MF <<<<
!     if(local_point_factor-1 < i) local_point_factor=i
!     if(do_cavitation) local_point_factor=1
DPRINT 'maximum allowd centers',N_dim_cent

      allocate(surf_elem%xyz(N_dim_xyz,3),stat=status2)
      if ( status2 /= 0) call error_handler &
           ("generate_dodecahedron: allocation surf_elem%xyz is failed")

      !definition of initial set of points
      xyz=>surf_elem%xyz
      xyz=0.0_r8_kind

      xyz(1:4,1)=0.0_r8_kind
      xyz(5,1)=s
      xyz(7,1)=s
      xyz(6,1)=-s
      xyz(8,1)=-s
      xyz(9:10,1)=h
      xyz(11:12,1)=-h
      xyz(13,1)=b 
      xyz(15,1)=b 
      xyz(17,1)=b 
      xyz(19,1)=b 
      xyz(14,1)=-b
      xyz(16,1)=-b
      xyz(18,1)=-b
      xyz(20,1)=-b
      xyz(21,1)=h1
      xyz(22,1)=-h1
      xyz(23,1)=h1
      xyz(24,1)=-h1 
      xyz(25:29,1)=0.0_r8_kind
      xyz(29:30,1)=h2 
      xyz(31:32,1)=-h2

      xyz(1,2)=-s
      xyz(3,2)=-s
      xyz(2,2)=s
      xyz(4,2)=s
      xyz(5:6,2)=h
      xyz(7:8,2)=-h
      xyz(9:12,2)=0.0_r8_kind
      xyz(13:14,2)=b
      xyz(17:18,2)=b 
      xyz(15:16,2)=-b 
      xyz(19:20,2)=-b
      xyz(21:24,2)=0.0_r8_kind
      xyz(25,2)=-h2 
      xyz(26:27,2)=h2 
      xyz(28,2)=-h2  
      xyz(29,2)=-h1 
      xyz(30,2)=h1
      xyz(31,2)=-h1 
      xyz(32,2)=h1 

      xyz(1:2,3)=h
      xyz(3:4,3)=-h
      xyz(5:8,3)=0.0_r8_kind
      xyz(9,3)=s
      xyz(11,3)=s
      xyz(10,3)=-s
      xyz(12,3)=-s
      xyz(13:16,3)=b 
      xyz(17:20,3)=-b 
      xyz(21:22,3)=h2 
      xyz(23:24,3)=-h2 
      xyz(25:26,3)=h1  
      xyz(27:28,3)=-h1  
      xyz(29:32,3)=0.0_r8_kind

      !definition of triangles

      allocate(surf_elem%index(N_dim_cent,3),stat=status2)
      if ( status2 /= 0) call error_handler( &
           "generate_dodecahedron: allocation surf_elem%index is failed")
      indexx=>surf_elem%index
      ind=1
      do i=1,12
         k=i+20
         m=5*(i-1)+1
         indexx(m:m+4,1)=k

         n=1
         do j=1,20
            xyz_buf=xyz(k,:)-xyz(j,:)
            r_buf=sqrt(dot_product(xyz_buf,xyz_buf))
            if (r_buf <= 1.06_r8_kind) then
               tang_buf(n)=j
               n=n+1
               if (n > 5) exit
            endif

         enddo

         do l=1,4
            l1=tang_buf(l)
            do n=l+1,5
               n1=tang_buf(n)
               xyz_buf=xyz(n1,:)-xyz(l1,:)
               r_buf=sqrt(dot_product(xyz_buf,xyz_buf))
               if (r_buf <= 2.0_r8_kind*s+0.001_r8_kind) then
                  indexx(ind,2)=l1
                  indexx(ind,3)=n1
                  ind=ind+1
               endif
            enddo
         enddo
      enddo

      ! orientation of points respect to symmetry point group
      if ( (name_point_group=='C1  ') .or. &
           (name_point_group=='C2  ') .or. &
           (name_point_group=='CS  ') .or. &
           (name_point_group=='C2V ') .or. &
           (name_point_group=='C2H ') .or. &
           (name_point_group=='I   ') .or. &
           (name_point_group=='IH  ') .or. &
           (name_point_group=='CI  ')  .or. &
           (name_point_group=='D2  ')  .or. &
           (name_point_group=='D2H ') ) then
      endif
      if ( (name_point_group=='C3  ') .or. &
           (name_point_group=='C3V ') .or. &
           (name_point_group=='D3  ')  .or. &
           (name_point_group=='D3D ')  .or. &
           (name_point_group=='S6  ')  ) then
         do i=1,N_dim_xyz_st
            x=xyz(i,1)*s/radius+xyz(i,3)*h/radius
            z=-xyz(i,1)*h/radius+xyz(i,3)*s/radius
            xyz(i,1)=x
            xyz(i,3)=z 
         enddo
         if ((name_point_group=='D3  ')  .or. &
             (name_point_group=='D3D ') ) then
            do i=1,N_dim_xyz_st
               x=cos12*xyz(i,1)-sin12*xyz(i,2)
               y=sin12*xyz(i,1)+cos12*xyz(i,2)
               xyz(i,1)=x
               xyz(i,2)=y 
            enddo
         end if
      endif
      if ( (name_point_group=='C5  ') .or. &
           (name_point_group=='C5V ') .or. &
           (name_point_group=='S10 ')  .or. &
           (name_point_group=='D5  ')  .or. &
           (name_point_group=='D5D ')  .or. &
           (name_point_group=='D5H ') ) then
         do i=1,N_dim_xyz_st
            x=xyz(i,1)*cosT+xyz(i,3)*sinT
            z=-xyz(i,1)*sinT+xyz(i,3)*cosT
            xyz(i,1)=x
            xyz(i,3)=z
         enddo
         if ((name_point_group=='D5  ') .or. &
             (name_point_group=='D5D '))  then
            do i=1,N_dim_xyz_st
               x=cos20*xyz(i,1)-sin20*xyz(i,2)
               y=sin20*xyz(i,1)+cos20*xyz(i,2)
               xyz(i,1)=x
               xyz(i,2)=y 
            enddo
         endif
!!!MF <<<<
      endif

!!!MF >>>>
      do j=1,local_point_factor-1
!!!MF allow mor than 1x subdivision
#ifdef _LINUX1
         call more_triangles(N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#else
         call more_triangles(xyz,indexx,N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#endif
	 N_dim_xyz_st=N_dim_xyz_next
	 N_dim_cent_st=N_dim_cent_next
	 N_dim_xyz_next= N_dim_xyz_st+(N_dim_cent_st*3)/2
	 N_dim_cent_next= N_dim_cent_st*4
      enddo
!!!MF <<<<

      ! definition of triangle centers
      allocate(surf_elem%xyz_centers(N_dim_cent,3),stat=status2)
      if ( status2 /= 0) call error_handler( &
           "generate_dodecahedron: allocation surf_elem%xyz_centers is failed")

      xyz_cent=>surf_elem%xyz_centers
      do i=1,N_dim_cent_st !!!!!!!!N_dim_cent
         i1=indexx(i,1)
         l1=indexx(i,2)
         n1=indexx(i,3)
         xyz_buf=(xyz(i1,:)+xyz(l1,:)+xyz(n1,:))/3.0_r8_kind
         xyz_cent(i,:)=(radius/sqrt(dot_product(xyz_buf,xyz_buf)))*xyz_buf
      enddo
      N_points_of_triangles=N_dim_xyz_st !!!!!!N_dim_xyz
      N_centers_on_sphere=N_dim_cent_st  !!!!!!N_dim_cent
      if(do_cavitation .and. output_cavity_data .and. .not.do_gradients) &
           write (output_unit,'(a42,i5)') 'the number of triangles on each sphere is ', N_centers_on_sphere

!!$     nullify(xyz,xyz_cent,index)
    end subroutine generate_dodecahedron
    !------------------------------------------------------------

    !------------------------------------------------------------
!!!MF >>>>
    subroutine generate_doublepyramide(n_rotations)
    !!! simple extension for all other point groups,
    !!! not very well suited, because surface areas my be
    !!! very acute angled triangles
   !** End of interface *****************************************
      real(kind=r8_kind),pointer :: xyz(:,:),xyz_cent(:,:)
      integer(kind=i4_kind), pointer :: indexx(:,:)

      real(kind=r8_kind) :: xyz_buf(3)
      integer(kind=i4_kind) :: N_dim_xyz,N_dim_cent,N_dim_xyz_st,N_dim_cent_st
      integer(kind=i4_kind) :: N_dim_xyz_next,N_dim_cent_next
      integer(kind=i4_kind) :: i,j,l1,n1,i1,status3
      integer(kind=i4_kind) :: n_rotations
      real(kind=r8_kind) :: alph, r_n_rot
      real(kind=r8_kind) , parameter :: pi = 3.14159265355897932368_r8_kind

      radius=1.0_r8_kind 


      N_dim_cent=2*n_rotations
      N_dim_cent_st=2*n_rotations
      N_dim_xyz=n_rotations+2
      N_dim_xyz_st=n_rotations+2

      ! at least one subdivision
      if(do_correction) then
         if(n_rotations == 3) then
            local_point_factor=5
         else
            local_point_factor=4
         endif
      else
         local_point_factor=point_factor+1 !2 is too much !!!!!
      endif

      i=1
      do 
       if(i>local_point_factor .and. & 
		(N_dim_cent>=max_cent .or. do_cavitation) ) exit
         N_dim_xyz=N_dim_xyz+N_dim_cent*3/2
         N_dim_cent=N_dim_cent*4
	 if(i==1) then
	    N_dim_xyz_next=N_dim_xyz
	    N_dim_cent_next=N_dim_cent
	 endif
         i=i+1
      enddo
DPRINT 'maximum allowd centers',N_dim_cent
!!!AS >>>>
!     if(local_point_factor < i) local_point_factor=i-1
!     if(do_cavitation) local_point_factor=0
!!!AS <<<<

      allocate(surf_elem%xyz(N_dim_xyz,3),stat=status3)
      if ( status3 /= 0) call error_handler( &
           "generate_doublepyramide: allocation surf_elem%xyz is failed")

      !definition of initial set of points
      xyz=>surf_elem%xyz
      xyz=0.0_r8_kind

      xyz(1,1:2)=0.0_r8_kind
      xyz(1,3)=radius
      xyz(N_dim_xyz_st,1:2)=0.0_r8_kind
      xyz(N_dim_xyz_st,3)=-radius
      xyz(2:N_dim_xyz_st-1,3)=0.0_r8_kind

      r_n_rot=real(n_rotations,kind=r8_kind)
      do i=0,n_rotations-1
        alph = (real(i,kind=r8_kind))/r_n_rot * 2.0_r8_kind * pi 
	xyz(i+2,1)=cos(alph)
        xyz(i+2,2)=sin(alph)
      enddo

      allocate(surf_elem%index(N_dim_cent,3),stat=status3)
      if ( status3 /= 0) call error_handler( &
           "generate_doublepyramide: allocation surf_elem%index is failed")
      surf_elem%index=0

      indexx=>surf_elem%index
      
      do i=1,n_rotations
        indexx(i,1)=i+1
        indexx(i,2)=i+2
        indexx(i,3)=1
        indexx(n_rotations+i,1)=i+1
        indexx(n_rotations+i,2)=i+2
        indexx(n_rotations+i,3)=N_dim_xyz_st
      enddo
      indexx(n_rotations,2)=2
      indexx(N_dim_cent_st,2)=2


      !dividing each triangles in four new triangles 
      do j=1,local_point_factor
!!!MF allow mor than 1x subdivision
#ifdef _LINUX1
         call more_triangles(N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#else
         call more_triangles(xyz,indexx,N_dim_cent_next,N_dim_xyz_st,N_dim_cent_st)
#endif
	 N_dim_xyz_st=N_dim_xyz_next
	 N_dim_cent_st=N_dim_cent_next
	 N_dim_xyz_next= N_dim_xyz_st+N_dim_cent_st*3/2
	 N_dim_cent_next= N_dim_cent_st*4
      enddo


      ! definition of triangle centers
      allocate(surf_elem%xyz_centers(N_dim_cent,3),stat=status3)
      if ( status3 /= 0) call error_handler( &
           "generate_ddoublepyr: allocation surf_elem%xyz_centers is failed")

      xyz_cent=>surf_elem%xyz_centers
      do i=1,N_dim_cent_st
         i1=indexx(i,1)
         l1=indexx(i,2)
         n1=indexx(i,3)
         xyz_buf=(xyz(i1,:)+xyz(l1,:)+xyz(n1,:))/3.0_r8_kind
         xyz_cent(i,:)=(radius/sqrt(dot_product(xyz_buf,xyz_buf)))*xyz_buf
      enddo

      N_points_of_triangles=N_dim_xyz_st
      N_centers_on_sphere=N_dim_cent_st

      if(do_cavitation .and. output_cavity_data .and. .not.do_gradients) &
           write (output_unit,'(a42,i5)') 'the number of triangles on each sphere is ', N_centers_on_sphere

!     nullify(xyz,xyz_cent,index)
    end subroutine generate_doublepyramide
!!!MF <<<<
    !------------------------------------------------------------

    !------------------------------------------------------------
#ifdef _LINUX1
    subroutine more_triangles(n_ind,n_xyz_st,n_ind_st)
#else
    subroutine more_triangles(xyz_t,ind_t,n_ind,n_xyz_st,n_ind_st)
#endif
      !subdivision routine, each triangle is devided in four by
      !halving the edges
      !** End of interface *****************************************

      real(kind=r8_kind), pointer :: xyz_t(:,:)
      integer(kind=i4_kind), pointer :: ind_t(:,:)
      integer(kind=i4_kind), intent(in) :: n_ind
      integer(kind=i4_kind), intent(inout) :: n_xyz_st,n_ind_st

      real(kind=r8_kind) :: xyz_t_buf(3),xyz_tt(3)
      integer(kind=i4_kind), allocatable :: ind_buf(:,:)
      integer(kind=i4_kind) :: new_numbers(6)
      integer(kind=i4_kind) :: status,next_i,neighbour,i1,i2
      integer(kind=i4_kind) :: i,j,k,l,m,m1,n,n1
      real(kind=r8_kind), parameter :: small=1.0e-11_r8_kind

#ifdef _LINUX1
      xyz_t=>surf_elem%xyz
      ind_t=>surf_elem%index
#endif

      allocate(ind_buf(n_ind,3),stat=status)
      if ( status /= 0) call error_handler( &
           "more_triangles: allocation ind_buf is failed")
      ind_buf=0


      next_i=0
      label_i: do i=1,n_ind_st

         m=0
         label_j: do j=1,3
            next_i=next_i+1
            neighbour=1
            i1=ind_t(i,j)
            ind_buf(next_i,neighbour)=i1

            label_k: do k=1,3
               if (k==j) cycle label_k
               i2=ind_t(i,k)
               xyz_t_buf=(xyz_t(i1,:)+xyz_t(i2,:))/2.0_r8_kind
               xyz_tt=(radius/sqrt(dot_product(xyz_t_buf,xyz_t_buf)))*xyz_t_buf

               label_l: do l=1,n_xyz_st

!!$                  if(xyz_tt(1)==xyz_t(l,1) .and. &
!!$                       xyz_tt(2)==xyz_t(l,2) .and. &
!!$                       xyz_tt(3)==xyz_t(l,3)) then
                  if(abs(xyz_tt(1)-xyz_t(l,1))<small .and. &
                       abs(xyz_tt(2)-xyz_t(l,2))<small .and. &
                       abs(xyz_tt(3)-xyz_t(l,3))<small) then
                     neighbour=neighbour+1
                     ind_buf(next_i,neighbour)=l
                     m=m+1
                     new_numbers(m)=l
                     cycle label_k
                  endif
               enddo label_l
               n_xyz_st=n_xyz_st+1
               xyz_t(n_xyz_st,:)=xyz_tt
               neighbour=neighbour+1
               ind_buf(next_i,neighbour)=n_xyz_st
               m=m+1
               new_numbers(m)=n_xyz_st
            enddo label_k
         enddo label_j
         next_i=next_i+1
         m1=1
         ind_buf(next_i,m1)=new_numbers(1)
         label_n: do n=2,m

            label_n1: do n1=1,n-1
               if(new_numbers(n) == new_numbers(n1)) cycle label_n
            enddo label_n1
            m1=m1+1
            ind_buf(next_i,m1)=new_numbers(n)
            if (m1==3) cycle label_i
         enddo label_n
      enddo label_i

      n_ind_st=next_i
      ind_t(1:n_ind,1:3)=ind_buf(1:n_ind,1:3)

      deallocate(ind_buf,stat=status)
      if ( status /= 0) call error_handler( &
           "more_triangles: deallocation ind_buf is failed")
!     nullify(xyz_t,ind_t)
    end subroutine more_triangles
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine tesselation
      !creates points on each sphere
      !calls def_poligon_tesselation ("cutting routine")
      !stores resulting surface tesselation in data_tes
      !** End of interface *****************************************

      type(triangles), allocatable :: triangles_on_sphere(:)
      type(poligon) :: tes_temp
      integer(i4_kind), allocatable :: int_sec_spheres(:)
      real(kind=r8_kind) :: xyz_pol_c(3),area_pol,area_tot
      integer(kind=i4_kind) :: status,i,j,k,l,i1,j1,k1,l1
      integer(kind=i4_kind), allocatable :: i_sorted_spheres(:),N_cent_loc(:)
      integer(kind=i4_kind) :: ihelp,N_new_cent,N_new_xyz,n_int_sec_spheres
      real(kind=r8_kind) :: area_comp,xyz_buf(3)

      allocate(i_sorted_spheres(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of i_sorted_spheres is failed")
      allocate(N_cent_loc(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of N_cent_loc is failed")

      i_sorted_spheres(1)=1
      do i=2,N_spheres
         i_sorted_spheres(i)=i
         labj: do j=1,i-1
            if(r_sphere(i)<r_sphere(i_sorted_spheres(j))) then
               do k=i-1,j,-1
                  i_sorted_spheres(k+1)=i_sorted_spheres(k) 
               enddo
               i_sorted_spheres(j)=i
               exit  labj
            endif
         enddo labj
      enddo

      allocate(triangles_on_sphere(N_spheres), stat=status)
      if ( status /= 0) call error_handler( &
           "tesselation: allocation of triangles_on_sphere is failed")

      !projecting set of points of arbitrary sphere on each sphere forming the cavity
      labisorted: do ihelp=1,N_spheres
         i=i_sorted_spheres(ihelp)
         
	 if(.not. do_cavitation) then
!!$            if(do_disp_rep .or. .not.with_pc) then
            if(.not.with_pc .or. (i_poly /= 1)) then
            area_comp=4.0_r8_kind*pi*r_sphere(i)**2         
            local_point_factor=ceiling(log(&
		 area_comp/(N_centers_on_sphere*m_t_a))/log(4.0_r8_kind))
            do k=1,local_point_factor
               N_new_xyz=N_points_of_triangles+N_centers_on_sphere*3/2
               N_new_cent=N_centers_on_sphere*4
#ifdef _LINUX1
               call more_triangles(N_new_cent,N_points_of_triangles,&
			N_centers_on_sphere)
#else
               call more_triangles(surf_elem%xyz,surf_elem%index,&
                    N_new_cent,N_points_of_triangles,N_centers_on_sphere)
#endif
               N_centers_on_sphere=N_new_cent
               N_points_of_triangles=N_new_xyz
            end do
            end if
            if(output_cavity_data .and. .not.do_gradients) &
                 write (output_unit,'(a27,i3,a11,i5)') &
                 'the number of triangles on ',i,' sphere is ', N_centers_on_sphere
         endif

         N_cent_loc(i)=N_centers_on_sphere
         do k=1,N_centers_on_sphere
            i1=surf_elem%index(k,1)
            l1=surf_elem%index(k,2)
            k1=surf_elem%index(k,3)
            xyz_buf=(surf_elem%xyz(i1,:)+surf_elem%xyz(l1,:)+surf_elem%xyz(k1,:))/3.0_r8_kind
            surf_elem%xyz_centers(k,:)=(radius/sqrt(dot_product(xyz_buf,xyz_buf)))*xyz_buf
         enddo
         allocate(triangles_on_sphere(i)%xyz(N_points_of_triangles,3), &
              triangles_on_sphere(i)%index(N_centers_on_sphere,3), &
              triangles_on_sphere(i)%xyz_centers(N_centers_on_sphere,3), &
              stat=status)
         if ( status /= 0) then 
            call error_handler( &
                 "tesselation: allocation of triangles_on_sphere(1) is failed")
         endif
         do j=1,N_points_of_triangles
            triangles_on_sphere(i)%xyz(j,:)= surf_elem%xyz(j,:)*r_sphere(i)/radius+ &
                 xyz_sphere(i,:)
         enddo
         triangles_on_sphere(i)%index(1:N_centers_on_sphere,:)= &
              surf_elem%index(1:N_centers_on_sphere,:)
         do k=1,N_centers_on_sphere
            triangles_on_sphere(i)%xyz_centers(k,:)= surf_elem%xyz_centers(k,:)*r_sphere(i)/radius+ &
                 xyz_sphere(i,:)
         enddo
         triangles_on_sphere(i)%radius=r_sphere(i)
!        triangles_on_sphere(i)%area=(4.0_r8_kind*pi*r_sphere(i)**2)/N_centers_on_sphere
         triangles_on_sphere(i)%area=0.0_r8_kind
! 	if(i.eq.1) print*,'lab ed',r_sphere(i),triangles_on_sphere(1)%xyz_centers(3,:)
! 	if(i.eq.1) print*,triangles_on_sphere(1)%index(3,:)
      enddo labisorted

!!! MF: why not?!
!     deallocate(i_sorted_spheres, stat=status)
      deallocate(i_sorted_spheres,surf_elem%xyz_centers,surf_elem%xyz,surf_elem%index, stat=status)
      if ( status /= 0) call error_handler( &
           "tesselation: deallocation of i_sorted_spheres is failed")

      allocate(xyz_tes_c(N_spheres*N_centers_on_sphere,3), &
           area_tes(N_spheres*N_centers_on_sphere), &
           r_tes(N_spheres*N_centers_on_sphere), &
           sphere(N_spheres*N_centers_on_sphere), &
           cuttt(N_spheres*N_centers_on_sphere), &
           data_tes(N_spheres*N_centers_on_sphere),stat=status)
      if ( status /= 0) call error_handler( &
           "tesselation: allocation of xyz_tes_c, area_tes, r_tes are failed")

!!! MF 5/2000 gradients
      if(do_gradients) then
	call alloc_geom_deriv_part2(cagr,N_spheres*N_centers_on_sphere)
      endif

      allocate(int_sec_spheres(N_spheres),stat=status)
      if ( status /= 0) call error_handler( &
           "tesselation: failed int_sec_spheres allocation")
      !definition of the cavity elements
      area_tot=0.0_r8_kind
      N_total=0
      lab1: do i=1,N_spheres
         if(.not. do_cavitation .and. .not. do_disp_rep) then
            if(gepol == 93) then
               if(zero_area(i)) cycle lab1
            end if
         end if

         call calc_intersect_spheres(i,xyz_sphere,r_sphere,N_spheres, &
              n_int_sec_spheres,int_sec_spheres)

         lab2: do j=1,N_cent_loc(i)
           j1=triangles_on_sphere(i)%index(j,1)
           k1=triangles_on_sphere(i)%index(j,2)
           l1=triangles_on_sphere(i)%index(j,3)

           if(if_tess_inside_cav(triangles_on_sphere(i)%xyz(j1,:), &
                triangles_on_sphere(i)%xyz(k1,:), &
                triangles_on_sphere(i)%xyz(l1,:), &
                i,N_cent_loc(i),xyz_sphere,r_sphere,N_spheres, &
                n_int_sec_spheres,int_sec_spheres)) then 
              cycle lab2
           endif

! 	if(i.eq.1.and.j.eq.3) print*
! 	if(i.eq.1.and.j.eq.3) print*,triangles_on_sphere(i)%xyz(j1,:)
! 	if(i.eq.1.and.j.eq.3) print*,triangles_on_sphere(i)%xyz(k1,:)
! 	if(i.eq.1.and.j.eq.3) print*,triangles_on_sphere(i)%xyz(l1,:)
! 
           call def_poligon_tes(i, &
                          triangles_on_sphere(i)%xyz(j1,:), &
                          triangles_on_sphere(i)%xyz(k1,:), &
                          triangles_on_sphere(i)%xyz(l1,:), &
                          xyz_pol_c,area_pol,tes_temp)

           if(area_pol /= 0.0_r8_kind) then
! 	   if(N_total.eq.2) print*,'def pol tes',j1,k1,l1,i,j
                  N_total=N_total+1
                  xyz_tes_c(N_total,:)=xyz_pol_c
                  area_tes(N_total)=area_pol
                  area_tot=area_tot+area_tes(N_total)
                  r_tes(N_total)=triangles_on_sphere(i)%radius
                  sphere(N_total)=i

		  
                  cuttt(N_total)=.false.
		  do l=1,tes_temp%n_vertises
			if(tes_temp%n_sphere(l,1)/=0) cuttt(N_total) = .true.
		  enddo

                  data_tes(N_total)=tes_temp
	   endif
         enddo lab2
      enddo lab1

      if(output_cavity_data .and. .not.do_gradients) then
         write(output_unit,*) '-------------------------------------------------------------'
         write(output_unit,'(i5,a27)') N_total,' points have been generated'
         write(output_unit,'(f18.9,a27)') area_tot,' a_o^2 total surface area  '
         if(output_cavity_long) then
           write(output_unit,*)'number                   coordinates(a.u.)               area      n_vertises'
           do i=1,N_total
            write(output_unit,'(1x,i4,3x,3(1x,f13.9),1x,f14.9,1x,i3)') i,xyz_tes_c(i,:), &
                 area_tes(i),data_tes(i)%n_vertises
!!$            do j=1,data_tes(i)%n_vertises
!!$               write(output_unit,*) data_tes(i)%xyz_vertex(j,:)
!!$            end do
           enddo
         endif
         write(output_unit,*) '-------------------------------------------------------------'
      endif
! 	print*, 'ter ter' ,2, xyz_tes_c(2,:)
 
      do i=1,N_spheres
         deallocate(triangles_on_sphere(i)%xyz, &
              triangles_on_sphere(i)%index, &
              triangles_on_sphere(i)%xyz_centers, &
              stat=status)
         if ( status /= 0) then 
            call error_handler( &
                 "tesselation: deallocation of triangles_on_sphere(1) is failed")
         endif

      enddo
      deallocate(triangles_on_sphere,stat=status)
      if ( status /= 0) call error_handler( &
         "tesselation: deallocation of triangles_on_sphere(2) is failed")

      deallocate(N_cent_loc,cut_rad_sort, stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: deallocation of N_cent_loc is failed")

      deallocate(int_sec_spheres,stat=status)
      if ( status /= 0) call error_handler( &
           "tesselation: failed int_sec_spheres deallocation")

      if(do_gradients .and. .not. do_disp_rep) then
         call dealloc_geom_deriv_part1(cagr)
      endif

    end subroutine tesselation
    !------------------------------------------------------------
    !------------------------------------------------------------
    subroutine init_cut_rad_sort()
      integer(kind=i4_kind) :: i,j,status,k,l
      real (kind=r8_kind),allocatable :: rcut(:)
      real (kind=r8_kind) :: help,vd(3)

      allocate(cut_rad_sort(N_spheres,N_spheres),rcut(N_spheres),stat=status)
      if(status/=0) call error_handler("alloc of cut_rad_sort failed")
      cut_rad_sort=0
      
      do i=1,N_spheres
! 	print*,xyz_sphere(i,:),i,'xyz_sphere'
         rcut=-1.0_r8_kind
         labj : do j=1,N_spheres
            if(i==j) cycle labj
            vd(:)=xyz_sphere(j,:)-xyz_sphere(i,:)
	    help=sqrt(dot_product(vd,vd))
            if (r_sphere(i)+r_sphere(j) < help) cycle 
	    help=(help**2+r_sphere(i)**2-r_sphere(j)**2)/&
				(2.0_r8_kind*help)
	    help=r_sphere(i)**2-help**2
	    if(help<0.0_r8_kind) help=0.0_r8_kind
            rcut(j)=sqrt(help)
         enddo labj

         do j=1,N_spheres
            cut_rad_sort(i,j)=j
            labk: do k=1,j-1
               if(rcut(cut_rad_sort(i,j))>rcut(cut_rad_sort(i,k))) then
                  do l=j-1,k,-1
                     cut_rad_sort(i,l+1)=cut_rad_sort(i,l) 
                  enddo
                  cut_rad_sort(i,k)=j
                  exit  labk
               endif
            enddo labk
         enddo
      enddo
! 	print*,sum(abs(rcut)),'rcut sum abs',sum(abs(xyz_sphere(1:N_spheres,:))),sum(r_sphere(1:N_spheres))
   
      deallocate(rcut)
    end subroutine init_cut_rad_sort
    !------------------------------------------------------------
    !------------------------------------------------------------
    subroutine def_poligon_tes(sphere_number, &
         xyz_triangl_1,xyz_triangl_2,xyz_triangl_3, &
         xyz_poligon_centre,poligon_area,poli)
      ! This is very important procedure calculating area and coordinates
      ! of geometrical center of tessarea of polygonal shape. 
      ! The polygonal type of tessarea is formed as result of intersection
      ! between two or some spheres.
      !** End of interface *****************************************
      integer(kind=i4_kind), intent(in) :: sphere_number
      real(kind=r8_kind), intent(in) :: xyz_triangl_1(3), xyz_triangl_2(3), xyz_triangl_3(3)
      real(kind=r8_kind), intent(out) :: xyz_poligon_centre(3), poligon_area
      type(poligon), intent(out) :: poli

      real(kind=r8_kind) :: new_vertex(6)
      real(kind=r8_kind) :: alpha, beta, cos_gamma,v1(3),v2(3),v_buf(3)
      logical :: combination(MAX_POL_VER,MAX_POL_VER)
      logical :: inside_flag(MAX_POL_VER),cutted
      real(kind=r8_kind) :: d_rad,d_rad1,d_vv
      real(kind=r8_kind), parameter :: small_d=1.0e-8_r8_kind

      integer(kind=i4_kind) :: ncut,k_new,l1,l2,n_extra
      integer(kind=i4_kind) :: i,i1,ii,j,k,jh,k1
      real(kind=r8_kind) :: tn(MAX_POL_VER,3),tns(MAX_POL_VER,3),vn(MAX_POL_VER,3),vns(MAX_POL_VER,3)
      logical :: extra_point(MAX_POL_VER),h_case(MAX_POL_VER,2),h_case_sphere
      real(kind=r8_kind), dimension(MAX_POL_VER) :: costhn,phin
      real(kind=r8_kind) :: cut_center(3),cut_radius,help,tanphi2,center_factor
      integer(kind=i4_kind) :: is(MAX_POL_VER),num_v(MAX_POL_VER),n_tes_part,max_tes_part

      character*54 :: message

      tn=0.0_r8_kind
      tns=0.0_r8_kind
      vn=0.0_r8_kind
      vns=0.0_r8_kind

      poli%xyz_vertex=0.0_r8_kind
      poli%bounds=0
      poli%r_bound=0.0_r8_kind
      poli%xyz_bound=0.0_r8_kind
      poli%n_sphere=0

      counter_n=counter_n+1

      poli%n_vertises=3

      poli%xyz_vertex(1,:)=xyz_triangl_1
      poli%xyz_vertex(2,:)=xyz_triangl_2
      poli%xyz_vertex(3,:)=xyz_triangl_3

      ! ensure anticlockwise sort
      v_buf=vector_product(xyz_triangl_1-xyz_sphere(sphere_number,:),&
	xyz_triangl_2-xyz_sphere(sphere_number,:))

      if(dot_product(v_buf,xyz_triangl_3-xyz_sphere(sphere_number,:))&
						<0.0_r8_kind) then
      	poli%xyz_vertex(2,:)=xyz_triangl_3
      	poli%xyz_vertex(3,:)=xyz_triangl_2
      endif

      poli%bounds(1,1)=2
      poli%bounds(1,2)=3
      poli%bounds(2,1)=3
      poli%bounds(2,2)=1
      poli%bounds(3,1)=1
      poli%bounds(3,2)=2

      poli%r_bound(1:3,:)=r_sphere(sphere_number)

      poli%xyz_bound(1,1:3)=xyz_sphere(sphere_number,:)
      poli%xyz_bound(2,1:3)=xyz_sphere(sphere_number,:)
      poli%xyz_bound(3,1:3)=xyz_sphere(sphere_number,:)
      poli%xyz_bound(1,4:6)=xyz_sphere(sphere_number,:)
      poli%xyz_bound(2,4:6)=xyz_sphere(sphere_number,:)
      poli%xyz_bound(3,4:6)=xyz_sphere(sphere_number,:)

      cutted=.false.
      n_extra=0_i4_kind
      extra_point=.false.
      h_case=.false.

      j_spheres: do jh=1,N_spheres
         j=cut_rad_sort(sphere_number,jh)
         inside_flag(:) = .false.
         h_case_sphere=.false.
         if (j==sphere_number) cycle j_spheres
         if(.not. do_cavitation .and. .not. do_disp_rep) then
            if(gepol == 93) then
               if(zero_area(j)) cycle j_spheres
            end if
         end if
         v1=xyz_sphere(j,:)-xyz_sphere(sphere_number,:)
	 d_rad1=sqrt(dot_product(v1,v1))
         if (r_sphere(sphere_number)+r_sphere(j) < d_rad1) cycle j_spheres

	 d_vv=(d_rad1**2+r_sphere(sphere_number)**2-r_sphere(j)**2)/&
				(2.0_r8_kind*d_rad1)

	 cut_center=xyz_sphere(sphere_number,:)+v1/d_rad1*d_vv
         help=r_sphere(sphere_number)**2-d_vv**2
	 if(help<0.0_r8_kind) help=0.0_r8_kind
         cut_radius=sqrt(help)

         !h_case: sphere more than half in an other, typically
         !for H-Atoms
         if(dot_product(v1,cut_center(:)-xyz_sphere(sphere_number,:))<0.0_r8_kind) then
            h_case_sphere=.true.
         endif

         ! definition of the vertises which are inside of J-th sphere
         k1=0
         do i=1,poli%n_vertises
            d_rad=sqrt(dot_product(poli%xyz_vertex(i,:)-xyz_sphere(j,:), &
                 poli%xyz_vertex(i,:)-xyz_sphere(j,:)))
            ! is vertex inside of sphere?
            if (d_rad < r_sphere(j) - small_d) then
               k1=k1+1
               inside_flag(i)= .true.
	       cutted=.true.
            endif
	 enddo
         ! stop tesselation because the tessarea is complitely within the J-th sphere
         if(k1==poli%n_vertises .and. d_rad1>=r_sphere(j)) then 
            poligon_area=0.0_r8_kind
            return
         end if

	 k=poli%n_vertises+1
         i_vertex: do i=1,poli%n_vertises
	    i1=poli%bounds(i,1)

!!$print*,sphere_number,j,inside_flag(i),inside_flag(i1),'!!!!!!!!!!!!!'
	    call line_cut(poli%xyz_vertex(i,:),poli%xyz_vertex(i1,:),&
		poli%xyz_bound(i,1:3),poli%r_bound(i,1),&
		xyz_sphere(j,:),r_sphere(j),&
		inside_flag(i),inside_flag(i1), &
                xyz_sphere(sphere_number,:),h_case(i,1),&
		ncut,new_vertex)
!!$print*,sphere_number,j,inside_flag(i),inside_flag(i1),ncut,'!!!!!!!!!!!!!'

            if(k+ncut>MAX_POL_VER) call error_handler("to many vert")

 	    select case(ncut)
	      case (1)
		  poli%xyz_vertex(k,:)=new_vertex(1:3)
! 	if(sphere_number.eq.2) then
! 	   print*,'case 1',poli%xyz_vertex(k,:),jh,i,i1,j
! 	   print*,sum(abs(poli%xyz_bound(i,1:3))), &
!                   poli%r_bound(i,1),r_sphere(j),h_case(i,1),inside_flag(i),inside_flag(i1)
! 	endif

		  poli%bounds(k,1)=i1
		  poli%bounds(k,2)=i
		  poli%bounds(i1,2)=k
		  poli%bounds(i,1)=k
		  if(inside_flag(i) .and. .not. inside_flag(i1) ) then
                     l1=1
                     l2=2
		  else if(.not. inside_flag(i) .and. inside_flag(i1) ) then
                     l1=2
                     l2=1
		  else
                     write(message,'(a19,i3,a17,i3,a9,i3)' ) &
                          'tessarea on sphere ',sphere_number,', cutting sphere ',j,', vertex ',k
                     call error_handler("def_poligon_tes: this case (1) &
				& should not occure"//achar(10)//trim(message))
		  endif

		  poli%r_bound(k,l1) = poli%r_bound(i,1)
		  poli%xyz_bound(k,3*l1-2:3*l1) = poli%xyz_bound(i,1:3)
		  poli%n_sphere(k,l1)=poli%n_sphere(i,1)
                  h_case(k,l1)=h_case(i,1)
		  poli%r_bound(k,l2) = cut_radius
		  poli%xyz_bound(k,3*l2-2:3*l2) = cut_center(:)
		  poli%n_sphere(k,l2)=j
                  if(h_case_sphere) h_case(k,l2)=.true.
		  k=k+1
		  cutted=.true.

              case (11)
                  ! add a point, which is not really a vertex but a point on an
		  ! edge
                  ! only, if no h_case edge
                  if(.not. h_case(i,1)) then
		    poli%xyz_vertex(k,:)=new_vertex(1:3)
! 	     if(sphere_number.eq.2) print*,'case 11',poli%xyz_vertex(k,:)

		    poli%bounds(k,1)=i1
		    poli%bounds(k,2)=i
		    poli%bounds(i1,2)=k
		    poli%bounds(i,1)=k

		    poli%r_bound(k,1) = poli%r_bound(i,1)
		    poli%r_bound(k,2) = poli%r_bound(i,1)
		    poli%xyz_bound(k,1:3) = poli%xyz_bound(i,1:3)
		    poli%xyz_bound(k,4:6) = poli%xyz_bound(i,1:3)
		    poli%n_sphere(k,1)=poli%n_sphere(i,1)
		    poli%n_sphere(k,2)=poli%n_sphere(i,1)
                    h_case(k,1)=h_case(i,1)
                    h_case(k,2)=h_case(i,1)
                    n_extra=n_extra+1
                    extra_point(k)=.true.
		    k=k+1
		    cutted=.true.
                  endif

	      case (2)
!AS 28.12.2005 
!Here we try to avoid situation when the j-th sphere does not cross any edges of the tessare
!but only touchs one of them. Othewise we can have situation of creating pseudo vertex
!with angle exactly equal 180 degree
                  v_buf=new_vertex(1:3)-new_vertex(4:6)
                  if(sqrt(dot_product(v_buf,v_buf))<small_d .and. &
                       .not.inside_flag(i) .and. .not. inside_flag(i1)) cycle i_vertex

		  poli%xyz_vertex(k,:)=new_vertex(1:3)
		  poli%xyz_vertex(k+1,:)=new_vertex(4:6)
! 	if(sphere_number.eq.2) print*,'case (2)',poli%xyz_vertex(k,:)

		  poli%bounds(i,1)=k
		  poli%bounds(k,1)=k+1
		  poli%bounds(k+1,1)=i1
		  poli%bounds(k,2)=i
		  poli%bounds(k+1,2)=k
		  poli%bounds(i1,2)=k+1
		  if(inside_flag(i) .and. inside_flag(i1)) then
                     l1=1
                     l2=2
		  else if(.not.inside_flag(i) .and. .not. inside_flag(i1)) then
                     l1=2
                     l2=1
		  else
                     write(message,'(a19,i3,a17,i3,a9,i3)' ) &
                          'tessarea on sphere ',sphere_number,', cutting sphere ',j,', vertex ',k
                     call error_handler("def_poligon_tes: this case (2) &
				& should not occure"//achar(10)//trim(message))
  		  endif

		  poli%r_bound(k,l1)=poli%r_bound(i,1)
		  poli%r_bound(k+1,l2)=poli%r_bound(i,1)
		  poli%r_bound(k,l2)=cut_radius
		  poli%r_bound(k+1,l1)=cut_radius
		  poli%n_sphere(k,l1)=poli%n_sphere(i,1)
                  h_case(k,l1)=h_case(i,1)
		  poli%n_sphere(k+1,l2)=poli%n_sphere(i,1)
                  h_case(k+1,l2)=h_case(i,1)
		  poli%n_sphere(k,l2)=j
		  poli%n_sphere(k+1,l1)=j
		  poli%xyz_bound(k,3*l1-2:3*l1)=poli%xyz_bound(i,1:3)
		  poli%xyz_bound(k+1,3*l2-2:3*l2)=poli%xyz_bound(i,1:3)
		  poli%xyz_bound(k,3*l2-2:3*l2)=cut_center(:)
		  poli%xyz_bound(k+1,3*l1-2:3*l1)=cut_center(:)
		  if(h_case_sphere) then
			h_case(k,l2)=.true.
                        h_case(k+1,l1)=.true.
                  endif
 		  k=k+2
		  cutted=.true.
		case default 
                   if(inside_flag(i)  .neqv. inside_flag(i1)) then
                      write(message,'(a19,i3,a17,i3,a9,i3)' ) &
                           'tessarea on sphere ',sphere_number,', cutting sphere ',j,', vertex ',k
                      call error_handler("this case (0) &
                           & should not occure"//achar(10)//trim(message))
                   end if
                   ! do nothing in cases n_cut=0 n_cut=3
                   ! n_cut=0 appears also, if both vertises are inside.
                   ! in this case, cutted=.true. is already set above
	    end select

         enddo i_vertex
	 k_new=k-1-poli%n_vertises
	 ! sort in and out new / old corners (only old corners, new are on 
	 ! cutting circle by construction
	 ! delete very close vertises
	 do i=1, poli%n_vertises
		if(.not. inside_flag(i)) then
			lab_l1 : do l1=1,2  
			   i1=poli%bounds(i,l1)
			   ii=1
			   if(l1==1) ii=2
			   v_buf=poli%xyz_vertex(i,:)-&
				poli%xyz_vertex(i1,:)
			   if(sqrt(dot_product(v_buf,v_buf))<small_d) then
				poli%bounds(i1,ii)=poli%bounds(i,ii)
				poli%r_bound(i1,ii)=poli%r_bound(i,ii)
				poli%xyz_bound(i1,ii*3-2:ii*3)=&
					poli%xyz_bound(i,3*ii-2:3*ii)
				poli%n_sphere(i1,ii)=poli%n_sphere(i,ii)
                                h_case(i1,ii)=h_case(i,ii)
				inside_flag(i)=.true.
				exit lab_l1
			   endif
			enddo lab_l1
		endif
	 enddo

 	 do i=1, poli%n_vertises
 		if(inside_flag(i)) then
 			poli%bounds(poli%bounds(i,1),2)=poli%bounds(i,2)
 			poli%bounds(poli%bounds(i,2),1)=poli%bounds(i,1)
 		endif
          enddo
         num_v=0
         if(k_new-n_extra>3 .and. .not. h_case_sphere) then
           !re-connect vertises, in case, tessera is cutted in several pieces
	   n_tes_part=1
           is=-1
           ii=0 
           new_points: do k=poli%n_vertises+1,poli%n_vertises+k_new
            if(extra_point(k).or.inside_flag(k)) cycle new_points
	    do i=1,ii
              if(is(i)==k) cycle new_points
	    enddo
            !k belongs to an separate piece of tessera
            ii=ii+1
            is(ii)=k
            !search for new vertexes belonging to the same piece of tessera
            i1=k
            do 
               i1=poli%bounds(i1,1)
               if (i1==k) exit
               if (.not. extra_point(i1) .and. i1>poli%n_vertises) then
                  ii=ii+1
                  is(ii)=i1
               endif
            enddo
            num_v(n_tes_part)=ii
            n_tes_part=n_tes_part+1
           enddo new_points
           max_tes_part=n_tes_part-1
           do k=max_tes_part,2,-1
            num_v(k)=num_v(k)-num_v(k-1)
           enddo
           !connect vertices from j_sphere cuttings which 
           !are the next ones in the opposite (cyclic) direction 
           !over the vertices from where
           !the j_sphere cutting edge joins two of them  
           !the is-field is constructed in 1 direction
           !therefore in 1 direction is(2) has to be connected with
           !is(3) ... is(1) with is(num), whereas in the 2 direction
           !is(1) has to be connected with is(2) and so on
           ii=1
           tessera_parts: do n_tes_part=1,max_tes_part
             if(num_v(n_tes_part)<4) then
               ! part is not devided in several new parts
               ii=ii+num_v(n_tes_part)
               cycle tessera_parts
             endif

             !find direction
             l1=2
             l2=1
             if(poli%n_sphere(is(ii),1)==j) then
 		l1=1
                l2=2
             endif
	     do i=ii-1+l1,ii-1+num_v(n_tes_part),2
                i1=i-1
                if(i1<ii) i1=ii+num_v(n_tes_part)-1  
                poli%bounds(is(i1),2)=is(i)
                poli%bounds(is(i),1)=is(i1)
	 	poli%n_sphere(is(i1),2)=j
	 	poli%n_sphere(is(i),1)=j
                if(h_case_sphere) then
			h_case(is(i1),2)=.true.
			h_case(is(i),1)=.true.
                endif
		poli%xyz_bound(is(i),1:3)=cut_center(:)
		poli%xyz_bound(is(i1),4:6)=cut_center(:)
		poli%r_bound(is(i),1)=cut_radius
		poli%r_bound(is(i1),2)=cut_radius
             enddo
             ii=ii+num_v(n_tes_part)
           enddo tessera_parts
         endif

	 ! contract poligon (remove empty space)
	 ! also only over old corners
! 	if(sphere_number.eq.2.and.poli%n_vertises.eq.4) print*,'n_vertises', poli%n_vertises
         i=1
	 do 
	     if(i>poli%n_vertises) exit
! 		if(i.eq.0) print*,'i eq 0'
	     if(inside_flag(i)) then
		do k=i+1,poli%n_vertises+k_new
		  if(.not. inside_flag(k)) then
		   poli%xyz_vertex(k-1,:)=poli%xyz_vertex(k,:)
		   poli%r_bound(k-1,:)=poli%r_bound(k,:)
		   poli%xyz_bound(k-1,:)=poli%xyz_bound(k,:)
		   poli%n_sphere(k-1,:)=poli%n_sphere(k,:)
                   h_case(k-1,:)=h_case(k,:)
		   poli%bounds(poli%bounds(k,1),2)=k-1
		   poli%bounds(poli%bounds(k,2),1)=k-1
		  endif
		  poli%bounds(k-1,:)=poli%bounds(k,:)
		  inside_flag(k-1)=inside_flag(k)
		  extra_point(k-1)=extra_point(k)
                enddo
		poli%n_vertises=poli%n_vertises-1
		i=i-1
	     endif
	     i=i+1
         enddo
	 poli%n_vertises=poli%n_vertises+k_new
      enddo j_spheres
	
! 	if(sphere_number.eq.2.and.poli%n_vertises.eq.4)  &
!            print*, sum(abs(poli%xyz_vertex(1:poli%n_vertises,:))), &
!             'just defined',k_new,sum(abs(poli%xyz_vertex(1:3,:)))

      !count again number of tessera pieces, because some
      !may be totally inside an other sphere
      ii=0
      is=-1
      n_tes_part=1

      count_pieces: do k=1,poli%n_vertises
	    do i=1,ii
              if(is(i)==k) cycle count_pieces
	    enddo
            ii=ii+1
            is(ii)=k
            i1=k
            do l1=1,poli%n_vertises
               i1=poli%bounds(i1,1)
               if (i1==k) exit
               ii=ii+1
               is(ii)=i1
            enddo
            n_tes_part=n_tes_part+1
      enddo count_pieces
      max_tes_part=n_tes_part-1


      !test for half-circle edges or edges with angle > pi
      k=poli%n_vertises+1
      n_extra=0 
      do i=1,poli%n_vertises
         if(poli%n_sphere(i,1)==0) cycle
         if(h_case(i,1)) cycle
         i1=poli%bounds(i,1)
         v_buf=vector_product(poli%xyz_vertex(i,:)-xyz_sphere(sphere_number,:),&
 			poli%xyz_vertex(i1,:)-xyz_sphere(sphere_number,:))
         d_vv= dot_product(v_buf,poli%xyz_vertex(i,:)-poli%xyz_bound(i,1:3))

         if(d_vv <small_d .and. -d_vv<small_d) then
           v_buf=v_buf/sqrt(dot_product(v_buf,v_buf))*poli%r_bound(i,1)+&
			poli%xyz_bound(i,1:3)
         else if(dot_product(v_buf,0.5_r8_kind*(poli%xyz_vertex(i,:)+&
		poli%xyz_vertex(i1,:))-poli%xyz_bound(i,1:3))< small_d ) then
           v_buf= -0.5_r8_kind*poli%xyz_vertex(i,:) &
		   -0.5_r8_kind*poli%xyz_vertex(i1,:) &
		   +poli%xyz_bound(i,1:3)
           v_buf= v_buf/sqrt(dot_product(v_buf,v_buf))*poli%r_bound(i,1)&
		   +poli%xyz_bound(i,1:3)
         else
           cycle
         endif
	 poli%xyz_vertex(k,:)=v_buf
	 

	 poli%bounds(k,1)=i1
	 poli%bounds(k,2)=i
	 poli%bounds(i1,2)=k
	 poli%bounds(i,1)=k

	 poli%r_bound(k,1) = poli%r_bound(i,1)
	 poli%r_bound(k,2) = poli%r_bound(i,1)
	 poli%xyz_bound(k,1:3) = poli%xyz_bound(i,1:3)
	 poli%xyz_bound(k,4:6) = poli%xyz_bound(i,1:3)
	 poli%n_sphere(k,1)=poli%n_sphere(i,1)
	 poli%n_sphere(k,2)=poli%n_sphere(i,1)
         h_case(k,1)=h_case(i,1)
         h_case(k,2)=h_case(i,1)
         extra_point(k)=.true.
           
         k=k+1
      enddo
      poli%n_vertises=k-1

      ! sorting already enshured
      ! test sorting
      do i=1,poli%n_vertises
	i1=poli%bounds(i,1)
	if(poli%bounds(i1,2)/=i) print *,"wrong sorting"
	i1=poli%bounds(i,2)
	if(poli%bounds(i1,1)/=i) print *,"wrong sorting"
      enddo

      if(poli%n_vertises==0) then
	poligon_area=0.0_r8_kind
	return
      endif

      ! computing poligone center
      xyz_poligon_centre=0.0_r8_kind
      if(.not. weight_cent) then
       if(.not. orig_cent .and. .not. weight_cent) then
! 	if(sphere_number.eq.2) print*,'case 1 xyz_poligon_centre'
         do i=1,poli%n_vertises
          if(.not. extra_point(i)) then
            xyz_poligon_centre=xyz_poligon_centre+ & !(case 1)
              (poli%xyz_vertex(i,:)-xyz_sphere(sphere_number,:))
          endif
         enddo
        else if(orig_cent) then
! 	if(sphere_number.eq.2) print*,'case 2 xyz_poligon_centre'
        ! use the original triangle vertices -> no problem with gradient
            xyz_poligon_centre=xyz_triangl_1+xyz_triangl_2+xyz_triangl_3 & !(case 2)
			-3.0_r8_kind*xyz_sphere(sphere_number,:)
        endif
        center_factor=sqrt(dot_product(xyz_poligon_centre,xyz_poligon_centre))
        xyz_poligon_centre=xyz_poligon_centre*(r_sphere(sphere_number))/ &
           center_factor+xyz_sphere(sphere_number,:)
!!!! MF bug fix 9/2001 (for further using)
	center_factor=center_factor/r_sphere(sphere_number)
      endif
!     else  if weigt_cent -> calculate after area computation

      ! computing poligon area (Gauss-Bonet theorem)
      ! attention: there are lots of errors in the paper of Cossi & al: J Comp Chem 17,57-73 (1996)
      ! read (p 60):
      ! phi_n=arccos(hat_v(n) hat_v*(n+1))
      ! cos(theta_n)= hat_P(n) hat_T(n), where
      ! T(n) is the vector pointing form the center of actual sphere to
      ! the center of the cutting sphere (the  difference to the definition in the paper
      ! is a sign in the case, one sphere is more then half in the other)

      ! more or less pathologic cases lead to negative areas
      ! in case, when one geodetic bonding edge of th poligon
      ! is cutted twice by the same sphere
      ! (e.g. if this cutting sphere is very small, or the poligon is
      ! very flat
      ! 4/2000 neglegt this areas (better: contract them with
      ! an neigbouring poligon
      combination=.false.

      poligon_area=0.0_r8_kind
      phin=0.0_r8_kind
      costhn=0.0_r8_kind

!!!MF >>>>
      first_vertex: do i=1,poli%n_vertises
         j=1
            i1=poli%bounds(i,j)

            if(poli%n_sphere(i,j)/=0) then
 	       v_buf=xyz_sphere(poli%n_sphere(i,j),:)-xyz_sphere(sphere_number,:)
               d_rad=sqrt(dot_product(v_buf,v_buf))
               cos_gamma=dot_product(poli%xyz_vertex(i,:)-xyz_sphere(sphere_number,:),v_buf)/&
                       (r_sphere(sphere_number)*d_rad)

               alpha=acosnum(dot_product(poli%xyz_vertex(i,:)-poli%xyz_bound(i,3*j-2:3*j), &
                    poli%xyz_vertex(i1,:)-poli%xyz_bound(i,3*j-2:3*j))/poli%r_bound(i,j)**2)

               ! because of the new sorting of vertices, always with neigbour
               !	number 1
               !if(j==1) then
                  costhn(i)=cos_gamma
                  phin(i)=alpha
               !else
               !   costhn(i1)=cos_gamma
               !   phin(i1)=alpha
               !endif
               poligon_area=poligon_area+alpha*cos_gamma
            else if(weight_cent_mass) then !also phin needed for uncut bounds
                                      !i.e. bound= sphere centre
               phin(i)=acosnum(dot_product(poli%xyz_vertex(i,:)-poli%xyz_bound(i,3*j-2:3*j), &
                    poli%xyz_vertex(i1,:)-poli%xyz_bound(i,3*j-2:3*j))/poli%r_bound(i,j)**2)
            endif
      enddo first_vertex

!	if(sphere_number.eq.2.and.poli%n_vertises.eq.4) print*,sum(phin(1:poli%n_vertises)), &
!		sum(abs(poli%xyz_vertex(1:poli%n_vertises,:)))
!!!MF <<<<

      do i=1,poli%n_vertises
         i1=poli%bounds(i,1)
	 vn(i,:)=poli%xyz_vertex(i,:)-poli%xyz_bound(i,1:3)
         v_buf=vector_product(vn(i,:), &
              poli%xyz_vertex(i1,:)-poli%xyz_bound(i,1:3))
         v1=vector_product(vn(i,:),v_buf)

         v1=v1/sqrt(dot_product(v1,v1))
         i1=poli%bounds(i,2)
	 vns(i,:)=poli%xyz_vertex(i,:)-poli%xyz_bound(i,4:6)
         
         v_buf=vector_product(vns(i,:), &
              poli%xyz_vertex(i1,:)-poli%xyz_bound(i,4:6))

         v2=vector_product(vns(i,:),v_buf)

         v2=v2/sqrt(dot_product(v2,v2))
         if(.not. extra_point(i)) then
         	beta=pi-acosnum(dot_product(v1,v2))

         	poligon_area=poligon_area-beta
         endif

	 !v1,v2 are the tn,tn+1 in Cossi96
 	 if (do_gradients .or. weight_cent_sin) then
	 	tn(i,:)=v1
	 	tns(i,:)=v2
 	 endif
      enddo

      poligon_area=(poligon_area+2.0_r8_kind*pi*max_tes_part)*r_sphere(sphere_number)**2

      if(weight_cent_sin) then
! 	if(sphere_number.eq.2) print*,'case 3 xyz_poligon_centre'
         do i=1,poli%n_vertises
          if(.not. extra_point(i)) then
            xyz_poligon_centre=xyz_poligon_centre+ &    ! (case 3)
              (poli%xyz_vertex(i,:)-xyz_sphere(sphere_number,:)) * &
              (1.0_r8_kind-(dot_product(tn(i,:),tns(i,:)))**2)
          endif
         enddo
         center_factor=sqrt(dot_product(xyz_poligon_centre,xyz_poligon_centre))
         xyz_poligon_centre=xyz_poligon_centre*(r_sphere(sphere_number))/ &
           center_factor+ xyz_sphere(sphere_number,:)
!!!!! MF 9/2001 bug fix (for further using)
         center_factor=center_factor/r_sphere(sphere_number)

      else if(weight_cent_mass) then
         !mass=0.0_r8_kind
         !real total mass not needed, for another scaling is anyhow
         !done to put the representative point (center) on the sphere
         !again
         do i=1,poli%n_vertises
            i1=poli%bounds(i,1)
            !run also over extra points which are constructed
            !to avoid sign problems with angles larger than pi
            !mass=mass+poli%r_bound(i,1)*phin(i)

            tanphi2=tan(phin(i)/2.0_r8_kind)

!           xyz_poligon_centre=xyz_poligon_centre+ &
!		poli%r_bound(i,1)*(&
!			(phin(i)-2.0_r8_kind*tanphi2)*&
!			   (poli%xyz_bound(i,1:3)-xyz_sphere(sphere_number,:))+&
!			tanphi2*(poli%xyz_vertex(i,:)+poli%xyz_vertex(i1,:)-&
!				2.0_r8_kind*xyz_sphere(sphere_number,:))&
!		)
!	    easier:

            xyz_poligon_centre=xyz_poligon_centre+ &   !(case 4)
		poli%r_bound(i,1)*(&
			phin(i)*(poli%xyz_bound(i,1:3)-xyz_sphere(sphere_number,:))+&
			tanphi2*(vn(i,:)+vns(i1,:))&
		)
         enddo
         center_factor=sqrt(dot_product(xyz_poligon_centre,xyz_poligon_centre))
! 	if(sphere_number.eq.2) then
!         print*,'case 4 xyz_poligon_centre',poli%n_vertises,center_factor
!	 print*,sum(abs(poli%xyz_bound(1:poli%n_vertises,:))),sum(abs(phin(1:poli%n_vertises)))
!  	endif
	
         xyz_poligon_centre=xyz_poligon_centre*(r_sphere(sphere_number))/ &
		center_factor+xyz_sphere(sphere_number,:)
!!!!! MF 9/2001 bug fix (for further using)
         center_factor=center_factor/r_sphere(sphere_number)
      endif

!!! MF 4/2000 cancle negative areas
      if (poligon_area < min_area) then
     	DPRINT 'area small/negative (',poligon_area,') , canceled'
     	DPRINT 'at center',xyz_poligon_centre 
     	poligon_area=0.0_r8_kind
      endif

!!! MF 5/2000
      if(do_gradients .and. poligon_area>0.0_r8_kind ) then
	 if(cutted) then
	    call geom_grad_cutted_triang(poli,sphere_number,tn,tns,&
		vn,vns,costhn,phin,poligon_area,extra_point,&
		xyz_poligon_centre,center_factor)
         else
    	    call geom_grad_orig_triang(sphere_number,poligon_area,&
				xyz_poligon_centre)
	 endif
      endif
!if(poligon_area>0.0_r8_kind .and. .not.do_cavitation .and. .not. do_disp_rep ) then
!n_extra=0
!i1=0
!do i=1,poli%n_vertises
!if(extra_point(i)) n_extra=n_extra+1
!if(poli%n_sphere(i,1)/=0) i1=i1+1
! enddo
! DPRINT 'poligon ' ,N_total+1,poli%n_vertises,i1,n_extra,max_tes_part
!endif

    end subroutine def_poligon_tes
!---------------------------------------------------------------------------
    !------------------------------------------------------------
!!!MF numerical save acos function >>>>
    function acosnum(cos_t)
      real(kind=r8_kind), intent(in) :: cos_t
      real(kind=r8_kind) :: acosnum

!!$print*,cos_t
      if(cos_t*cos_t-1.0_r8_kind > 1.0e-15_r8_kind) then
	DPRINT cos_t
        DPRINT counter_n
	call error_handler("acos of value >1 or <-1 demanded?!")
      else if(cos_t>1.0_r8_kind) then
        acosnum=acos(1.0_r8_kind)
      else if(cos_t<-1.0_r8_kind) then
        acosnum=acos(-1.0_r8_kind)
      else 
        acosnum=acos(cos_t)
      end if

    end function acosnum
    !------------------------------------------------------------

!---------------------------------------------------------------------------
    subroutine line_cut(p1,p2,cent1,r1,cent2,r2,ins1i,ins2i,cent0,h_case,ncut,pcut)
      ! idea: any point of the edge considered (center at origin) 
      ! can be written as:
      ! r=(v1+lam (v2-v1))/|(v1+lam (v2-v1))| *r_bound
      ! with lam in [0,1]
      ! look for solutions of |r-d|=R, where d is the vector to the
      ! cutting sphere center and R is its radius
      !** End of interface *****************************************

      real(kind=r8_kind),intent(in),dimension(3) :: p1,p2,cent1,cent2,cent0
      real(kind=r8_kind),intent(in) :: r1,r2
      logical, intent(in) :: ins1i, ins2i, h_case
      real(kind=r8_kind),intent(out),optional :: pcut(6)
      integer (kind=i4_kind), intent(out) :: ncut
      integer (kind=i4_kind) :: i,ncut_o,ih
      real(kind=r8_kind), dimension(3) :: v1,v12,vd
      real(kind=r8_kind) :: d,del,v1v12,v1vd,v12vd,ha,hb,hc,lam(2),v12v12,v1v1,aha,ahb,ahc
      real(kind=r8_kind), parameter :: small = 1.0e-8_r8_kind
      real (kind=r8_kind) :: vb(3),help,lower_bound,pcut_help(6)
      logical :: near(2,2),l_help,twocase,colin_case,smaller_pi,second_run,ins1,ins2,interchange

      smaller_pi=.true.
      second_run=.false.
      colin_case=.false.
      twocase=.false.
      interchange=.false.
      ins1=ins1i
      ins2=ins2i
      lower_bound=0.0_r8_kind
      lam=-100.0_r8_kind
      v1=p1-cent1
      v12=p2-p1
      
      !test if vectors are linear dependent
      vd=vector_product(v1,v12)
!!$print*,v1,v12
      if(dot_product(vd,vd)<small .and. .not. dot_product(v12,v12) < small)&
                colin_case=.true. !vectors parallel!     

      !test if edge has angle larger then pi -> only for cutting edges
      if(.not.colin_case) then
        vd=cent1-cent0
        if(dot_product(vd,vd)>small .and. .not. h_case ) then
           vd=vector_product(p1-cent0,p2-cent0)
!          larger pi case for h_case
	   if(h_case) vd=-vd
 	   if(dot_product(vd,0.5_r8_kind*(p1-cent1)+0.5_r8_kind*(p2-cent1))&
			<0.0_r8_kind ) then
              smaller_pi=.false.
              vb= -0.5_r8_kind*p1 -0.5_r8_kind*p2 +cent1
              vb= vb/sqrt(dot_product(vb,vb)) *r1
              v12= vb -v1
              vd=vb-(cent2-cent1)
	      if(dot_product(vd,vd)<r2**2) then
			ins2=.true.
              else
                        ins2=.false.
              endif
	   endif
        endif
      endif

      if(colin_case) then 
        v12=vector_product(p1-cent0,p2-cent0)
        v12=v12/sqrt(dot_product(v12,v12)) * r1
	! opposite for h_case (convex bond)
!	if (h_case) v12=-v12
        lower_bound=-1.0_r8_kind
      endif

      vd=cent2-cent1
      ncut=0

      d=sqrt(dot_product(vd,vd))
      del=r1**2+d**2-r2**2

1000  v1v12=dot_product(v1,v12)
      v1vd=dot_product(v1,vd)
      v12vd=dot_product(v12,vd)
      v12v12=dot_product(v12,v12)
      v1v1=dot_product(v1,v1)
      near=.false.
  
      if(.not. colin_case) then
         ha=4.0_r8_kind*r1**2*v12vd**2-del**2*v12v12
         hb=8.0_r8_kind*r1**2*v12vd*v1vd-2.0_r8_kind*del**2*v1v12
         hc=4.0_r8_kind*r1**2*v1vd**2-del**2*v1v1
      else
         ha=4.0_r8_kind*(v1vd**2+v12vd**2)
         hb=4.0_r8_kind*(-del*v1vd)
         hc=del**2-4.0_r8_kind*v12vd**2 
      endif

      aha=abs(ha)
      ahb=abs(hb)
      ahc=abs(hc)
!!$print*,aha,ahb,ahc,colin_case
      ! this a littel bit complcated formulation I do because of
      ! not clear accuracy of intrinsic functions
      ! solutions of: ha*lam**2+hb*lam+hc==0
      if(aha<small .and. ahb<small .and. ahc<small) then
         !all lambdas fullfill the equation (esotheric case)
         ncut=3
         return
      else if (aha<small .and. ahb<small ) then
         !no solution
         ncut=0
         if (.not. colin_case .and. smaller_pi) return
      else if (aha<small ) then
         !exactly one solution
         ncut=1
         lam(1)=-hc/hb
         if(lam(1)<lower_bound-small .or. lam(1)>1.0_r8_kind+small) ncut=0
         if(abs(lam(1)-lower_bound)<10.0_r8_kind*small) then
                if(ins1.neqv.ins2) then 
		    lam(1)=lower_bound
                    ncut=1
                else
                    ncut=0
                endif
         else if(abs(lam(1)-1.0_r8_kind)<10.0_r8_kind*small) then
                if(ins1.neqv.ins2) then 
                    lam(1)=1.0_r8_kind
                    ncut=1
                else
                    ncut=0
                endif
         endif
      else if ((hb/ha)**2-4.0_r8_kind*hc/ha> -small) then
!!$print*,'2'
         !two possible solutions
         twocase = .true.
         ncut=2
         if((hb/(2.0_r8_kind*ha))**2-hc/ha > small*10.0_r8_kind) then
            lam(1)=sqrt((hb/(2.0_r8_kind*ha))**2 - hc/ha)
         else
            lam(1)=0.0_r8_kind
         endif
         lam(2)=-hb/(2.0_r8_kind*ha)+lam(1)
         lam(1)=-hb/(2.0_r8_kind*ha)-lam(1)
         near(1,1)=(abs(lam(1)-lower_bound)<small*10.0_r8_kind)
         near(2,1)=(abs(lam(2)-lower_bound)<small*10.0_r8_kind)
         near(1,2)=(abs(lam(1)-1.0_r8_kind)<small*10.0_r8_kind)
         near(2,2)=(abs(lam(2)-1.0_r8_kind)<small*10.0_r8_kind)
         ! always lam(1)<lam(2)
!!$print*,lam(1),lam(2),'lam(1),lam(2)',lower_bound
         if(lam(1)>1.0_r8_kind+small .or. lam(2)<lower_bound-small) then
            ! no solution in the range [0,1] 
            ncut=0
         else if(lam(2)>1.0_r8_kind+small .and. lam(1)<lower_bound-small)  then
            ! no solution in the range [0,1]
            ncut=0
         else if(lam(2)>1.0_r8_kind+small) then! .or.  
            ! only lam(1) in the range [0,1]
            ncut=1
         else if(lam(1)<lower_bound-small) then!.or. ((ins1i.neqv.ins2i).and.lam(2)>0.0_r8_kind)) then 
            ! only lam(2) solution in range [0,1]
            ncut=1
            help=lam(2)
            lam(2)=lam(1)
            lam(1)=help
            l_help=near(1,1)
            near(1,1)=near(2,1)
            near(2,1)=l_help
            l_help=near(1,2)
            near(1,2)=near(2,2)
            near(2,2)=l_help
         endif
!!$print*,ncut,'ncut'
      else
         !no real solution
         ncut=0
         if(.not. colin_case .and. smaller_pi) return
      endif
      i=1
      do 
         if(i>ncut) exit

         if(.not.colin_case) then
           vb=v1+lam(i)*v12
           vb=vb/(sqrt(dot_product(vb,vb)))
         else
           if(lam(i)**2<1.0_r8_kind) then
              vb=lam(i)*v1+sqrt(1.0_r8_kind-lam(i)**2)*v12
           else
              vb=lam(i)*v1
           endif
           vb=vb/r1
         endif
         ! test if not solution of - vd*pcut = d**2+r1**2-r2**2 
!!$         if(abs(-2.0_r8_kind*dot_product(vd,vb)*r1-del)<sqrt(small) .and. &
         if(abs(2.0_r8_kind*dot_product(vd,vb)*r1-del)>=sqrt(small) .and. &
		abs(dot_product(vd,vb))>sqrt(small)) then
            ! non valid solution
            if(i==1 .and. ncut==1) then
               ncut=0
               if(.not. colin_case .and. smaller_pi) return
            else if(i==1 .and. ncut==2) then
               i=0
               ncut=1
               help=lam(1)
               lam(1)=lam(2)
               lam(2)=help
               l_help=near(1,1)
               near(1,1)=near(2,1)
               near(2,1)=l_help
               l_help=near(1,2)
               near(1,2)=near(2,2)
               near(2,2)=l_help
               interchange=.true.
            else
               ncut=1
            endif
         else
            ! valid solution
            pcut(3*i-2:3*i) = cent1 + vb*r1
         endif
         i=i+1
      enddo

!!$print*,ncut,'ncut1'
      if(twocase) then
         if(ncut==0 .and. (ins1 .neqv. ins2)) then
            if(near(1,1) .or. near(2,1)) then
               lam(1)=lower_bound
            else if(near(1,2) .or. near(2,2)) then
               lam(1)=1.0_r8_kind
            else 
               ncut=-1
            endif
            ncut=ncut+1
         else if(ncut==2 .and. (ins1 .neqv. ins2)) then
            if(ins1 .and. near(1,1)) then
               lam(1)=lam(2)
            else if (ins1 .and. near(2,1)) then 
            else if (ins2 .and. near(2,2)) then
            else if (ins2 .and. near(1,2)) then
               lam(1)=lam(2)
            else if (near(1,1) .and. near(2,1)) then
            else if (near(1,2) .and. near(2,2)) then
               lam(1)=lam(2)
            else if(abs(lam(1)-lam(2))<sqrt(small)) then
            else
               ncut=3
            endif
            ncut=ncut-1 
         else if(ncut ==1 .and. (ins1 .eqv. ins2) .and. ins1) then
            if (near(1,1) .or. near(1,2) .or. near (2,1) .or. near (2,2))ncut=0
         else if(ncut ==1 .and. (ins1 .eqv. ins2) .and. .not. ins1) then
            if (near(1,1) .or. near(1,2)) then
               ncut=0
            else if (near(2,1) .or. near(2,2)) then
               ncut=2 
               if(near(2,1)) then
                  lam(2)=lower_bound
                  interchange=.true.
               else if(near(2,2)) then
                  lam(2)=1.0_r8_kind
               endif
            endif
         endif
!!$print*,ncut,'ncut2'
         
!        recalculate in any case
         do i=1,ncut
           if(.not.colin_case) then
             vb=v1+lam(i)*v12
             vb=vb/(sqrt(dot_product(vb,vb)))
           else
             if(lam(i)**2<1.0_r8_kind) then
              vb=lam(i)*v1+sqrt(1.0_r8_kind-lam(i)**2)*v12
             else
              vb=lam(i)*v1
             endif
           vb=vb/r1
           endif
           pcut(3*i-2:3*i) = cent1 + vb*r1
         enddo
      endif

      if(.not.smaller_pi .and. ncut<2 .and. .not. second_run) then
           pcut_help=pcut
           ncut_o=ncut
           v1=-0.5_r8_kind*p1 -0.5_r8_kind*p2 + cent1
           v1=v1/sqrt(dot_product(v1,v1))*r1
	   v12=p2-cent1-v1
           ins1=ins2
	   ins2=ins2i
           lam=-100.0_r8_kind
           second_run=.true.
           goto 1000
      else if (.not. smaller_pi .and. second_run) then
           ncut=ncut+ncut_o
           do i=ncut_o+1,ncut
             ih=i-ncut_o
             pcut_help(3*i-2:3*i)=pcut(3*ih-2:3*ih)
	   enddo
           pcut=pcut_help
      endif
!!$print*,ncut,'ncut3'
  
!     if(ncut==0 .and. colin_case) then
!        pcut(1:3)=cent1+v12
!        ncut=11
!     endif
!     if(ncut==0 .and. .not. smaller_pi) then
!        vb= -0.5_r8_kind*p1 -0.5_r8_kind*p2 +cent1
!        vb= vb/dot_product(vb,vb) *r1             
!        pcut(1:3)=cent1+vb 
!        ncut=11
!     endif

    end subroutine line_cut
    !------------------------------------------------------------

    !------------------------------------------------------------
    function vector_product(vector1,vector2)
      real(kind=r8_kind), intent(in) :: vector1(3), vector2(3)
      real(kind=r8_kind) :: vector_product(3)

      vector_product(1)=vector1(2)*vector2(3)-vector2(2)*vector1(3)
      vector_product(2)=vector1(3)*vector2(1)-vector2(3)*vector1(1)
      vector_product(3)=vector1(1)*vector2(2)-vector2(1)*vector1(2)      

    end function vector_product
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine geom_grad_cutted_triang(poli,nsp,tn,tns,vn,vns,costhn,phin,area,&
         extra_point,xyz_cent,cent_f)
      !gradients of areas and centers of cutted triangles
      !** End of interface *****************************************

      type(poligon), intent(in) :: poli
      integer(kind=i4_kind), intent(in) :: nsp
      real(kind=r8_kind), intent(in),dimension(MAX_POL_VER,3) :: tn,tns,vn,vns
      real(kind=r8_kind), intent(in),dimension(MAX_POL_VER) :: phin,costhn
      real(kind=r8_kind), intent(in) :: area,xyz_cent(3),cent_f
      logical, intent(in) :: extra_point(MAX_POL_VER)

      real(kind=r8_kind), dimension(3) :: vc,vd,tnsg,tng,&
           ep,no,nos,vbuf,dno,dnos,dik,diks,epk
      real(kind=r8_kind) :: dp1,dpnoep,dpnosep,dpnotns,dpnostn,mu,mus,  &
           dist1,dist2,help,help1,tanphi2
      real(kind=r8_kind), dimension(3) :: dP,dTc,dTcs
      integer(kind=i4_kind) :: i,j,l,i1,i2,k,status,na,ea,l1
      logical :: b_cut,bs_cut
      real (kind=r8_kind), parameter :: small=1.0e-11_r8_kind
      integer :: N_pc

      type(arrmat2), allocatable :: cgdP(:,:,:),cgdv(:,:,:),cgdvs(:,:,:)
      type(arrmat1), allocatable :: cgdomeg(:,:,:),cgdcosth(:,:,:),cgdphi(:,:,:)

      !bound is the edge and vertex the corner of the poligon
      !all derivatives relative to sphere center
      !dP: vertex relative to sphere center
      !dv: vertex relative to bound center
      !dTc: bound center
      !tn.. bound tangents at vertices
      !phin: bound arc angle
      
      N_pc=0
!!$      if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
      if(with_pc) N_pc=pointcharge_N

      allocate(cgdP(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=status)
      if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang0")
      allocate(cgdv(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=status)
      if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang1")
      allocate(cgdvs(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=status)
      if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang2")
      allocate(cgdomeg(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=status)
      if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang3")
      allocate(cgdcosth(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=status)
      if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang4")
      allocate(cgdphi(3,N_moving_unique_atoms+N_pc,ua_dim_max),stat=status)
      if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang5")
      
      do i=1,N_moving_unique_atoms+N_pc
         if(i <= N_moving_unique_atoms) then
            na=moving_unique_atom_index(i)
            ea=unique_atoms(na)%n_equal_atoms
         else
            na=i-N_moving_unique_atoms
            ea=pointcharge_array(na)%N_equal_charges
         end if
         do l=1,ea
            do j=1,3
               allocate(cgdP(j,i,l)%m(3,poli%n_vertises),stat=status)
               if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang6")
               allocate(cgdv(j,i,l)%m(3,poli%n_vertises),stat=status)
               if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang7")
               allocate(cgdvs(j,i,l)%m(3,poli%n_vertises),stat=status)
               if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang8")
               allocate(cgdomeg(j,i,l)%m(poli%n_vertises),stat=status)
               if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang9")
               allocate(cgdcosth(j,i,l)%m(poli%n_vertises),stat=status)
               if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang10")
               allocate(cgdphi(j,i,l)%m(poli%n_vertises),stat=status)
               if(status/=0) call error_handler("alloc fail geom_grad_cutted_triang11")
               cgdP(j,i,l)%m=0.0_r8_kind
               cgdv(j,i,l)%m=0.0_r8_kind
               cgdvs(j,i,l)%m=0.0_r8_kind
               cgdcosth(j,i,l)%m=0.0_r8_kind
               cgdphi(j,i,l)%m=0.0_r8_kind
               cgdomeg(j,i,l)%m=0.0_r8_kind
            enddo
         enddo
      enddo

      do i=1,poli%n_vertises
         !P here relative vertex vector
         ep=poli%xyz_vertex(i,:)-xyz_sphere(nsp,:)
         ep=ep/sqrt(dot_product(ep,ep))

         i1=poli%bounds(i,1)
         i2=poli%bounds(i,2)

         vbuf=vector_product(vn(i,:),vns(i1,:))
         no=vbuf/sqrt(dot_product(vbuf,vbuf))

         vbuf=vector_product(vns(i,:),vn(i2,:))
         nos=vbuf/sqrt(dot_product(vbuf,vbuf))

         b_cut=.false.
         if(poli%n_sphere(i,1)/=0) b_cut=.true.
         bs_cut=.false.
         if(poli%n_sphere(i,2)/=0) bs_cut=.true.

         if(b_cut) then
            dik=xyz_sphere(poli%n_sphere(i,1),:)-xyz_sphere(nsp,:)
            dist1=sqrt(dot_product(dik,dik))
            if(dot_product(no,dik)<0.0_r8_kind) no=-no
         endif
         if(bs_cut) then
            diks=xyz_sphere(poli%n_sphere(i,2),:)-xyz_sphere(nsp,:)
            dist2=sqrt(dot_product(diks,diks))
            if(dot_product(nos,diks)<0.0_r8_kind) nos=-nos
         endif

         ! compute products after prospective sign change!!!
         dpnotns=dot_product(no,tns(i,:))
         dpnostn=dot_product(nos,tn(i,:))
         dpnoep =dot_product(no ,ep)
         dpnosep=dot_product(nos,ep)

         do l=1,N_moving_unique_atoms+N_pc
            if(l <= N_moving_unique_atoms) then
               na=moving_unique_atom_index(l)
               ea=unique_atoms(na)%n_equal_atoms
            else
               na=l-N_moving_unique_atoms
               ea=pointcharge_array(na)%N_equal_charges
            end if
            do l1=1,ea
               do j=1,3
                  dTc(:)=0.0_r8_kind
                  dTcs(:)=0.0_r8_kind
                  dno=0.0_r8_kind
                  dnos=0.0_r8_kind
	
                  !calculate dno and dnos
                  !calculate dTc and dTcs
                  if(b_cut) then
                     do k=1,3
                        vbuf(k)= cagr%dc(k,poli%n_sphere(i,1))%xyz_grad(j,l,l1) -&
                             cagr%dc(k,nsp)%xyz_grad(j,l,l1)
                     enddo
		   
                     help1=dot_product(dik,vbuf)
                     dno=vbuf/dist1-help1* dik/dist1**3

                     help=(r_sphere(nsp)**2- &
                          r_sphere(poli%n_sphere(i,1))**2)/dist1**2
                     dTc(:)=0.5_r8_kind*(1.0_r8_kind+help)*vbuf + &
                          dik*(r_sphere(nsp)*cagr%dR(nsp)%xyz_grad(j,l,l1)-  &
                          r_sphere(poli%n_sphere(i,1)) *		&
                          cagr%dR(poli%n_sphere(i,1))%xyz_grad(j,l,l1)  &
                          -help1*help)/dist1**2
                  endif
                  if(bs_cut) then
                     do k=1,3
                        vbuf(k)= cagr%dc(k,poli%n_sphere(i,2))%xyz_grad(j,l,l1)-&
                             cagr%dc(k,nsp)%xyz_grad(j,l,l1)
                     enddo
		   
                     help1=dot_product(diks,vbuf)
                     dnos=vbuf/dist2-help1* diks/dist2**3
                  
                     help=(r_sphere(nsp)**2- &
                          r_sphere(poli%n_sphere(i,2))**2)/dist2**2
                     dTcs(:)=0.5_r8_kind*(1.0_r8_kind+help)*vbuf + &
                          diks*(r_sphere(nsp)*cagr%dR(nsp)%xyz_grad(j,l,l1)-  &
                          r_sphere(poli%n_sphere(i,2))*               &
                          cagr%dR(poli%n_sphere(i,2))%xyz_grad(j,l,l1)  -   &
                          help1*help)/dist2**2
                  endif

                  if(.not.extra_point(i)) then
                    mus=(dot_product(no,dTc(:))-			&
                       dot_product(dno,vn(i,:)) -  			&
                       dpnoep*cagr%dR(nsp)%xyz_grad(j,l,l1))/dpnotns
                    mu=(dot_product(nos,dTcs(:))-			&
                       dot_product(dnos,vns(i,:)) -			&
                       dpnosep*cagr%dR(nsp)%xyz_grad(j,l,l1))/dpnostn

                    dP(:)= ep * cagr%dR(nsp)%xyz_grad(j,l,l1)+ &
                       tn(i,:) * mu + tns(i,:) *mus                          
                  else
                    vbuf=vector_product(ep,tn(i,:))
                    mu=(dot_product(no,dTc(:))-&
                       dot_product(dno,vn(i,:)) - &
                       dpnoep*cagr%dR(nsp)%xyz_grad(j,l,l1))/&
			  dot_product(no,vbuf)
                    dP(:)= ep * cagr%dR(nsp)%xyz_grad(j,l,l1) + &
 		       vbuf(:) * mu
                  endif

                  do k=1,3
                     cgdP(j,l,l1)%m(k,i)=dP(k)
                     if(.not.extra_point(i)) then
                       if(.not. weight_cent) then
                         cagr%dcenter(j,l,l1)%m(k,N_total+1)=dP(k) +&
                          cagr%dcenter(j,l,l1)%m(k,N_total+1)
                       else if(weight_cent_sin) then
                         cagr%dcenter(j,l,l1)%m(k,N_total+1)= &
                             cagr%dcenter(j,l,l1)%m(k,N_total+1)+&
			     dP(k)*(1.0_r8_kind-(dot_product(tn(i,:),tns(i,:)))**2)
                       endif
                     endif

                     cgdv(j,l,l1)%m(k,i)=dP(k)-dTc(k) !! use for recalculating dTc
                     cgdvs(j,l,l1)%m(k,i)=dP(k)-dTcs(k)

                  enddo
                  if(costhn(i)*costhn(i)>small) then
                     do k=1,3 
                        vd(k)= cagr%dc(k,poli%n_sphere(i,1))%xyz_grad(j,l,l1)-&	
                             cagr%dc(k,nsp)%xyz_grad(j,l,l1)
                     enddo
                     cgdcosth(j,l,l1)%m(i)= &
                          deriv_cos(poli%xyz_vertex(i,:)-xyz_sphere(nsp,:),&
                          xyz_sphere(poli%n_sphere(i,1),:)-xyz_sphere(nsp,:),&
                          dP,vd,.false.,.false.)
                  else
                     cgdcosth(j,l,l1)%m(i)= 0.0_r8_kind
                  endif

               enddo
            enddo
         enddo
      enddo

      do i=1,poli%n_vertises
         i1=poli%bounds(i,1)
         i2=poli%bounds(i,2)

         do l=1,N_moving_unique_atoms+N_pc
            if(l <= N_moving_unique_atoms) then
               na=moving_unique_atom_index(l)
               ea=unique_atoms(na)%n_equal_atoms
            else
               na=l-N_moving_unique_atoms
               ea=pointcharge_array(na)%N_equal_charges
            end if
            do l1=1,ea
               do j=1,3

                  vc=cgdv(j,l,l1)%m(:,i)
                  vd=cgdvs(j,l,l1)%m(:,i1)

                  cgdphi(j,l,l1)%m(i)=  deriv_cos(vn(i,:),vns(i1,:),vc,vd,.true.,.false.)
		 
                  if(weight_cent_mass) then
!!!! MF bug fix 12/2001
			 ! recalculate dTc
			 dTc(:)=cgdP(j,l,l1)%m(:,i)-cgdv(j,l,l1)%m(:,i)

                         dp1=phin(i)*0.5_r8_kind
                         tanphi2=tan(dp1)
                         help=dot_product(vn(i,:),vc)/poli%r_bound(i,1)
				!derivative of r_bound(i,1)
                         ep=poli%xyz_bound(i,1:3)-xyz_sphere(nsp,:)
                         epk=vn(i,:)+vns(i1,:)
                         cagr%dcenter(j,l,l1)%m(:,N_total+1)= &
                             cagr%dcenter(j,l,l1)%m(:,N_total+1)+&
			     help*(phin(i)*ep+tanphi2*epk) + & !deriv of r_bound
			     cgdphi(j,l,l1)%m(i)*poli%r_bound(i,1)* &
				(ep+0.5_r8_kind/(cos(dp1)**2)*epk) + &
!!!! MF bug fix 9/2001
!wrong:			     poli%r_bound(i,1)*(phin(i)*dTc(i)+help*(vc+vd))
 			     poli%r_bound(i,1)*(phin(i)*dTc(:)+tanphi2*(vc+vd))
                  endif

                  ! expansion of the double vector product terms ax(bxc)=b(ac)-c(ab)
                  ! and setting (vv) = r_bound**2
                  ! derivative of not normalized tangent
                  dp1=dot_product(vn(i,:),vns(i1,:))
                  tng =vn(i,:)*(dot_product(vn(i,:),vd)+dot_product(vc,vns(i1,:))) &
                       + vc *  dp1                                   &
                       - vd * poli%r_bound(i,1)**2                  &
                       - 2.0_r8_kind * vns(i1,:) * dot_product(vc,vn(i,:))

                  ! norm of double vector product vx(vxv*)
                  help=poli%r_bound(i,1)**2 * &
                       (poli%r_bound(i,1)**4 - dp1**2)
		  if(help<0.0_r8_kind) help=0.0_r8_kind
                  help=sqrt(help)

                  tng=tng/help
                  tng=tng-tn(i,:)*dot_product(tn(i,:),tng)

                  vc=cgdvs(j,l,l1)%m(:,i)
                  vd=cgdv(j,l,l1)%m(:,i2)

                  dp1=dot_product(vns(i,:),vn(i2,:))

                  tnsg=vns(i,:)*(dot_product(vns(i,:),vd)+dot_product(vc,vn(i2,:))) &
                       + vc *  dp1                                  &
                       - vd * poli%r_bound(i,2)**2                  &
                       - 2.0_r8_kind *vn(i2,:)* dot_product(vc,vns(i,:))

                  help=poli%r_bound(i,2)**2 * &
                       (poli%r_bound(i,2)**4 - dp1**2)
		  if(help<0.0_r8_kind) help=0.0_r8_kind
                  help=sqrt(help)
                  tnsg=tnsg/help
                  tnsg=tnsg-tns(i,:)*dot_product(tns(i,:),tnsg)

                  cgdomeg(j,l,l1)%m(i)=-deriv_cos(tn(i,:),tns(i,:),tng,tnsg,.true.,extra_point(i))

                  if(i==1) cagr%darea(j,l,l1)%m(N_total+1) = 2.0_r8_kind * &
                       cagr%dR(nsp)%xyz_grad(j,l,l1) *area / r_sphere(nsp)
                  cagr%darea(j,l,l1)%m(N_total+1)= &
                       cagr%darea(j,l,l1)%m(N_total+1) +&
                       (phin(i)* cgdcosth(j,l,l1)%m(i)    + &
                       costhn(i)* cgdphi(j,l,l1)%m(i)     - &
                       cgdomeg(j,l,l1)%m(i)) *r_sphere(nsp)**2
                  if(weight_cent_sin) then
                      cagr%dcenter(j,l,l1)%m(:,N_total+1)= &
                             cagr%dcenter(j,l,l1)%m(:,N_total+1)-&
			     (poli%xyz_vertex(i,:)-xyz_sphere(nsp,:))*2.0_r8_kind*( &
				dot_product(tn(i,:),tnsg(:))+ &
                                dot_product(tng(:),tns(i,:)))
                  endif
               enddo
            enddo
         enddo
      enddo

!     now terms because of the scaling of the center to the sphere surface     
!
!     ep=0.0_r8_kind
!     help=1.0_r8_kind
!     do i=1,poli%n_vertises
!        if(.not. extra_point(i)) then
!           if(weight_cent_sin) help=1.0_r8_kind-(dot_product(tn(i,:),tns(i,:)))**2
!           ep=ep+(poli%xyz_vertex(i,:)-xyz_sphere(nsp,:))*help
!        endif
!     enddo
      !representative point before scaling to sphere surface
      ep=(xyz_cent-xyz_sphere(nsp,:))*cent_f

      help=sqrt(dot_product(ep,ep))

      do l=1,N_moving_unique_atoms+N_pc
         if(l <= N_moving_unique_atoms) then
            na=moving_unique_atom_index(l)
            ea=unique_atoms(na)%n_equal_atoms
         else
            na=l-N_moving_unique_atoms
            ea=pointcharge_array(na)%N_equal_charges
         end if
         do l1=1,ea
            do j=1,3
             if(.not.orig_cent) then
               do k=1,3
                  vd(k)=cagr%dcenter(j,l,l1)%m(k,N_total+1)
               enddo
               vc=vd/help-ep*dot_product(ep,vd)/help**3
               do k=1,3
                  cagr%dcenter(j,l,l1)%m(k,N_total+1)= vc(k)*r_sphere(nsp) + &
                       cagr%dc(k,nsp)%xyz_grad(j,l,l1) + &
                       ep(k)/help*cagr%dR(nsp)%xyz_grad(j,l,l1) 
               enddo
             else if(orig_cent) then !orig_cent
	       do k=1,3
                  cagr%dcenter(j,l,l1)%m(k,N_total+1) = &
                       cagr%dc(k,nsp)%xyz_grad(j,l,l1) + &
                       (xyz_cent(k) - xyz_sphere(nsp,k))* &
                       cagr%dR(nsp)%xyz_grad(j,l,l1)/r_sphere(nsp)    
               enddo
             endif
            enddo
         enddo
      enddo

      do i=1,N_moving_unique_atoms+N_pc
         if(i <= N_moving_unique_atoms) then
            na=moving_unique_atom_index(i)
            ea=unique_atoms(na)%n_equal_atoms
         else
            na=i-N_moving_unique_atoms
            ea=pointcharge_array(na)%N_equal_charges
         end if
         do l=1,ea
            do j=1,3
               deallocate(cgdP(j,i,l)%m,stat=status)
               if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang1")
               deallocate(cgdv(j,i,l)%m,stat=status)
               if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang2")
               deallocate(cgdvs(j,i,l)%m,stat=status)
               if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang3")
               deallocate(cgdomeg(j,i,l)%m,stat=status)
               if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang4")
               deallocate(cgdcosth(j,i,l)%m,stat=status)
               if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang5")
               deallocate(cgdphi(j,i,l)%m,stat=status)
               if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang6")
            enddo
         enddo
      enddo

      deallocate(cgdP,stat=status)
      if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang7")
      deallocate(cgdv,stat=status)
      if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang8")
      deallocate(cgdvs,stat=status)
      if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang9")
      deallocate(cgdomeg,stat=status)
      if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang10")
      deallocate(cgdcosth,stat=status)
      if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang11")
      deallocate(cgdphi,stat=status)
      if(status/=0) call error_handler("dealloc fail geom_grad_cutted_triang12")
      

    end subroutine geom_grad_cutted_triang
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine geom_grad_orig_triang(nsp,area,xyz_cent)
      !gradients of non cutted surface triangles
      !** End of interface *****************************************
      integer(kind=i4_kind) :: l,j,k,l1,na,ea
      integer(kind=i4_kind) , intent(in):: nsp
      real(kind=r8_kind) , intent(in):: area,xyz_cent(3)
      integer :: N_pc

      N_pc=0
!!$      if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
      if(with_pc) N_pc=pointcharge_N
 
      do l=1,N_moving_unique_atoms+N_pc
         if(l <= N_moving_unique_atoms) then
            na=moving_unique_atom_index(l)
            ea=unique_atoms(na)%n_equal_atoms
         else
            na=l-N_moving_unique_atoms
            ea=pointcharge_array(na)%N_equal_charges
         end if
         do l1=1,ea
            do j=1,3
               cagr%darea(j,l,l1)%m(N_total+1) = 2.0_r8_kind * area * &
                    cagr%dR(nsp)%xyz_grad(j,l,l1) / r_sphere(nsp)		
               do k=1,3
                    !also valid for weight_cent_sin and weight_cent_mass
                    !movement only by sphere movement
                    cagr%dcenter(j,l,l1)%m(k,N_total+1) = &
                       cagr%dc(k,nsp)%xyz_grad(j,l,l1) + &
                       (xyz_cent(k) - xyz_sphere(nsp,k))* &
                       cagr%dR(nsp)%xyz_grad(j,l,l1)/r_sphere(nsp)
               enddo
            enddo
         enddo
      enddo

    end subroutine geom_grad_orig_triang
    !------------------------------------------------------------

    !------------------------------------------------------------
    function deriv_cos(a,b,da,db,do_acos,extra_p)

     real(kind=r8_kind), dimension(3), intent(in) :: a,b,da,db
     real(kind=r8_kind) :: deriv_cos
     real(kind=r8_kind) :: costh,absa,absb,vbuf(3),sinth
     logical, intent(in) :: do_acos, extra_p
     real(kind=r8_kind), parameter :: small=1.e-9
     ! if do_acos == .true. the derivative of the angle is computed
     ! else the derivative of the cosine of the angle is computed

     ! see formula (31) in Cossi 96
    
     absa= sqrt(dot_product(a,a))
     absb= sqrt(dot_product(b,b))
     costh= dot_product(a,b)
     if(absa>small .and. absb>small) then
   	costh=costh/(absa*absb) 
     	if(do_acos) then
                if(costh**2<1.0_r8_kind) then 
 		   sinth = sqrt(1.0_r8_kind-costh**2)
                else  
                   sinth = 0.0_r8_kind !sign(max(small,abs(sinth)),sinth) !0.0_r8_kind
                endif 
		if(sinth<small .and. .not. extra_p) then 
                  ABORT("deriv_cos: angle to small")
                else if (sinth<small) then
			deriv_cos=0.0_r8_kind
			return
                endif
        endif
        vbuf(:)=a(:)-costh*absa/absb* b(:)
        deriv_cos=dot_product(vbuf,db)
        vbuf(:)=b(:)-costh*absb/absa* a(:)
        deriv_cos=deriv_cos+dot_product(vbuf,da)
        deriv_cos=deriv_cos/(absa*absb)
	if(do_acos) deriv_cos = - deriv_cos/sinth
     else 
        deriv_cos=0.0_r8_kind
     endif

    end function deriv_cos
 !!!MF <<<<
    !------------------------------------------------------------

    !------------------------------------------------------------
    subroutine symm_sorted_centers(ret_stat,verbose)
      ! find and sort symmetry equivalent surface tessera,
      ! store in tessarea
      implicit none
      integer(kind=i4_kind), intent(out) :: ret_stat
      logical, intent(in)                :: verbose
      !** End of interface *****************************************

      integer(kind=i4_kind) :: n_equal,n_equal_check
      real(kind=r8_kind)    :: this(3),that(3),cartes(3),check(3)
      type(sub_group) :: local_groups
      type(group_coset) :: cosets
      type(symm_transformation_int), allocatable :: point_trafos_buf(:)
      logical, allocatable :: checked(:)
      type(cavity_data),allocatable :: tessarea_buf(:)

      real(kind=r8_kind),parameter :: small = 1.0e-7_r8_kind
      integer(kind=i4_kind) :: i,n,j,k,status,l

      integer(i4_kind), parameter :: max_num_el = 256
      integer(i4_kind)            :: local_group_el(max_num_el)
      integer(i4_kind)            :: uniq
      real(r8_kind)               :: diff,norma

# define VPRINT if(verbose) print *,

      FPP_TIMER_DECL(tot)
      FPP_TIMER_DECL(prep)
      FPP_TIMER_DECL(cmp)

      VPRINT 'symm_sorted_centers: entered'
      FPP_TIMER_START(tot)

      ret_stat = 0

      allocate(checked(N_total),point_trafos_buf(N_total),stat=status)
      ASSERT(status==0)
      checked=.false.

      allocate(tessarea_buf(N_total),stat=status)
      ASSERT(status==0)

      if(do_gradients) then
         DPRINT 'symm_sorted_centers: allocate(i_symm_sort)'
         allocate(i_symm_sort(N_total,group_num_el),stat=status)
         ASSERT(status==0)
      endif

      VPRINT 'total=',n_total
      uniq=0
      l=0
      i_N_total: do i=1,N_total
         if(checked(i)) cycle
            VPRINT 'i=',i
            FPP_TIMER_START(prep)
            ! hopefully one more Stuek surface:
            uniq = uniq + 1
            ! reorder coordinates of points as
            ! (x,y,z) --> (x,z,y) in order to comply with the 
            ! convention for angular momentum l=1
            this(1) = xyz_tes_c(i,1)
            this(2) = xyz_tes_c(i,3)
            this(3) = xyz_tes_c(i,2)
!!$            call normalize(this)
            !
            ! determine local symmetry groups
            !
            ! now apply all symmetry operations to the position of the 
            ! surface point
            norma = max(norm(this),1.0_r8_kind)
            n = 0
            do j=1,group_num_el
               that = MATMUL(ylm_trafos(1)%matrix(:,:,j),this)
               VPRINT '1) this=',this
               VPRINT '1) that=',that
!!$               diff = dot_product(that-this,that-this)
               diff  = norm(that-this)
               if (diff < small*norma ) then
                  VPRINT '1) that==this: diff=',diff,'norma=',norma
                  n = n+1
                  ASSERT(n<=max_num_el)
                  local_group_el(n) = j
               else
                  VPRINT '1) that/=this: diff=',diff,'norma=',norma
               endif
            enddo

            ! allocate group elements
            local_groups%num_el = n
            allocate(local_groups%elements(n))
            ASSERT(status==0)
            ! and fill up group elements
            local_groups%elements(:) = local_group_el(:n)

            !
            ! now determine symmetry equivalent atoms 
            ! 

            call group_coset_decomp(n_equal,local_groups,&
                 cosets,point_trafos_buf(uniq)%matrix)

             VPRINT 'n_equal=',n_equal


            ! search of positions of equal atoms

            allocate(tessarea_buf(uniq)%xyz(n_equal,3), &
                 tessarea_buf(uniq)%sphere(n_equal), stat=status)
            ASSERT(status==0)

            FPP_TIMER_STOP(prep)
            FPP_TIMER_START(cmp)

            n_equal_check=0
            j_n_equal: do j=1,n_equal
               that = MATMUL(ylm_trafos(1)%matrix(:,:,cosets%elements(1,j)),this)
               cartes(1) = that(1)
               cartes(2) = that(3)
               cartes(3) = that(2)
               k_N_total: do k=1,N_total
                  if(.not.checked(k)) then
!!$                     if (sqrt(dot_product(cartes-xyz_tes_c(k,:), &
!!$                          cartes-xyz_tes_c(k,:))) <= small*10.0_r8_kind) then
!!$                     if (dot_product(cartes-xyz_tes_c(k,:), &
!!$                          cartes-xyz_tes_c(k,:)) <= small*10.0_r8_kind) then
                     check = xyz_tes_c(k,:)
                     VPRINT '2) that  =',cartes,'(',i,j,')'
                     VPRINT '2) check =',check,'(',k,')'
!!$                     diff = dot_product(cartes-check,cartes-check)
                     diff = norm(cartes-check)
                     if (diff < small*norma) then
                        VPRINT '2) that==check: diff=',diff,'norma=',norma
                        checked(k) = .true.
                        n_equal_check = n_equal_check + 1
                        l=l+1
                        tessarea_buf(uniq)%xyz(j,:)  = xyz_tes_c(k,:)
                        tessarea_buf(uniq)%area      = area_tes(k)
                        tessarea_buf(uniq)%r_tes     = r_tes(k)
                        tessarea_buf(uniq)%sphere(j) = sphere(k)
                        tessarea_buf(uniq)%n_equal   = n_equal
!!$                        tessarea_buf(uniq)%tessar_data(j)=data_tes(k)
                        tessarea_buf(uniq)%cut_off   = cuttt(k)

			if(do_gradients) then
                           i_symm_sort(uniq,j)=k
                        endif
                     else
                        VPRINT '2) that/=check: diff=',diff,'norma=',norma
                     endif
                  endif
               enddo k_N_total
            enddo j_n_equal
            if (n_equal_check /= n_equal) then 
		print *,'failure at tes/area/cut',i,area_tes(i),cuttt(i)
                print *,'n_equal=',n_equal
                print *,'n_equal_check=',n_equal_check
                print *,'count(.not.checked)=',count(.not.checked)
                ret_stat = 1
		call error_handler( &
!!$                print *,&
                 "The program has calculated more equivalent points than &
                 & it had been able to find on the cavity surface. Who fib from us? &
                 & I do not know")
                print *, 'retrying...'
            endif
            deallocate(local_groups%elements, stat=status)
            ASSERT(status==0)
            if(ret_stat/=0) goto 1001 ! cleanup and return error
      enddo i_N_total
      FPP_TIMER_STOP(cmp)

      ! set the global var:
      n_size = uniq
      print *,'solv::symm_sorted_centers: uniq=',n_size,' total=',n_total

      allocate(tessarea(n_size),stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation TESSAREA is failed")

      do i=1,n_size
         tessarea(i)%n_equal=tessarea_buf(i)%n_equal
         tessarea(i)%area=tessarea_buf(i)%area
         tessarea(i)%r_tes=tessarea_buf(i)%r_tes
         tessarea(i)%cut_off=tessarea_buf(i)%cut_off

         allocate(tessarea(i)%xyz(tessarea(i)%n_equal,3), &
              tessarea(i)%sphere(tessarea(i)%n_equal), stat=status)
         ASSERT(status==0)

         tessarea(i)%xyz    = tessarea_buf(i)%xyz
         tessarea(i)%sphere = tessarea_buf(i)%sphere

!!$         deallocate(tessarea_buf(i)%xyz, &
!!$              tessarea_buf(i)%sphere, stat=status)
!!$         ASSERT(status==0)
      enddo

      if(output_cavity_data .and. .not.do_gradients) then
         write (output_unit,*) '--------------------------------------------------------------'
         write (output_unit,*) &
              'The symmetrization of surface points has been done succesfully, number of unique points:', &
              n_size
         if(output_cavity_long) then
           write(output_unit,*)'number n_equal                  coordinates(a.u.)               area'
           do i=1,n_size
            write(output_unit,'(1x,i4,2x,i4,3x,3(f13.9,1x),f14.9)') i,tessarea(i)%n_equal, &
                 tessarea(i)%xyz(1,:),tessarea(i)%area
           enddo
          endif
         write(output_unit,*) '---------------------------------------------------------------'
      endif

      do i=1,n_size
         if(tessarea(i)%area <= 0.0_r8_kind)  then 
            call write_to_output_units("---------------------------------------------------------")
            call write_to_output_units("because  of  some  tessarea  have  very  small  size  the")
            call write_to_output_units("calculating   areas   of  such  surface   elements   give")
            call write_to_output_units("unstable  results. Sometimes  the  value of area  can  be")
            call write_to_output_units("equal ZERO or  even be NEGATIVE. To  continue  your  work")
            call write_to_output_units("You should  either change  SCALED-FACTOR  to use  another")
            call write_to_output_units("size  of cavity  or choose  another  POINT-FACTOR to  use")
            call write_to_output_units("different number  of surface point  or if is possible  of")
            call write_to_output_units("course change symmetry of system to take another type  of")
            call write_to_output_units("poligone inscribed  to each sphere.  Sorry  unconvinient.")
            call write_to_output_units("---------------------------------------------------------")
            call error_handler("symm_sorted_centers: bad area. See description and output file!")
         endif
      enddo

      deallocate(xyz_tes_c, &
           area_tes, &
           r_tes, &
           sphere, &
           cuttt, &
           data_tes, stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: deallocation xyz_tes_c, area_tes, r_tes are failed")

      if(do_correction .and. .not. do_gradients) then
         allocate(point_trafos(n_size),  stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of point_trafos is failed")
         do i=1,n_size
            n_equal=tessarea(i)%n_equal
            allocate(point_trafos(i)%matrix(n_equal,n_equal,group_num_el), stat=status)
            if ( status /= 0) call error_handler( &
                 "points_on_cavity_surface: allocation of point_trafos%matix is failed")

            point_trafos(i)%matrix=point_trafos_buf(i)%matrix

            deallocate(point_trafos_buf(i)%matrix, stat=status)
            if ( status /= 0) call error_handler( &
                 "points_on_cavity_surface: deallocation of point_trafos_buf%matrix is failed")
         enddo

         deallocate(point_trafos_buf, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of point_trafos_buf is failed")

         allocate(unique_surf_points(n_size),  stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: allocation of unique_surf_charges failed")

         do i=1,n_size
            unique_surf_points(i)%N_equal_atoms=tessarea(i)%n_equal
            allocate(unique_surf_points(i)%position(3,tessarea(i)%n_equal),  stat=status)
            if ( status /= 0) call error_handler( &
                 "points_on_cavity_surface: allocation of unique_surf_points%position failed")
            do j=1,tessarea(i)%n_equal
               unique_surf_points(i)%position(:,j)=tessarea(i)%xyz(j,:)
               unique_surf_points(i)%lmax_all=1
            enddo
         enddo

!!$         call error_handler("solvation: need symm_symmadapt_charges() sub!")
         DPRINT 'solv::points_on_cavity_surface: call   symm_adapt_centers(...)'
         call symm_adapt_centers(unique_surf_points, point_trafos, L_MAX=1)
         DPRINT 'solv::points_on_cavity_surface: return symm_adapt_charges(...)'

         do i=1,n_size
            deallocate(point_trafos(i)%matrix, stat=status)
            if ( status /= 0) call error_handler( &
                 "points_on_cavity_surface: deallocation point_trafos%matix is failed")
         enddo
         deallocate(point_trafos, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation point_trafos is failed")
      else
         do i=1,n_size
            deallocate(point_trafos_buf(i)%matrix, stat=status)
            if ( status /= 0) call error_handler( &
                 "points_on_cavity_surface: deallocation of point_trafos_buf%matrix is failed(1)")
         enddo
         deallocate(point_trafos_buf, stat=status)
         if ( status /= 0) call error_handler( &
              "points_on_cavity_surface: deallocation of point_trafos_buf is failed(1)")
      endif

1001  continue ! exeption enters here:

      do i=1,uniq ! could be less than n_size
         deallocate(&
              & tessarea_buf(i)%xyz, &
              & tessarea_buf(i)%sphere, &
              & stat=status)
         ASSERT(status==0)
      enddo
         
      deallocate(tessarea_buf,stat=status)
      ASSERT(status==0)
      deallocate(checked,stat=status)
      ASSERT(status==0)

      if(do_gradients.and.ret_stat/=0) then
         deallocate(i_symm_sort, stat=status)
         ASSERT(status==0)
      endif

      FPP_TIMER_STOP(tot)
      FPP_TIMER_PRINT(tot)
      FPP_TIMER_PRINT(prep)
      FPP_TIMER_PRINT(cmp)

    end subroutine symm_sorted_centers
    !--------------------------------------------------------
    
    real(r8_kind) function norm(x)
      implicit none
      real(r8_kind), intent(in) :: x(3)
      ! *** end of interface ***

      norm = sqrt(x(1)**2 + x(2)**2 + x(3)**2)
    end function norm

    !--------------------------------------------------------
    subroutine matrix_generation
      !generate the "interaction" matrix of charged surface areas
      !inverse = matrix for calculating the induced surface charge from the
      !molecule potential on the surface
      !** End of interface *****************************************

      integer(kind=i4_kind) :: i,j,k,l,status
      integer(kind=i4_kind) :: first_index,second_index,first_equal,second_equal
      real(kind=r8_kind) :: distance,A_matrix_fs
      real(kind=r8_kind) :: vect(3),tt

      ! generating direct matrix A for the main COSMO equation
!     allocate(A_matrix(N_total,N_total),stat=status)
      allocate(A_matrix_inv(n_size,n_size),stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of A_MATRIX is failed")

!     first_index=0
!     i_n_size: do i=1,n_size
!        first_equal=tessarea(i)%n_equal
!        j_first_equal: do j=1,first_equal
!           first_index=first_index+1
!           second_index=0
!           k_n_size: do k=1,n_size
!              second_equal=tessarea(k)%n_equal
!              l_second_equal: do l=1,second_equal
!                 second_index=second_index+1
!
!                 f_s: if (first_index==second_index) then
!                    A_matrix(first_index,second_index)= &
!                         1.07_r8_kind*sqrt(4.0_r8_kind*pi/tessarea(i)%area)
!                 else
!                    vect=tessarea(i)%xyz(j,:)-tessarea(k)%xyz(l,:)
!                    distance=sqrt(dot_product(vect,vect))
!                    A_matrix(first_index,second_index)= 1.0_r8_kind/distance 
!
!                 endif f_s
!              enddo l_second_equal
!           enddo k_n_size
!        enddo j_first_equal
!     enddo i_n_size

!!$call cpu_time(tt)
!!$print*,tt
      first_index=1
      do i=1,n_size
         first_equal=tessarea(i)%n_equal
         second_index=1
         do k=1,n_size
            second_equal=tessarea(k)%n_equal
            A_matrix_inv(i,k)=0.0_r8_kind
            do l=1,second_equal
                  f_s: if (first_index==second_index) then
                     A_matrix_fs= &
                          1.07_r8_kind*sqrt(4.0_r8_kind*pi/tessarea(i)%area)
                  else
                     vect=tessarea(i)%xyz(1,:)-tessarea(k)%xyz(l,:)
                     distance=sqrt(dot_product(vect,vect))
                     A_matrix_fs= 1.0_r8_kind/distance 
 
                  endif f_s
                  A_matrix_inv(i,k)=A_matrix_inv(i,k)+ &
			A_matrix_fs
               second_index=second_index+1
            enddo
          enddo
          first_index=first_index+first_equal
      enddo
!!$print*,sum(A_matrix_inv(:,:))


!     call contract_matrix
!!$call cpu_time(tt)
!!$print*,tt

      call invert_matrix(n_size,A_matrix_inv)
!!$call cpu_time(tt)
!!$print*,tt

!     deallocate(A_matrix,stat=status)
!     if ( status /= 0) call error_handler( &
!          "points_on_cavity_surface: deallocation of A_MATRIX is failed")


    end subroutine matrix_generation
    !---------------------------------------------------------
    subroutine contract_matrix
      ! sum matrix elements concerning equivalent space points
      integer(kind=i4_kind) :: i,k,l,status
      integer(kind=i4_kind) :: first_index,second_index,first_equal,second_equal

      allocate(A_matrix_inv(n_size,n_size),stat=status)
      if ( status /= 0) call error_handler( &
           "points_on_cavity_surface: allocation of A_MATRIX_INV is failed")

      first_index=1
      do i=1,n_size
         first_equal=tessarea(i)%n_equal
         second_index=1
         do k=1,n_size
            second_equal=tessarea(k)%n_equal
            A_matrix_inv(i,k)=0.0_r8_kind
            do l=1,second_equal
               A_matrix_inv(i,k)=A_matrix_inv(i,k)+ &
			A_matrix(first_index,second_index)
               second_index=second_index+1
            enddo
          enddo
          first_index=first_index+first_equal
      enddo
      
    end subroutine contract_matrix

  end subroutine points_on_cavity_surface
  !****************************************************

  !****************************************************
!!$  subroutine send_receive_cavity_matrix
!!$
!!$    use commpack_module
!!$    use comm_module
!!$    use msgtag_module
!!$
!!$    integer(kind=i4_kind) :: info,status
!!$
!!$    if(comm_i_am_master()) then
!!$       call comm_init_send(comm_all_slave_hosts,msgtag_cavity_matrix)
!!$
!!$       call commpack(dielectric_constant,info)
!!$       if( info.ne.0) call error_handler &
!!$            ("send_receive_cavity_matrix: dielectric_constant pack failed")
!!$
!!$       call commpack(N_total,info)
!!$       if( info.ne.0) call error_handler &
!!$            ("send_receive_cavity_matrix: N_total pack failed")
!!$
!!$       call commpack(A_matrix_inv(1,1),N_total*N_total,1,info)
!!$       if( info.ne.0) call error_handler &
!!$            ("send_receive_cavity_matrix: A_matrix_inv pack failed")
!!$       call comm_send()
!!$    else
!!$
!!$       call communpack(dielectric_constant,info)
!!$       if( info.ne.0) call error_handler &
!!$            ("send_receive_cavity_matrix: dielectric_constant unpack failed")
!!$
!!$       call communpack(N_total,info)
!!$       if( info.ne.0) call error_handler &
!!$            ("send_receive_cavity_matrix: N_total unpack failed")
!!$
!!$       allocate(A_matrix_inv(N_total,N_total),stat=status)
!!$       if ( status /= 0) call error_handler( &
!!$            "send_receive_cavity_matrix: allocation of A_MATRIX_INV is failed")
!!$
!!$       call communpack(A_matrix_inv(1,1),N_total*N_total,1,info)
!!$       if( info.ne.0) call error_handler &
!!$            ("send_receive_cavity_matrix: A_matrix_inv unpack failed")
!!$
!!$    endif
!!$
!!$  end subroutine send_receive_cavity_matrix
  !***************************************************

  !***************************************************
  subroutine dealloc_A_inv
   ! deallocates the inverse of the cavity matrix A
   ! (A_inv is needed to calculate the induced surface charges)
   !** End of interface *****************************************
    integer(kind=i4_kind) :: status

    deallocate(A_matrix_inv,stat=status)
    if ( status /= 0) call error_handler( &
         "dealloc_A_inv: deallocation of A_MATRIX_INV is failed")
      
  end subroutine dealloc_A_inv
  !***************************************************

  !***************************************************
  subroutine matrix_grad(grad_index)
    !gradient of the cavity matrix A
    use unique_atom_module
    use pointcharge_module
    use elec_static_field_module
    use comm_module, only: comm_get_n_processors,comm_myindex
    implicit none
    integer(kind=i4_kind), intent(in) :: grad_index(N_moving_unique_atoms + 1)
    !** End of interface *****************************************

    integer(kind=i4_kind) :: i,i1,j,k,l,m,ng,ng1,lg,na,ea
    integer(kind=i4_kind) :: first_index,second_index,first_equal,second_equal
    real(kind=r8_kind) :: distance,help,eps_help,help_d
    real(kind=r8_kind) :: vect(3),gradient(3),Qi,Qk,tt
    real(kind=r8_kind),pointer  :: rotmat(:,:)
    integer(kind=i4_kind) :: index,grad_dim,N_pc
    integer(i4_kind) :: n_proc,my_index,N_species,n_start,n_length

    eps_help=to_calc_grads%dielconst/(2.0_r8_kind*(to_calc_grads%dielconst-1.0_r8_kind))

    N_pc=0
    if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N

    DPRINT 'matrix_grad: entered'
    DPRINT 'matrix_grad: grad_index=',grad_index

    N_species=N_moving_unique_atoms+N_pc
    n_proc=comm_get_n_processors()
    my_index=comm_myindex()
    n_start=1
    n_length=0
    do i=1,my_index
       n_start=n_start+n_length
       N_species=N_species-n_length
       n_length=int(N_species/n_proc)
       n_proc=n_proc-1
    end do

    if(n_length == 0) return
!!$call cpu_time(tt)
!!$print*,tt
    ng_N: do ng=n_start,n_start+n_length-1
       if(ng <= N_moving_unique_atoms) then
          na = moving_unique_atom_index(ng)
          ea = unique_atoms(na)%n_equal_atoms
       else
          na=ng-N_moving_unique_atoms
          ea=pointcharge_array(na)%N_equal_charges
       end if
!!$       m_ea: do m=1,ea
          first_index=0
          i_n_size: do i=1,to_calc_grads%n_points
             first_equal=to_calc_grads%n_equal(i)

             Qi=to_calc_grads%Q(i)
             help_d=-1.07_r8_kind*Qi*Qi*sqrt(pi/to_calc_grads%s(i))/&
                  to_calc_grads%s(i)

             j_first_equal: do j=1,first_equal
                first_index=first_index+1

                second_index=0
                k_n_size: do k=1,to_calc_grads%n_points
                   second_equal=to_calc_grads%n_equal(k)

                   Qk=to_calc_grads%Q(k)

                   l_second_equal: do l=1,second_equal
                      second_index=second_index+1
                      if(second_index < first_index) cycle l_second_equal
                      f_s: if (first_index==second_index) then
                         if(ng <= N_moving_unique_atoms) then
                            grad_dim=grad_index(ng+1)-grad_index(ng)
                            index=grad_index(ng)
                            do i1=1,grad_dim
                               grad_solv_totsym(index)=grad_solv_totsym(index) + &
                                    help_d*eps_help* &
                                    to_calc_grads%ds_totsyms(i1,ng)%m(to_calc_grads%i_symm_sort(i,j))
                               index=index+1
                            end do
                         else
                            ng1=ng-N_moving_unique_atoms
                            grad_dim=surf_points_grad_index(ng1+1)-surf_points_grad_index(ng1)
                            index=surf_points_grad_index(ng1)
                            do i1=1,grad_dim
                               totalsym_field(index)=totalsym_field(index) - &
                                    help_d*eps_help* &
                                    to_calc_grads%ds_totsyms(i1,ng)%m(to_calc_grads%i_symm_sort(i,j))
                               index=index+1
                            end do
                         end if
                      else
                         vect=to_calc_grads%xyz(i,j,:)-to_calc_grads%xyz(k,l,:)
                         distance=sqrt(dot_product(vect,vect))
                         help=-1.0_r8_kind/distance**3
                         if(ng <= N_moving_unique_atoms) then
                            grad_dim=grad_index(ng+1)-grad_index(ng)
                            index=grad_index(ng)
                            do i1=1,grad_dim
                               grad_solv_totsym(index)=grad_solv_totsym(index) + & 
                                    help*2.0_r8_kind*eps_help*Qi*Qk* &
                                    dot_product(vect, &
                                    to_calc_grads%dxyz_totsyms(i1,ng)%m(:,to_calc_grads%i_symm_sort(i,j))- &
                                    to_calc_grads%dxyz_totsyms(i1,ng)%m(:,to_calc_grads%i_symm_sort(k,l)))
                               index=index+1
                            end do
                         else
                            ng1=ng-N_moving_unique_atoms
                            grad_dim=surf_points_grad_index(ng1+1)-surf_points_grad_index(ng1)
                            index=surf_points_grad_index(ng1)
                            do i1=1,grad_dim
                               totalsym_field(index)=totalsym_field(index) - &
                                    help*2.0_r8_kind*eps_help*Qi*Qk* &
                                    dot_product(vect, &
                                    to_calc_grads%dxyz_totsyms(i1,ng)%m(:,to_calc_grads%i_symm_sort(i,j))- &
                                    to_calc_grads%dxyz_totsyms(i1,ng)%m(:,to_calc_grads%i_symm_sort(k,l)))
                               index=index+1
                            end do
                         end if
                      endif f_s         
                   enddo l_second_equal
                enddo k_n_size
             enddo j_first_equal
          enddo i_n_size
!!$       enddo m_ea
    enddo ng_N
!!$call cpu_time(tt)
!!$print*,tt

  end subroutine matrix_grad
  !***************************************************

  !***************************************************
  subroutine solv_poten_transfer_data
   !** End of interface *****************************************

    use potential_module, only: N_points,point_in_space

    integer(kind=i4_kind) :: status
    integer(kind=i4_kind) :: i,j
    N_points=n_size

    allocate(point_in_space(N_points),stat=status)
    if ( status /= 0) call error_handler( &
         "solv_poten_transfer_data: allocation of point_in_space is failed")

    do i=1,N_points
       point_in_space(i)%N_equal_points=tessarea(i)%n_equal
       allocate(point_in_space(i)%position(3,point_in_space(i)%N_equal_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "solv_poten_transfer_data: allocation of point_in_space%N_equal_points is failed")
       do j=1,point_in_space(i)%N_equal_points
          point_in_space(i)%position(:,j)=tessarea(i)%xyz(j,:)
       enddo

       point_in_space(i)%position_first_ep(:)=tessarea(i)%xyz(1,:)
    enddo

    call dealloc_cavity()

  end subroutine solv_poten_transfer_data
  !******************************************************

  !************************************************************
  subroutine dealloc_geom_deriv_part1(cagr)
    ! dealloc dR and dc of cagr
    type(geom_deriv), intent(inout) :: cagr
    !** End of interface *****************************************

    integer(kind=i4_kind) :: i,alloc_stat,j

    DPRINT '_part1: entered, N_spheres=',N_spheres
    DPRINT '_part1: shape(cagr%dR)=',shape(cagr%dR)
    DPRINT '_part1: shape(cagr%dc)=',shape(cagr%dc)
    ASSERT(size(cagr%dR)==n_spheres)
    ASSERT(size(cagr%dc,2)==n_spheres)
    ASSERT(size(cagr%dc,1)==3)
    do i=1,N_spheres !size(cagr%dR)
       deallocate(cagr%dR(i)%xyz_grad,&
            stat=alloc_stat)
       if ( alloc_stat /= 0) call error_handler( &
            "dealloc_geom_deriv_part: deallocation of xyz_grad is failed")
       do j=1,3
          DPRINT '_part1:',i,j,associated(cagr%dc(j,i)%xyz_grad)
          deallocate(cagr%dc(j,i)%xyz_grad,&
               stat=alloc_stat)
          if ( alloc_stat /= 0) call error_handler( &
               "dealloc_geom_deriv_part: deallocation of xyz_grad is failed")
       enddo
    enddo
    deallocate(cagr%dR,stat=alloc_stat)
    if ( alloc_stat /= 0) call error_handler( &
         "dealloc_geom_deriv_part: deallocation of grad_atomic_center failed")
    deallocate(cagr%dc,stat=alloc_stat)
    if ( alloc_stat /= 0) call error_handler( &
         "dealloc_geom_deriv_part: deallocation of grad_atomic_center failed")

  end subroutine dealloc_geom_deriv_part1
  !************************************************************

  !******************************************************
  subroutine dealloc_geom_deriv_part2
   !dealloc darea,dcenter of cagr
   !** End of interface *****************************************

    use unique_atom_module, only : N_moving_unique_atoms,unique_atoms,moving_unique_atom_index
    use pointcharge_module, only : pointcharge_array, pointcharge_N

    integer(kind=i4_kind) :: status,N_pc
    integer(kind=i4_kind) :: i,j,l,na,ea

    N_pc=0
    if(with_pc) N_pc=pointcharge_N

    do i=1,N_moving_unique_atoms+N_pc
       if(i <= N_moving_unique_atoms) then
          na = moving_unique_atom_index(i)
          ea = unique_atoms(na)%n_equal_atoms
       else
          na=i-N_moving_unique_atoms
          ea=pointcharge_array(na)%N_equal_charges
       end if
       do l=1,ea
          do j=1,3
             deallocate(cagr%dcenter(j,i,l)%m, &
                  cagr%darea(j,i,l)%m,stat=status)
             if ( status /= 0) call error_handler( &
                  "dealloc_geom_deriv_part2: deallocation of cagr%dcenter%m is failed")
          enddo
       enddo
    enddo

    deallocate(cagr%dcenter,cagr%darea,stat=status)
    if ( status /= 0) call error_handler( &
         "dealloc_geom_deriv_part2: deallocation of cagr%dcenter is failed")

    deallocate(i_symm_sort,stat=status)
    if ( status /= 0) call error_handler( &
         "dealloc_geom_deriv_part2: deallocation of i_symm_sort is failed")

  end subroutine dealloc_geom_deriv_part2
  !*****************************************************

  !***************************************************
  subroutine send_receive_geom_grad(grad_index)
   !** End of interface *****************************************

    use group_module, only : group_num_el
    use unique_atom_module, only: N_moving_unique_atoms,unique_atoms,moving_unique_atom_index, &
         unique_atom_grad_info
    use elec_static_field_module, only: surf_points_grad_index,surf_points_grad_info
    use pointcharge_module, only: pointcharge_N,pointcharge_array
    use comm_module
    use commpack_module
    use msgtag_module, only: msgtag_geom_grad
    implicit none
    integer(kind=i4_kind), intent(in),optional:: grad_index(N_moving_unique_atoms + 1)
    integer(kind=i4_kind) :: dim,dim1,status,info,N_pc
    integer(kind=i4_kind) :: i,j,l,na,ea,ma,grad_dim
    real(kind=r8_kind),pointer :: rotmat(:,:) 

    if(comm_i_am_master()) then
       if(.not. present(grad_index)) call error_handler(&
          "send_receive_geom_grad: grad_index missing when master calls")

       to_calc_grads%dielconst=dielectric_constant

       N_pc=0
       if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N

       to_calc_grads%n_points=n_size

       allocate(to_calc_grads%n_equal(to_calc_grads%n_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%n_equal on master failed")
       do i=1,to_calc_grads%n_points
          to_calc_grads%n_equal(i)=tessarea(i)%n_equal
       enddo

       dim=maxval(to_calc_grads%n_equal)
       allocate(to_calc_grads%xyz(to_calc_grads%n_points,dim,3), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%xyz on master failed")

       allocate(to_calc_grads%s(to_calc_grads%n_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%s on master failed")

       do i=1,to_calc_grads%n_points
          to_calc_grads%s(i)=tessarea(i)%area 
          do j=1,to_calc_grads%n_equal(i)  
             to_calc_grads%xyz(i,j,:)=tessarea(i)%xyz(j,:) 
          enddo
       enddo

       allocate(to_calc_grads%Q(to_calc_grads%n_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%Q on master failed")
       do i=1,to_calc_grads%n_points
          to_calc_grads%Q(i)=Q_n(i)+Q_e(i)
       enddo
       call dealloc_Q()
       
       allocate(to_calc_grads%i_symm_sort(N_total,group_num_el), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%i_symm_sort on master failed")
       to_calc_grads%i_symm_sort=i_symm_sort

       allocate(to_calc_grads%dxyz_totsyms(3,N_moving_unique_atoms+N_pc), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%dxyz_totsyms on master failed")

       allocate(to_calc_grads%ds_totsyms(3,N_moving_unique_atoms+N_pc), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%ds_totsyms on master failed")

       
       dim1=N_spheres*N_centers_on_sphere
       do i=1,N_moving_unique_atoms+N_pc
          if(i <= N_moving_unique_atoms) then
             na = moving_unique_atom_index(i)
             ea = unique_atoms(na)%n_equal_atoms
             grad_dim = grad_index(i+1) - grad_index(i)
          else
             na=i-N_moving_unique_atoms
             ea=pointcharge_array(na)%N_equal_charges
             grad_dim = surf_points_grad_index(na+1)-surf_points_grad_index(na)
          end if
          do j=1,3
                allocate(to_calc_grads%dxyz_totsyms(j,i)%m(3,dim1), &
                     stat=status)
                if ( status /= 0) call error_handler( &
                     "send_receive_geom_grad:allocation to_calc_grads%dxyz_totsyms%m on master failed")
		to_calc_grads%dxyz_totsyms(j,i)%m=0.0_r8_kind

                allocate(to_calc_grads%ds_totsyms(j,i)%m(dim1), &
                     stat=status)
                if ( status /= 0) call error_handler( &
                     "send_receive_geom_grad:allocation to_calc_grads%ds_totsyms%m on master failed")
		to_calc_grads%ds_totsyms(j,i)%m=0.0_r8_kind
          enddo
          do l=1,ea
	     if(i <= N_moving_unique_atoms) then 
                rotmat=>unique_atom_grad_info(i)%m(:,:,l)
             else
                rotmat=>surf_points_grad_info(na)%m(:,:,l)
             end if
             do j=1,grad_dim
                do ma=1,3
                   to_calc_grads%dxyz_totsyms(j,i)%m(:,:)=&
                        to_calc_grads%dxyz_totsyms(j,i)%m(:,:)+&
                        rotmat(j,ma)*cagr%dcenter(ma,i,l)%m(:,:)
                   
                   to_calc_grads%ds_totsyms(j,i)%m(:)=&
                        to_calc_grads%ds_totsyms(j,i)%m(:)+&
                        rotmat(j,ma)*cagr%darea(ma,i,l)%m(:)
                enddo
             enddo
          enddo
       enddo

       call dealloc_geom_deriv_part2()
       call dealloc_cavity()
    endif

    if(.not.comm_parallel()) RETURN
    ! RETURN POINT IF NOT PARALLEL

       if(comm_i_am_master()) then
          ! === context: master
          call comm_init_send(comm_all_slave_hosts,msgtag_geom_grad)

          call commpack(to_calc_grads%dielconst,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:dielconst pack failed")

          call commpack(with_pc,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:with_pc pack failed")
          call commpack(fixed_pc,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:fixed_pc pack failed")
          call commpack(to_calc_grads%n_points,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:n_points pack failed")
          call commpack(to_calc_grads%n_equal(1),to_calc_grads%n_points,1,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:n_equal pack failed")
          call commpack(dim,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:dim pack failed")
          call commpack(to_calc_grads%xyz(1,1,1),to_calc_grads%n_points*dim*3,1,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:n_equal xyz failed")
          call commpack(to_calc_grads%s(1),to_calc_grads%n_points,1,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:n_equal s failed")
          call commpack(to_calc_grads%Q(1),to_calc_grads%n_points,1,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:n_equal Q failed")
          call commpack(N_total,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:N_total pack failed")
          call commpack(group_num_el,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:group_num_el pack failed")
          call commpack(to_calc_grads%i_symm_sort(1,1),N_total*group_num_el,1,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:i_symm_sort pack failed")
          call commpack(ua_dim_max,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:ua_dim_max pack failed")
          call commpack(dim1,info)
          if(info/=0) call error_handler &
               ("send_receive_geom_grad:dim1 pack failed")
          do i=1,N_moving_unique_atoms+N_pc
!!$             na = moving_unique_atom_index(i)
             do j=1,3
!!!?dim1
                   call commpack(to_calc_grads%dxyz_totsyms(j,i)%m(1,1),3*dim1,1,info)
                   if(info/=0) call error_handler &
                        ("send_receive_geom_grad:dxyz pack failed")
             enddo
          enddo

          do i=1,N_moving_unique_atoms+N_pc
             do j=1,3
                call commpack(to_calc_grads%ds_totsyms(j,i)%m(1),dim1,1,info)
                if(info/=0) call error_handler &
                     ("send_receive_geom_grad:ds pack failed")
             enddo
          enddo

          call comm_send()

       else
       ! === context: slaves
       call comm_save_recv(comm_master_host,msgtag_geom_grad)

       call communpack(to_calc_grads%dielconst,info)
       if(info/=0) call error_handler &
               ("send_receive_geom_grad:dielconst unpack failed")

       call communpack(with_pc,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:with_pc unpack failed")

       call communpack(fixed_pc,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:fixed_pc unpack failed")

       N_pc=0
       if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N

       call communpack(to_calc_grads%n_points,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:n_points unpack failed")

       allocate(to_calc_grads%n_equal(to_calc_grads%n_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%n_equal on slave failed")
       call communpack(to_calc_grads%n_equal(1),to_calc_grads%n_points,1,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:n_equal unpack failed")

       call communpack(dim,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:dim unpack failed")

       allocate(to_calc_grads%xyz(to_calc_grads%n_points,dim,3), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%xyz on slave failed")
       call communpack(to_calc_grads%xyz(1,1,1),to_calc_grads%n_points*dim*3,1,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:xyz unpack failed")

       allocate(to_calc_grads%s(to_calc_grads%n_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%s on slave failed")
       call communpack(to_calc_grads%s(1),to_calc_grads%n_points,1,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:s unpack failed")

       allocate(to_calc_grads%Q(to_calc_grads%n_points), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%Q on slave failed")
       call communpack(to_calc_grads%Q(1),to_calc_grads%n_points,1,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:Q unpack failed")
       call dealloc_Q()

       call communpack(N_total,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:N_total unpack failed")

       call communpack(group_num_el,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:group_num_el unpack failed")

       allocate(to_calc_grads%i_symm_sort(N_total,group_num_el), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%i_symm_sort on slave failed")
       call communpack(to_calc_grads%i_symm_sort(1,1),N_total*group_num_el,1,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:i_symm_sort unpack failed")

       call communpack(ua_dim_max,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:ua_dim_max unpack failed")

       call communpack(dim1,info)
       if(info/=0) call error_handler &
            ("send_receive_geom_grad:dim1 unpack failed")

       allocate(to_calc_grads%dxyz_totsyms(3,N_moving_unique_atoms+N_pc), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%dxyz_totsyms on slave failed")

       allocate(to_calc_grads%ds_totsyms(3,N_moving_unique_atoms+N_pc), &
            stat=status)
       if ( status /= 0) call error_handler( &
            "send_receive_geom_grad:allocation to_calc_grads%ds_totsyms on slave failed")

       do i=1,N_moving_unique_atoms+N_pc
!!$          na = moving_unique_atom_index(i)
          do j=1,3
                allocate(to_calc_grads%dxyz_totsyms(j,i)%m(3,dim1), &
                     stat=status)
                if ( status /= 0) call error_handler( &
                     "send_receive_geom_grad:allocation to_calc_grads%dxyz_totsyms%m on slave failed")
                call communpack(to_calc_grads%dxyz_totsyms(j,i)%m(1,1),3*dim1,1,info)
                if(info/=0) call error_handler &
                     ("send_receive_geom_grad:dxyz_totsyms unpack failed")
	     
          enddo
       enddo

       do i=1,N_moving_unique_atoms+N_pc
          do j=1,3
             allocate(to_calc_grads%ds_totsyms(j,i)%m(dim1), &
                  stat=status)
             if ( status /= 0) call error_handler( &
                  "send_receive_geom_grad:allocation to_calc_grads%ds_totsyms%m on slave failed")
             call communpack(to_calc_grads%ds_totsyms(j,i)%m(1),dim1,1,info)
             if(info/=0) call error_handler &
                  ("send_receive_geom_grad:ds_totsyms unpack failed")
          enddo
       enddo
    endif

  end subroutine send_receive_geom_grad
  !*****************************************************

  !****************************************************
  subroutine dealloc_geom_grad
   !deallocates to_calc_grads
   !** End of interface *****************************************

    use unique_atom_module, only: N_moving_unique_atoms,unique_atoms,moving_unique_atom_index
    use pointcharge_module, only: pointcharge_N
    use comm_module
    use commpack_module   

    integer(kind=i4_kind) :: status
    integer(kind=i4_kind) :: i,j,l,ea,N_pc  

    N_pc=0
    if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N

    do i=1,N_moving_unique_atoms+N_pc
       do j=1,3
             deallocate(to_calc_grads%dxyz_totsyms(j,i)%m, &
                  stat=status)
             if ( status /= 0) call error_handler( &
                  "dealloc_geom_grad:deallocation to_calc_grads%dxyz_totsyms%m failed")

             deallocate(to_calc_grads%ds_totsyms(j,i)%m, &
                  stat=status)
             if ( status /= 0) call error_handler( &
                  "dealloc_geom_grad:deallocation to_calc_grads%ds_totsyms%m failed")
       enddo
    enddo
    deallocate(to_calc_grads%n_equal, &
         to_calc_grads%xyz, &
         to_calc_grads%Q, &
         to_calc_grads%i_symm_sort, &
         to_calc_grads%dxyz_totsyms, &
         to_calc_grads%ds_totsyms, &
         stat=status)
    if ( status /= 0) call error_handler( &
            "dealloc_geom_grad:deallocation to_calc_grad failed")
  end subroutine dealloc_geom_grad
  !****************************************************

  !***************************************************
  subroutine solv_elfield_transfer_data
   !** End of interface *****************************************

    use elec_static_field_module, only: N_surface_points,surface_points

    integer(kind=i4_kind) :: status
    integer(kind=i4_kind) :: i,j,k

    N_surface_points=n_size

    allocate(surface_points(N_surface_points),stat=status)
    if ( status /= 0) call error_handler( &
         "solv_elfield_transfer_data: allocation of surface_points is failed")

    do i=1,N_surface_points
       surface_points(i)%N_equal_points=tessarea(i)%n_equal
       allocate(surface_points(i)%position(3,surface_points(i)%N_equal_points),stat=status)
       if ( status /= 0) call error_handler( &
            "solv_elfield_transfer_data: allocation of surface_points%position is failed")
       do j=1,surface_points(i)%N_equal_points
          surface_points(i)%position(:,j)=tessarea(i)%xyz(j,:)
       enddo
       surface_points(i)%area=tessarea(i)%area
       k=tessarea(i)%sphere(1)
       surface_points(i)%out_normal=(tessarea(i)%xyz(1,:)-xyz_sphere(k,:))/ &
            sqrt(dot_product(tessarea(i)%xyz(1,:)-xyz_sphere(k,:),tessarea(i)%xyz(1,:)-xyz_sphere(k,:)))
    enddo

    if (do_correction)then
       call dealloc_cavity()
    endif

  end subroutine solv_elfield_transfer_data
  !******************************************************

  !******************************************************
  subroutine dealloc_cavity
   !deallocate tesserea
   !** End of interface *****************************************

    integer(kind=i4_kind) :: status
    integer(kind=i4_kind) :: i

    DPRINT 'dealloc_cavity: enetered'
    DPRINT 'dealloc_cavity: size(tessarea)=',size(tessarea)
    ASSERT(n_size==size(tessarea))
    do i=1,size(tessarea)
       deallocate(tessarea(i)%xyz, &
            tessarea(i)%sphere, stat=status)
       if (status .ne. 0 ) call error_handler( &
            "dealloc_cavity: deallocation of TESSAREA%XYZ  failed")
    enddo
    deallocate(tessarea,stat=status)
    if ( status /= 0) call error_handler( &
         "dealloc_cavity: deallocation TESSAREA is failed")
    
    DPRINT 'dealloc_cavity: shape(r_sphere)=', shape(r_sphere)
    deallocate(r_sphere, stat=status)
    if ( status /= 0) call error_handler( &
         "dealloc_cavity: deallocation r_sphere is failed")
    if(allocated(iuniq))  then
	deallocate(iuniq,stat=status)
       if ( status /= 0) call error_handler( &
            "dealloc_cavity: deallocation of iuniq is failed")
    endif

    DPRINT 'dealloc_cavity: shape(xyz_sphere)=',shape(xyz_sphere)
    deallocate(xyz_sphere, stat=status)
    if ( status /= 0) call error_handler( &
         "dealloc_cavity: deallocation xyz_sphere is failed")
    
    if(allocated(parents)) then
       deallocate(parents, stat=status)
       if ( status /= 0) call error_handler( &
            "dealloc_cavity: deallocation of parents is failed")
    endif

    if(allocated(zero_area)) then
       deallocate(zero_area, stat=status)
       if ( status /= 0) call error_handler( &
            "dealloc_cavity: deallocation of zero_area is failed")
    endif

  end subroutine dealloc_cavity
  !******************************************************

  !******************************************************
  subroutine const_part_of_ham_and_energy
    ! This subroutine calculates constant contributions to
    ! Hamiltonian and energy discribing interaction between
    ! solute molecule and point charges destributed on 
    ! cavity surface
    ! 1) The contribution to energy : interaction between
    !    solute nuclei and surface charges due to solute nuclei
    ! 2) The contributions to Hamiltonian:
    ! a- J-matrix (interaction between electronic part of the solute
    !    potential and point charges due to the nuclear part of the
    !    charge distribution of the solute molecule)
    ! b- Y-matrix (interaction between nuclear part of the solute
    !    potential and point charges due to the electronic part of the
    !    charge distribution of the solute molecule)
    ! because of both J and Y matrices have to be the same the program
    ! use only J matrix        
    !** End of interface *****************************************

    use potential_module
    use unique_atom_module, only :unique_atoms,N_unique_atoms
    use pointcharge_module, only: pointcharge_N,pointcharge_array
    use comm_module, only: comm_parallel,comm_all_slave_hosts,comm_init_send

    real(kind=r8_kind), allocatable :: V_buf(:),Q_n_buf(:)
    real(kind=r8_kind) :: Q_n_sum, Z_sum
    integer(kind=i4_kind) :: status,n_eql,next
    integer(kind=i4_kind) :: i,j,k

    ! 1) The contribution to energy : interaction between
    !    solute nuclei and surface charges due to solute nuclei
    call get_poten_n !get V_pot_n
    if(with_pc) call get_poten_pc() !get V_pot_pc
    ! V_pot_n and V_pot_e are point_in_space(i)%N_equal_points times
    ! the potential, because: The integrals contain theses factor,
    ! because the totalsymmetric sum of all equivalent spacepoints
    ! is used as operand.

    allocate(V_buf(N_points),stat=status)
    if ( status /= 0) call error_handler( &
         "const_part_of_ham_and_energy: allocation of V_buf is failed")


    do i=1,N_points
       n_eql=point_in_space(i)%N_equal_points
       V_buf(i)=V_pot_n(i)/real(n_eql,kind=r8_kind)
       if(with_pc) V_buf(i)=V_buf(i)+V_pot_pc(i)/real(n_eql,kind=r8_kind)
    enddo

    allocate(Q_n(N_points),stat=status)
    if ( status /= 0) call error_handler( &
         "const_part_of_ham_and_energy: allocation of Q_n is failed")

    ! calculation point charges due to the nuclear part of the solute molecule
    Q_n= -((dielectric_constant-1.0_r8_kind)/(dielectric_constant))* & 
         MATMUL(A_matrix_inv,V_buf)

         
    deallocate(V_buf,stat=status)
    if ( status /= 0) call error_handler( &
         "const_part_of_ham_and_energy: deallocation of V_buf is failed")

    !correction of point charges respect to Gauss equation
    Z_sum=0.0_r8_kind
    do i=1,N_unique_atoms
       Z_sum=Z_sum+unique_atoms(i)%N_equal_atoms*unique_atoms(i)%Z
    enddo
    if(with_pc) then
       do i=1,pointcharge_N
           Z_sum=Z_sum+pointcharge_array(i)%N_equal_charges*pointcharge_array(i)%Z
       end do
    end if
    Z_sum=-Z_sum*((dielectric_constant-1.0_r8_kind)/dielectric_constant)

    Q_n_sum=0.0_r8_kind
    do j=1,N_points
       n_eql=point_in_space(j)%N_equal_points
       Q_n_sum=Q_n_sum+real(n_eql,kind=r8_kind)*Q_n(j)
    enddo
    write (output_unit,*) 'SOLVENT EFFECT: Discretization error of nuclear part'
    write (output_unit,*) '(Q_n-Z_n)(e-1)/e', Q_n_sum-Z_sum
    write (output_unit,*) 'Q_n*(e-1)/e', Q_n_sum, 'Z_n*(e-1)/e', Z_sum

    correct_factor_n=Z_sum/Q_n_sum
!!! MF for gradients
    if(.not.cor_nuc) then
	if( (correct_factor_n-1.0_r8_kind)**2>1.e-4_r8_kind) then
		call write_to_output_units("solvation module: warning: large &
		& discretization error. It is recommended to choose smaller &
		& tessera size")
	endif
	correct_factor_n=1.0_r8_kind
    endif

    Q_n=correct_factor_n*Q_n

    ! E=(1/2)*Unn
    energy_core_n=0.0_r8_kind
    do i=1,N_points
       n_eql=point_in_space(i)%N_equal_points
       energy_core_n=energy_core_n+Q_n(i)*V_pot_n(i)*0.5_r8_kind
       if(with_pc) energy_core_n=energy_core_n+Q_n(i)*V_pot_pc(i)*0.5_r8_kind
    enddo
!!$print*,sum(V_pot_n(:))+sum(V_pot_pc(:))
    write (output_unit,*) 'CONSTANT PART OF SOLVATION ENERGY'
    write (output_unit,*) '(included in energy, not in spectra)'
    write (output_unit,*) energy_core_n,'Hartree'

    if(comm_parallel()) then 
       call send_receive_nuc_pot_Q()
    endif

    !--------------------

    ! 2) The contributions to Hamiltonian:
    ! a- J-matrix (interaction between electronic part of the solute
    !    potential and point charges due to the nuclear part of the
    !    charge distribution of the solute molecule)
    ! b- Y-matrix (interaction between nuclear part of the solute
    !    potential and point charges due to the electronic part of the
    !    charge distribution of the solute molecule)
    ! because of both J and Y matrices have to be the same the program
    ! use only J matrix

  end subroutine const_part_of_ham_and_energy
  !**********************************************************

  !*********************************************************
  subroutine send_receive_nuc_pot_Q
   !** End of interface *****************************************

    use commpack_module
    use comm_module, only : comm_i_am_master, comm_init_send, comm_send, &
         comm_all_slave_hosts
    use msgtag_module, only : msgtag_nuc_pot_Q
    use potential_module, only : N_points,V_pot_n

    integer(kind=i4_kind) :: status,info
    

    if (comm_i_am_master()) then
       call comm_init_send(comm_all_slave_hosts,msgtag_nuc_pot_Q)

       call commpack(Q_n,N_points,1,info)
       if( info.ne.0) call error_handler &
            ("solvation:pack of Q_n failed")

       call comm_send()
    else
       allocate(Q_n(N_points),stat=status)
       if ( status .ne. 0) call error_handler( &
            "solvation: allocated Q_n failed(1)" )


       call communpack(Q_n,N_points,1,info)
       if( info.ne.0) call error_handler &
            ("solvation:unpack of Q_n failed")
    endif

  end subroutine send_receive_nuc_pot_Q
  !*********************************************************

  !******************************************************
  subroutine build_solv_ham
   !setup the part of hamiltonian due to the electron-dependent
   !electrostatic interactions between solute and solvent
   !** End of interface *****************************************

    use potential_module
    use elec_static_field_module
    use occupation_module, only: get_n_elec
    use msgtag_module, only : msgtag_X_ham_start
    use comm_module
    use commpack_module
    use casc_logic_module
    use unique_atom_module, only :unique_atoms,N_unique_atoms

    real(kind=r8_kind), allocatable :: V_buf(:),Q_e_buf(:)
    real(kind=r8_kind) :: Q_e_sum, ne_sum , correct_factor_e
    real(kind=r8_kind) :: N_electrons
    integer(kind=i4_kind), allocatable :: vpn(:)
    integer(kind=i4_kind) :: status,info,n_eql,next,i_pr
    integer(kind=i4_kind) :: i,j,k

    DPRINT 'slv:build_solv_ham: eneterd'
    call start_read_poten_e

    call get_n_elec(N_electrons)

    allocate(V_buf(N_points),stat=status)
    if ( status /= 0) call error_handler( &
         "build_solv_ham: allocation of V_buf is failed")

    k=0
    do i=1,N_points
       n_eql=point_in_space(i)%N_equal_points
       V_buf(i)=V_pot_e(i)/real(n_eql,kind=r8_kind)
    enddo

    if(.not.allocated(Q_e)) then
       allocate(Q_e(N_points),stat=status)
       if ( status /= 0) call error_handler( &
            "build_solv_ham: allocation of Q_e is failed")
    endif

    Q_e= -((dielectric_constant-1.0_r8_kind)/(dielectric_constant))* &
         MATMUL(A_matrix_inv,V_buf)

    deallocate(V_buf,stat=status)
    if ( status /= 0) call error_handler( &
         "build_solv_ham: deallocation of V_buf is failed")

    if(charge_correction) then
       call start_read_field_e
       call effective_charges(N_electrons)
    end if

    ne_sum=N_electrons*((dielectric_constant-1.0_r8_kind)/dielectric_constant)

    Q_e_sum=0.0_r8_kind
    do j=1,N_points
       n_eql=point_in_space(j)%N_equal_points
       Q_e_sum=Q_e_sum+real(n_eql,kind=r8_kind)*Q_e(j)
    enddo
    print*,Q_e_sum-ne_sum,'Q_e_sum-ne_sum...',Q_e_sum,ne_sum
    correct_factor_e=ne_sum/Q_e_sum 

    if(.not.cor_el) then
        if( (correct_factor_e-correct_factor_n)**2>1.e-4_r8_kind) then
                call write_to_output_units("solvation module: warning: large &
                & discretization error. It is recommended to choose smaller &
                & tessera size")
        endif
        correct_factor_e=correct_factor_n
    endif

    Q_e=correct_factor_e*Q_e

    i_pr=comm_get_n_processors()

    if(comm_parallel()) then
       call send_receive_Q_e()
    endif

    allocate(vpn(i_pr),stat=status)
    if ( status /= 0) call error_handler( &
         "build_solv_ham: allocation of VPN is failed")

    call comp_vpn(vpn)

    if(comm_parallel()) then
       do i=2,i_pr
          call comm_init_send(i,msgtag_X_ham_start)
          call commpack(vpn(i),info)
          if(info /= 0) call error_handler('build_solv_ham: packing VPN is failed')
          call comm_send()
       enddo
    endif

    call X_part_of_ham(vpn(1))

    deallocate(vpn,stat=status)
    if ( status /= 0) call error_handler( &
         "build_solv_ham: deallocation of VPN is failed")    

  end subroutine build_solv_ham
  !******************************************************

  !******************************************************
  subroutine effective_charges(n_elec)
   !(for Mennucci type tailing correction)
   !** End of interface *****************************************

    use elec_static_field_module
    use potential_module

    real(kind=r8_kind),intent(in) :: n_elec

    integer(kind=i4_kind) :: i,status
    real(kind=r8_kind) :: Q_in,Q_out,rho_out
    real(kind=r8_kind),pointer :: rho(:,:)

    Q_in=0.0_r8_kind
    do i=1,N_surface_points
       Q_in=Q_in+E_n(i)*surface_points(i)%area*surface_points(i)%N_equal_points
    enddo
    Q_in=Q_in/(4.0_r8_kind*pi)

    Q_out=-(n_elec+Q_in)

    Q_out=-((dielectric_constant-1.0_r8_kind)/(dielectric_constant))*Q_out

    call calc_rho(rho)

    rho_out=0.0_r8_kind
    do i=1,N_points
       rho_out=rho_out+rho(i,1)*surface_points(i)%area*surface_points(i)%N_equal_points
    enddo

    do i=1,N_points
       Q_e(i)=Q_e(i)+Q_out*rho(i,1)*surface_points(i)%area/rho_out
    enddo

    deallocate(rho,stat=status)
    if ( status /= 0) call error_handler( &
         "effective_charges: deallocation of rho is failed")    

  end subroutine effective_charges
  !******************************************************

  !******************************************************
  subroutine calc_rho(rho1)
    !calculates electronic charge inside the cavity
    !(for Mennucci type tailing correction)
    !** End of interface *****************************************

    use density_calc_module
    use orbitalstore_module
    use orbital_module
    use machineparameters_module
    use symmetry_data_module, only: symmetry_data_n_spin
    use potential_module
    use msgtag_module, only: msgtag_start_rho,msgtag_finish_rho
    use comm_module
    use commpack_module

    real(kind=r8_kind),pointer,optional :: rho1(:,:)

    real(kind=r8_kind),pointer :: rho_local(:,:)
    integer(kind=i4_kind) :: i,status,j,my_ind,item_arr,first_i,i_pr,info,bound
    integer(kind=i4_kind) :: ispin,vec_length,vec_length_act
    type(orbital_type),pointer :: orbs_ob(:)
    real(kind=r8_kind),pointer  :: grid_surf(:,:)
    real(kind=r8_kind),allocatable  :: buff(:,:)
    type(poten_bounds)      :: bounds


    call get_bounds_poten(bounds)

    ispin=symmetry_data_n_spin()
    vec_length=machineparameters_veclen

    if(comm_i_am_master()) then
       allocate(rho1(vec_length,ispin),stat=status)
       if ( status /= 0) call error_handler( &
            "calc_rho: allocation of rho is failed")  
       rho1=0.0_r8_kind
    endif

    if(comm_parallel()) then
       if(comm_i_am_master()) then
          call comm_init_send(comm_all_slave_hosts,msgtag_start_rho)
          call comm_send()
       endif

       my_ind=comm_myindex()
       item_arr=bounds%item_arr(my_ind)
       if(item_arr==0) return
       first_i=1
       do i=1,my_ind-1
          first_i=first_i+bounds%item_arr(i)
       enddo
       allocate(grid_surf(item_arr,3),stat=status)
       if ( status /= 0) call error_handler( &
            "calc_rho: allocation of grid_surf(1) is failed")

       do j=first_i,first_i+item_arr-1
          grid_surf(j-first_i+1,:)=point_in_space(i)%position(:,1)
       enddo

       allocate(rho_local(vec_length,ispin),stat=status)
       if ( status /= 0) call error_handler( &
            "calc_rho: allocation of rho is failed")  
       rho_local=0.0_r8_kind

    else
       allocate(grid_surf(N_points,3),stat=status)
       if ( status /= 0) call error_handler( &
            "calc_rho: allocation of grid_surf is failed")        
       do i=1,N_points
          grid_surf(i,:)=point_in_space(i)%position(:,1)
       enddo
       rho_local=>rho1
    endif

    call orbital_setup(vec_length)
    call orbital_allocate(orbs_ob)

    vec_length_act=size(grid_surf,1)

    call orbital_calculate(grid_surf(1:vec_length_act,1:3),&
         vec_length_act,orbs_ob)
    call density_calc(vec_length_act,rho_local,orbs_ob)

    call orbital_free(orbs_ob)
    call orbital_shutdown()

    deallocate(grid_surf,stat=status)
    if ( status /= 0) call error_handler( &
         "effective_charges: deallocation of grid_surf is failed")        

    if(comm_parallel()) then
       if(comm_i_am_master()) then
          i_pr=comm_get_n_processors()
          bound=0
          do i=1,i_pr
             item_arr=bounds%item_arr(i)
             if(item_arr == 0) cycle
             if (i == 1) then
                rho1(bound+1:bound+item_arr,:)= rho_local(1:item_arr,:)
                deallocate(rho_local,stat=status)
                if ( status .ne. 0) call error_handler( &
                     "calc_rho: deallocated of rho_local failed(1)" )
             else
                call comm_save_recv(i,msgtag_finish_rho)

                allocate(buff(item_arr,ispin),stat=status)
                if ( status .ne. 0) call error_handler( &
                     "calc_rho: allocated buff failed" )

                call communpack(buff(1,1),item_arr*ispin,1,info)
                if( info.ne.0) call error_handler &
                     ("calc_rho:unpack of rho failed")
                rho1(bound+1:bound+item_arr,:)=buff

                deallocate(buff,stat=status)
                if ( status .ne. 0) call error_handler( &
                     "calc_rho: deallocated buff failed" )
             endif
             bound=bound+item_arr
          enddo
          if(ispin==2) rho1(:,1)=rho1(:,1)+rho1(:,2)
       else
          call comm_init_send(comm_master_host,msgtag_finish_rho)
          call commpack(rho_local(1,1),item_arr*ispin,1,info)
          if( info.ne.0) call error_handler &
               ("calc_rho:pack of rho_local failed")
          call comm_send()

          deallocate(rho_local,stat=status)
          if ( status /= 0) call error_handler( &
               "calc_rho: deallocation of rho_local is failed")    
       endif
    else
       if(ispin==2) rho1(:,1)=rho1(:,1)+rho1(:,2)
       return
    endif

  end subroutine calc_rho
  !******************************************************

  !******************************************************
  subroutine alloc_ham_solv
   !** End of interface *****************************************

    use symmetry_data_module  ! provide ssym

    integer(kind=i4_kind), allocatable :: dim_irrep(:)
    integer(kind=i4_kind)       :: n_irrep,status
    integer(kind=i4_kind)       :: n,i

    n_irrep = symmetry_data_n_irreps()

    allocate(dim_irrep(n_irrep),stat=status)
    if ( status .ne. 0) call error_handler( &
         "alloc_ham_solv: allocated dim_irrep failed" )

    do n=1,n_irrep
       dim_irrep(n) = symmetry_data_dimension(n)
    enddo

    allocate (ham_solv_el(n_irrep),STAT=status)
    if (status.ne.0) call error_handler &
         ("alloc_ham_solv: allocation of ham_solv_el failed ")

    do i=1,n_irrep
       allocate( ham_solv_el(i)%m(dim_irrep(i),dim_irrep(i)),STAT=status)
       if (status.ne.0) call error_handler &
            ("alloc_ham_solv: allocation of ham_solv_el(1) failed")

       ham_solv_el(i)%m=0.0_r8_kind
    enddo

    deallocate(dim_irrep,stat=status)
    if ( status .ne. 0) call error_handler( &
         "alloc_ham_solv: deallocated dim_irrep failed" )

  end subroutine alloc_ham_solv
  !******************************************************

  !******************************************************
  subroutine dealloc_ham_solv
   !** End of interface *****************************************

    use symmetry_data_module  ! provide ssym

    
    integer(kind=i4_kind)       :: n_irrep,status
    integer(kind=i4_kind)       :: i

    n_irrep = symmetry_data_n_irreps()

    do i=1,n_irrep
       deallocate( ham_solv_el(i)%m,STAT=status)
       if (status.ne.0) call error_handler &
            ("dealloc_ham_solv: deallocation of ham_solv_el(1) failed")
    enddo

    deallocate (ham_solv_el,STAT=status)
    if (status.ne.0) call error_handler &
         ("dealloc_ham_solv: deallocation of ham_solv_el failed ")

  end subroutine dealloc_ham_solv
  !******************************************************

  !******************************************************
  subroutine send_receive_Q_e
   !** End of interface *****************************************

    use commpack_module
    use comm_module, only : comm_i_am_master, comm_init_send, comm_send, &
         comm_all_slave_hosts
    use msgtag_module, only : msgtag_Q_elec
    use potential_module, only : N_points

    integer(kind=i4_kind) :: status,info
    

    if (comm_i_am_master()) then
       call comm_init_send(comm_all_slave_hosts,msgtag_Q_elec)

       call commpack(Q_e,N_points,1,info)
       if( info.ne.0) call error_handler &
            ("solvation:pack of Q_n failed")

       call comm_send()
    else
       if (.not. allocated(Q_e)) then
          allocate(Q_e(N_points),stat=status)
          if ( status .ne. 0) call error_handler( &
               "solvation: allocated Q_n failed(1)" )
       endif

       call communpack(Q_e,N_points,1,info)
       if( info.ne.0) call error_handler &
            ("solvation:unpack of Q_n failed")
    endif

  end subroutine send_receive_Q_e
  !******************************************************

  !******************************************************
  subroutine dealloc_Q
   !** End of interface *****************************************

    integer(kind=i4_kind) :: status

    if(allocated(Q_n)) then
       deallocate(Q_n,stat=status)
       if(status /= 0) call error_handler("dealloc_Q:deallocation Q_n failed")
    endif
    if(allocated(Q_e)) then
       deallocate(Q_e,stat=status)
       if(status /= 0) call error_handler("dealloc_Q:deallocation Q_e failed")
    endif

  end subroutine dealloc_Q
  !******************************************************

  !******************************************************
  subroutine X_part_of_ham(vpnx)
    ! The contribution to the Hamiltonian due to interaction
    ! of electrons with surface chares induced by the electrons
    ! themselfs
    !** End of interface *****************************************

    use options_module
    use potential_module
    use readwriteblocked_module
    use msgtag_module, only: msgtag_back_ham_solv
    use symmetry_data_module  ! provide ssym
    use comm_module
    use commpack_module
    use casc_logic_module
    use filename_module, only: tmp_dir
    use integralstore_module, only: integralstore_3c_poten

    integer(kind=i4_kind),optional :: vpnx

    type(readwriteblocked_tapehandle) :: th_poten
    type(poten_bounds)      :: bounds
    real(kind=r8_kind),pointer :: poten_int(:)
    real(kind=r8_kind), allocatable :: sum_x(:)
    real(kind=r8_kind), allocatable :: help_arr(:,:,:)
    integer(kind=i4_kind), allocatable :: dim_irrep(:)
    integer(kind=i4_kind), allocatable :: rpn(:)
    integer(kind=i4_kind)       :: item_arr_poten,my_ind,n_irrep,i_gamma, &
         first_i,n_eql,vpn1,vpn2,i_pr,di,nitem1, &
         lower_node, upper_node
    logical ::  integrals_on_file
    integer(kind=i4_kind) :: n,status,info,i_mn,m,n_mn,k,i,j,i_meta,i_last

    integrals_on_file=options_integrals_on_file()

    n_irrep = symmetry_data_n_irreps()

    allocate(dim_irrep(n_irrep),stat=status)
    if ( status .ne. 0) call error_handler( &
         "X_part_of_ham: allocated dim_irrep failed" )

    do n=1,n_irrep
       dim_irrep(n) = symmetry_data_dimension(n)
    enddo

    call get_bounds_poten(bounds)

    my_ind=comm_myindex()
    item_arr_poten=bounds%item_arr(my_ind)

    first_i=1
    do i=1,my_ind-1
       first_i=first_i+bounds%item_arr(i)
    enddo

    if(comm_i_am_master()) then
       if(present(vpnx)) then
          vpn1=vpnx
       else
          call error_handler &
               ("X_part_of_ham: where have you lost VPN ?")
       endif
    else
       call communpack(vpn1,1,1,info)
       if( info.ne.0) call error_handler &
            ("solvation:unpack of vpn1 failed")
    endif

    i_pr=comm_get_n_processors()

    allocate(rpn(2*i_pr-1),stat=status)
    if ( status .ne. 0) call error_handler( &
         "X_part_of_ham: allocation of rpn is  failed" )

!   call comp_rpn(rpn,i_pr)
    call comp_rpn(rpn)

    call alloc_ham_solv()

    if ( integrals_on_file ) then
       ! open the integral files ----------------------
       if (item_arr_poten /= 0) call poten_integral_open(th_poten)
    else
       i_meta=1
    endif

#ifndef _VECTOR
    if (integrals_on_file) then 
       allocate( poten_int(item_arr_poten),STAT=status)
       if(status.ne.0) call error_handler&
            ("X_part_of_ham: allocation of poten_int, poten_q failed")
    endif
#endif
    i_gamma_lab: do i_gamma = 1,n_irrep
       vpn2=vpn1

       n_mn = ( dim_irrep(i_gamma) * (dim_irrep(i_gamma) + 1) ) / 2

       if (item_arr_poten /= 0) then
          allocate( sum_x(n_mn), STAT=status )
          if (status.ne.0) call error_handler &
               ("X_part_of_ham: allocation of sum_x failed")
          sum_x = 0.0_r8_kind

#ifndef _VECTOR
          i_mn = 1
          do m=1,dim_irrep(i_gamma)
             do n=1,m
                ! read in integrals file
                if (integrals_on_file) then
                   call readwriteblocked_read(poten_int,th_poten) 
                else
                   i_last=i_meta+item_arr_poten-1
                   poten_int => integralstore_3c_poten(i_meta:i_last)
                   i_meta=i_last+1
                endif
                do k=1,item_arr_poten
                   sum_x(i_mn) =sum_x(i_mn)-poten_int(k)*Q_e(k+first_i-1)
                   sum_x(i_mn) =sum_x(i_mn)-poten_int(k)*Q_n(k+first_i-1)
                enddo
                i_mn = i_mn + 1
             enddo
          enddo
#else
          if ( integrals_on_file ) then
             allocate( poten_int(item_arr_poten*n_mn),STAT=status )
             if(status.ne.0) call error_handler &
                  ("potential_module: allocation of poten_int failed")
             call readwriteblocked_read(poten_int,th_poten) 
             do k=1,item_arr_poten
                do i_mn = 1, n_mn
                   sum_x(i_mn) =sum_x(i_mn)-poten_int(k+(i_mn-1)*item_arr_poten)*Q_e(k+first_i-1)
                   sum_x(i_mn) =sum_x(i_mn)-poten_int(k+(i_mn-1)*item_arr_poten)*Q_n(k+first_i-1)
                enddo
             enddo
             deallocate(poten_int,STAT=status)
             if(status.ne.0) call error_handler &
                  ("potential_modul: deallocation of poten_int failed")
          else
             do k=1,item_arr_poten
                do i_mn = 1, n_mn
                   sum_x(i_mn) =sum_x(i_mn)-integralstore_3c_poten(i_meta-1+k+(i_mn-1)*item_arr_poten)*Q_e(k+first_i-1)
                   sum_x(i_mn) =sum_x(i_mn)-integralstore_3c_poten(i_meta-1+k+(i_mn-1)*item_arr_poten)*Q_n(k+first_i-1)
                enddo
             enddo
             i_meta=i_meta+item_arr_poten*n_mn
          endif
#endif

          i_mn = 1
          do m=1,dim_irrep(i_gamma)
             do n=1,m-1
                ham_solv_el(i_gamma)%m(m,n) = sum_x(i_mn)
                ham_solv_el(i_gamma)%m(n,m) = sum_x(i_mn)
                i_mn = i_mn + 1
             enddo
             ham_solv_el(i_gamma)%m(m,m) = sum_x(i_mn)
             i_mn = i_mn + 1
          enddo

          deallocate( sum_x, STAT=status )
          if (status.ne.0) call error_handler &
               ("J_Y_part_of_ham: deallocation of sum_j or sum_y failed")
       endif

       !cascadic procedure sending Hamiltonian data to master
       if(2*(vpn1/2) == vpn1) then
          allocate(help_arr(dim_irrep(i_gamma),dim_irrep(i_gamma),1),stat=status)
          if (status.ne.0) call error_handler &
               ("J_Y_part_of_ham: allocation of help_arr failed")
       endif

       di=dim_irrep(i_gamma)
       nitem1=di*di

       vpn2_lab: do while(vpn2 > 1)
          if(mod(vpn2,2) == 0) then
             vpn2=vpn2/2
             lower_node=rpn(2*vpn2+1)

             call comm_save_recv(lower_node,msgtag_back_ham_solv)

             call communpack(help_arr(1,1,1),nitem1,1,info)
             if( info.ne.0) call error_handler &
                  ("solvation:unpack of help_arr  failed")

             ham_solv_el(i_gamma)%m=ham_solv_el(i_gamma)%m+help_arr(:,:,1)
          else
             upper_node=rpn((vpn2-1)/2)

             call comm_init_send(upper_node,msgtag_back_ham_solv)

             call commpack(ham_solv_el(i_gamma)%m(1,1),nitem1,1,info)
             if( info.ne.0) call error_handler &
                  ("solvation:pack of ham_solv_el  failed")

             call comm_send()
             vpn2=0
          endif
       enddo vpn2_lab
       if(mod(vpn1,2)==0) then 
          deallocate(help_arr,stat=status)
          if (status.ne.0) call error_handler &
               ("J_Y_part_of_ham: deallocation of help_arr is failed")
       endif
    enddo i_gamma_lab

#ifndef _VECTOR
    if (integrals_on_file) then 
       deallocate(poten_int,STAT=status)
       if(status.ne.0) call error_handler&
            ( "X_part_of_ham: deallocation of poten_int failed")
    endif
#endif

    if ( integrals_on_file ) then
       ! close the integral files ----------------------
       if (item_arr_poten /= 0) call poten_integral_close(th_poten)
    endif

    if(.not.comm_i_am_master()) call dealloc_ham_solv()

    deallocate(dim_irrep,stat=status)
    if ( status .ne. 0) call error_handler( &
         "X_part_of_ham: deallocated dim_irrep failed" )
    deallocate(rpn,stat=status)
    if ( status .ne. 0) call error_handler( &
         "X_part_of_ham: deallocation of rpn is  failed" )

  end subroutine X_part_of_ham
  !**************************************************

  !**************************************************
  subroutine solv_energy_el
   ! addition of different electrostatic parts of energy due
   ! to solvent polarization
   !** End of interface *****************************************

    use potential_module

    integer(kind=i4_kind) :: i

    energy_solv_el=0.0_r8_kind
    do i=1,N_points
       energy_solv_el=energy_solv_el+(Q_e(i)*V_pot_n(i)+Q_e(i)*V_pot_e(i)+ &
            Q_n(i)*V_pot_e(i))*0.5_r8_kind
       if(with_pc) energy_solv_el=energy_solv_el+Q_e(i)*V_pot_pc(i)*0.5_r8_kind
    enddo

    energy_solv_el=energy_solv_el+energy_core_n


  end subroutine solv_energy_el
  !**************************************************

  !**************************************************
  subroutine nuc_grad(grad_index,keep_tes_grads)
   !calculates and adds the part of gradient 
   !(induced charges) * (gradient of electrostatic potential due to nuclei) 
   !** End of interface *****************************************

    use unique_atom_module
    use pointcharge_module, only : pointcharge_array, pointcharge_N
    use elec_static_field_module

    integer(kind=i4_kind), intent(in) :: grad_index(N_moving_unique_atoms + 1)
    logical :: keep_tes_grads

    real(kind=r8_kind)          :: za,dist,zca,Q
    integer(kind=i4_kind)       :: ma,ma1,na,na1,index,grad_dim,i,j,k,l,m,n,i1,ea,nn,kk
    integer(kind=i4_kind)       :: n_equal_p,n_equal_a,ism
    real(kind=r8_kind),pointer  :: xa(:,:),xb(:,:),rotmat(:,:)
    real(kind=r8_kind) :: dr_n(3,3),dr_ts(3,3)
    real(i8_kind) :: unit(3,3)=reshape((/1.0_r8_kind,0.0_r8_kind,0.0_r8_kind, &
                                         0.0_r8_kind,1.0_r8_kind,0.0_r8_kind, &
                                         0.0_r8_kind,0.0_r8_kind,1.0_r8_kind/), &
                                       (/3,3/))
    integer :: N_pc,N_pc1

    N_pc=0; N_pc1=0
    if(with_pc .and. .not.fixed_pc) N_pc=pointcharge_N
    if(with_pc) N_pc1=pointcharge_N

    unique1: do ma=1,N_moving_unique_atoms+N_pc
       if(ma <= N_moving_unique_atoms) then
          na = moving_unique_atom_index(ma)
          ea = unique_atoms(na)%n_equal_atoms
          na1=na
       else
          na=ma-N_moving_unique_atoms
          ea=pointcharge_array(na)%N_equal_charges
          na1=na+N_unique_atoms
       end if
       
       unique3: do j=1,to_calc_grads%n_points
          xb => to_calc_grads%xyz(j,:,:)
          n_equal_p=to_calc_grads%n_equal(j)
          Q=to_calc_grads%Q(j)

          unique4: do k=1,n_equal_p
             ism=to_calc_grads%i_symm_sort(j,k)

             unique5: do l=1,N_unique_atoms+N_pc1
                if(l <= N_unique_atoms) then
                   n_equal_a=unique_atoms(l)%n_equal_atoms
                   za = unique_atoms(l)%Z
                   xa => unique_atoms(l)%position
                   zca = unique_atoms(l)%ZC
                   if (.not.pseudopot_present) zca = 0.0_r8_kind
                   za=za-zca
                else
                   n_equal_a=pointcharge_array(l-N_unique_atoms)%N_equal_charges
                   za=pointcharge_array(l-N_unique_atoms)%Z
                   xa => pointcharge_array(l-N_unique_atoms)%position
                end if

                unique6: do m=1,n_equal_a
                   if(ma <= N_moving_unique_atoms) then
                      grad_dim=grad_index(ma+1)-grad_index(ma)
                      rotmat=>unique_atom_grad_info(ma)%m(:,:,1)
                      index=grad_index(ma)
                   else
                      ma1=ma-N_moving_unique_atoms
                      grad_dim=surf_points_grad_index(ma1+1)-surf_points_grad_index(ma1)
                      rotmat=>surf_points_grad_info(ma1)%m(:,:,1)
                      index=surf_points_grad_index(ma1)
                   end if

                   dr_n = 0.0_r8_kind
                   if(l == na1 .and. m == 1) dr_n=unit
                   dr_ts=0.0_r8_kind
                   do nn=1,grad_dim
                      do kk=1,3
                         dr_ts(nn,kk)=dr_ts(nn,kk)+dot_product(rotmat(nn,:),dr_n(:,kk))*ea
                      end do
                   end do

                   dist = sqrt(sum((xa(:,m)-xb(k,:))**2))

                   if(ma <= N_moving_unique_atoms) then
                      do i1=1,grad_dim
                         grad_solv_totsym(index) = grad_solv_totsym(index) - &
                              (za*Q/dist**3)*dot_product((xa(:,m)-xb(k,:)), &
                              (dr_ts(i1,:) - to_calc_grads%dxyz_totsyms(i1,ma)%m(:,ism)))
                         if(keep_tes_grads) then
                            grad_solv_totsym_tes(index,j) = grad_solv_totsym_tes(index,j) - &
                                 (za*Q/dist**3)*dot_product((xa(:,m)-xb(k,:)), &
                                 (dr_ts(i1,:) - to_calc_grads%dxyz_totsyms(i1,ma)%m(:,ism)))
                         end if
                         index=index+1
                      end do
                   else
                      do i1=1,grad_dim
                         totalsym_field(index) = totalsym_field(index) + &
                              (za*Q/dist**3)*dot_product((xa(:,m)-xb(k,:)), &
                              (dr_ts(i1,:) - to_calc_grads%dxyz_totsyms(i1,ma)%m(:,ism)))
                         index=index+1
                      end do
                   endif
                enddo unique6
             enddo unique5
          enddo unique4
       enddo unique3
    enddo unique1

  end subroutine nuc_grad
  !****************************************************************

  !****************************************************************
  subroutine init_forces_on_pc()
    use elec_static_field_module, only: totalsym_field

    totalsym_field=0.0_r8_kind

  end subroutine init_forces_on_pc
  !****************************************************************

  !****************************************************************
  subroutine solv_forces_on_pc()

    use elec_static_field_module, only: N_surface_points,surface_points,transform_to_cart_field
    use elec_static_field_module, only: totalsym_field

    integer :: status,i,j

    allocate(F_solv_pc(N_surface_points),stat=status)
    if ( status .ne. 0) call error_handler( &
         "solv_forces_on_pc: allocated  F_solv_pc failed" )

    do i=1,N_surface_points
       allocate(F_solv_pc(i)%m(3,surface_points(i)%N_equal_points),stat=status)
       if (status .ne. 0) call error_handler( &
            "solv_forces_on_pc: allocated F_solv_pc%m failed" )
    end do

    call transform_to_cart_field(F_solv_pc,totalsym_field)
!!$do i=1,N_surface_points
!!$do j=1,surface_points(i)%N_equal_points
!!$write(output_unit,'(a20,3F20.12)') ' ',F_solv_pc(i)%m(:,j)
!!$write(*,'(a20,3F20.12)') ' ',F_solv_pc(i)%m(:,j)
!!$end do
!!$end do

    totalsym_field=0.0_r8_kind

  end subroutine solv_forces_on_pc
  !****************************************************************

  !****************************************************************
  subroutine dealloc_solv_pc()

    use elec_static_field_module, only: N_surface_points

    integer :: status,i

    if(allocated(F_solv_pc)) then
       do i=1,N_surface_points
          deallocate(F_solv_pc(i)%m,stat=status)
          if ( status .ne. 0) call error_handler( &
               "solv_forces_on_pc:deallocation of F_solv_pc%m is failed" )
       end do
       deallocate(F_solv_pc,stat=status)
       if ( status .ne. 0) call error_handler( &
            "solv_forces_on_pc: deallocated  F_solv_pc failed" )
    end if

  end subroutine dealloc_solv_pc
  !****************************************************************

  !****************************************************************
  subroutine shutdown_solvation
   !deallocates some used variables
   !** End of interface *****************************************
  use comm_module
  use msgtag_module
  use potential_module, only: deallocate_pot,bounds_free_poten,destroy_poten_file,dealloc_space_points
  use elec_static_field_module, only: deallocate_field, bounds_free_field,destroy_field_file, &
       dealloc_surf_points


           !delete everything connected with solvation effect
           call deallocate_pot()                             !!!!!!!!!!!!!!!!!!!!!!!
           call bounds_free_poten()                          !!!!!!!!!!!!!!!!!!!!!!!
	   call dealloc_A_inv()                              !!!!!!!!!!!!!!!!!!!!!!!
           if(comm_parallel()) then
              call comm_init_send(comm_all_slave_hosts,msgtag_del_poten) !!!!!!!!!!!
              call comm_send()                                           !!!!!!!!!!!
           endif
           call destroy_poten_file()                                  !!!!!!!!!!!
           call dealloc_space_points()
           if (charge_correction) then 
              call deallocate_field()    !!!!!!!!!!!!!!!!!!!!!!!
              call bounds_free_field()   !!!!!!!!!!!!!!!!!!!!!!!
              if(comm_parallel()) then
                 call comm_init_send(comm_all_slave_hosts,msgtag_del_field) !!!!!!!!
                 call comm_send()                                           !!!!!!!!
              endif
              call destroy_field_file()                                  !!!!!!!!
              call dealloc_surf_points()                                 !!!!!!!!
           endif

  end subroutine shutdown_solvation

end module solvation_module

